# Стандартизация Технологического Стека Микросервисов

**Версия:** 1.0
**Дата последнего обновления:** 2024-07-16

## 1. Введение

Данный документ определяет стандартизированный технологический стек для всех микросервисов российского аналога платформы Steam. Цель стандартизации — обеспечить согласованность, упростить разработку, тестирование и поддержку, а также повысить эффективность команды разработки.

Стандарты разработаны с учетом использования Go в качестве основного языка программирования для бэкенда, PostgreSQL в качестве основной базы данных и Flutter для фронтенда.

## 2. Основной Технологический Стек

### 2.1. Языки программирования
*   **Бэкенд (основной)**: Go (версия 1.21+) - используется для большинства микросервисов.
*   **Бэкенд (специализированные задачи/унаследованные компоненты)**:
    *   Java/Kotlin (Spring Boot): Рассматривается для Payment Service и, возможно, Notification Service, где уже может быть экспертиза или специфичные требования интеграций.
    *   Python: Может использоваться для задач Analytics Service (обработка данных, ML) и отдельных компонентов Social Service.
*   **Фронтенд**: Dart (версия 3.0+), Flutter (версия 3.10+)
*   **Скрипты**: Python (версия 3.10+), Bash

### 2.2. Базы данных
*   **Реляционная СУБД (основная для большинства сервисов)**: PostgreSQL (версия 15+)
*   **Кэширование и In-Memory**: Redis (версия 7.0+) - для кэширования, управления сессиями, очередей, rate limiting.
*   **Полнотекстовый Поиск и Аналитика**: Elasticsearch (версия 8.x+) - используется Catalog Service, Admin Service.
*   **Аналитическая СУБД (DWH)**: ClickHouse - используется Analytics Service, Notification Service (для статистики).
*   **NoSQL (Колоночные)**: Apache Cassandra - используется Social Service (для чатов, лент активности).
*   **NoSQL (Графовые)**: Neo4j - используется Social Service (для социального графа).
*   **NoSQL (Документо-ориентированные)**: MongoDB - используется Admin Service (для логов аудита, сложных структур модерации).
*   **Хранилище объектов (Object Storage)**: S3-совместимое хранилище (MinIO, Yandex Object Storage, etc.) - используется Download Service, Catalog Service, Developer Service, Library Service (для билдов, медиа-контента, сохранений игр).

### 2.3. Очереди сообщений и Потоковая обработка
*   **Основной брокер сообщений**: Apache Kafka (версия 3.x+) - для асинхронного обмена событиями между большинством сервисов.
*   **Потоковая обработка (если требуется)**: Kafka Streams, Apache Flink (для Analytics Service).
*   *Примечание: NATS был упомянут как альтернатива, но Kafka является преобладающим выбором в документации сервисов.*

### 2.4. Инфраструктура
*   **Контейнеризация**: Docker
*   **Оркестрация**: Kubernetes (версия 1.25+)
*   **CI/CD**: GitLab CI/CD или Jenkins (или GitHub Actions, если используется).
*   **Хостинг: Проект будет размещен на мощностях российского хостинг-провайдера Beget. Облачные сервисы (S3-совместимые хранилища, базы данных, Kubernetes), если используются, будут от российских провайдеров (например, Yandex Cloud, VK Cloud, SberCloud), совместимых с инфраструктурой Beget или как часть гибридного решения.**
*   **Мониторинг**: Prometheus + Grafana. Alertmanager для оповещений.
*   **Логирование**: Fluent Bit / Fluentd + Elasticsearch/ClickHouse/Loki + Kibana/Grafana.
*   **Трассировка**: OpenTelemetry + Jaeger/Tempo.
*   **Управление секретами**: HashiCorp Vault или Kubernetes Secrets (с шифрованием at-rest).

### 2.5. Ключевые Интеграции с Российскими Сервисами
*   **Платежные шлюзы:** ЮKassa, Тинькофф Касса, Сбербанк (SberPay), ВТБ (Эквайринг), Система быстрых платежей (СБП).
*   **Сервисы Авторизации:** ВКонтакте (OAuth), Telegram (Telegram Login).
*   **Фискализация:** Интеграция с Оператором Фискальных Данных (ОФД) согласно 54-ФЗ.

## 3. Стандарты Разработки на Go

### 3.1. Версия Go
*   Использовать Go версии 1.21 или выше.
*   Обновлять версию Go не реже одного раза в год.
*   Использовать одну версию Go для всех микросервисов.

### 3.2. Структура проекта
*   Следовать стандартной структуре Go-проекта (см. документ по инфраструктурным файлам).
*   Использовать модули Go (`go.mod`).
*   Разделять код на пакеты по функциональности.

### 3.3. Стиль кода и Линтинг
*   Официальный стиль Go (`gofmt` и `goimports`).
*   Линтеры (`golangci-lint`) с единой конфигурацией, хранящейся в общем репозитории (`platform-linters-config` или аналогичном).
*   Принципы чистого кода (например, SOLID, DRY, KISS) и идиоматического Go.

### 3.4. Обработка ошибок
*   Явная проверка ошибок (`if err != nil`).
*   Оборачивание ошибок для добавления контекста (например, `fmt.Errorf("module: operation failed: %w", err)` или использование библиотек типа `github.com/pkg/errors`).
*   Определение кастомных типизированных ошибок для доменной логики, где это необходимо для программной обработки.
*   Централизованное логирование ошибок на верхнем уровне обработчика запроса или в специализированных middleware/interceptors.

### 3.5. Конкурентность
*   Эффективное использование горутин и каналов.
*   Использование пакета `context` для управления жизненным циклом запросов и таймаутами.
*   Применение примитивов синхронизации из пакета `sync` (Mutex, RWMutex, WaitGroup, etc.) там, где это необходимо для защиты разделяемых ресурсов.
*   Избегать глобальных переменных для изменяемого состояния.

### 3.6. Производительность
*   Использование пулов ресурсов (например, для соединений с БД).
*   Буферизация I/O операций.
*   Регулярное профилирование (`pprof`) критичных участков кода.
*   Оптимизация запросов к БД.

## 4. Стандарты Работы с PostgreSQL (и другими реляционными СУБД)

### 4.1. Подключение
*   Использование пула соединений (например, `pgxpool` для `pgx`, или встроенный в GORM).
*   Управление контекстом (`context.Context`) для запросов, включая таймауты.

### 4.2. ORM и SQL
*   **Основной ORM (Go):** GORM (`gorm.io/gorm`) с соответствующим драйвером (например, `gorm.io/driver/postgres`).
*   **SQL Builder (Go, для сложных запросов):** Squirrel (`github.com/Masterminds/squirrel`) или аналогичный, если ORM не покрывает потребности.
*   **Драйвер PostgreSQL (Go, для низкоуровневой работы):** `pgx` (`github.com/jackc/pgx/v5`).
*   Всегда использовать параметризованные запросы или ORM-методы, предотвращающие SQL-инъекции.

### 4.3. Миграции Схемы
*   Использовать инструменты управления миграциями, такие как `golang-migrate/migrate` или встроенные возможности ORM (если есть и удовлетворяют требованиям).
*   Миграции должны храниться в системе контроля версий вместе с кодом сервиса.
*   Автоматическое применение миграций при развертывании или через CI/CD пайплайн.

### 4.4. Транзакции
*   Использовать транзакции для всех операций, требующих атомарности (например, несколько связанных записей в БД).
*   Применять паттерн Unit of Work, где это целесообразно.
*   Обеспечивать корректную обработку ошибок и откат транзакций.

### 4.5. Индексы и Оптимизация
*   Создавать индексы для полей, часто используемых в условиях `WHERE`, `JOIN`, `ORDER BY`.
*   Регулярно анализировать производительность запросов с помощью `EXPLAIN ANALYZE`.
*   Использовать частичные индексы и другие специфичные для PostgreSQL возможности оптимизации при необходимости.
*   Настраивать регулярные задачи `VACUUM` и `ANALYZE` (часто управляется самим PostgreSQL).

## 5. Стандарты Разработки на Flutter (Клиентское приложение)

### 5.1. Версия Flutter и Dart
*   Flutter 3.10+, Dart 3.0+. Обновление не реже раза в полгода.

### 5.2. Архитектура приложения
*   Чистая архитектура (Presentation, Domain, Data). DI (`get_it` или `provider`). Паттерн Repository.

### 5.3. Управление состоянием
*   Основной подход: BLoC (`flutter_bloc`).
*   Альтернативы: Riverpod, Provider, GetX (для прототипов).
*   Предпочтение локальному состоянию. Иммутабельные модели.

### 5.4. Структура проекта (Пример)
```
flutter_app/
├── android/
├── ios/
├── lib/
│   ├── app/         # Настройки, маршруты, темы
│   ├── core/        # Общие компоненты, утилиты
│   ├── data/        # Источники данных, модели, репозитории (реализация)
│   ├── domain/      # Бизнес-логика, сущности, интерфейсы репозиториев, use cases
│   ├── presentation/ # UI (BLoC, страницы, виджеты)
│   ├── di/          # Внедрение зависимостей
│   └── main.dart    # Точка входа
├── test/
└── pubspec.yaml
```

### 5.5. Стиль кода
*   Официальный стиль Dart (`dartfmt`). Линтеры (`dart_code_metrics`, `flutter_lints`). `analysis_options.yaml`.

### 5.6. Работа с API
*   `dio` или `http`. Interceptors. Модели для сериализации/десериализации (`json_serializable` или `freezed`).

### 5.7. Кэширование и локальное хранение
*   `shared_preferences` (простые настройки). `hive` или `sqflite` (данные). `flutter_secure_storage` (чувствительные данные). Стратегия кэширования для оффлайн-режима.

### 5.8. Локализация
*   `flutter_localizations` и `intl`. ARB-файлы. Генерация кода. Поддержка ru, en.

### 5.9. Навигация
*   `go_router` или `auto_route`. Именованные маршруты. Вложенная навигация. Deep links.

### 5.10. Оптимизация производительности
*   `const` конструкторы. `ListView.builder`, `GridView.builder`. `cached_network_image`. `compute` для тяжелых вычислений. Профилирование.

### 5.11. Особенности десктопной разработки
*   Адаптивный дизайн. Десктоп-специфичные виджеты. Оптимизация для мыши/клавиатуры. `flutter_acrylic`. Drag and drop.

## 6. Библиотеки и Фреймворки

### 6.1. HTTP-сервер (Go)
*   **Основной:** Echo (`github.com/labstack/echo/v4`).
*   Альтернативы: Gin, Chi, Fiber.

### 6.2. gRPC (Go)
*   **Основной:** `google.golang.org/grpc`.
*   Генерация: `protoc-gen-go-grpc`. Валидация: `protoc-gen-validate`. Документация: `protoc-gen-doc`.

### 6.3. Работа с базами данных (Go)
*   **PostgreSQL:** ORM GORM, драйвер pgx, миграции golang-migrate.
*   **Redis:** Клиент `go-redis/redis`, кэширование `go-redis/cache`.
*   **Kafka:** Клиент `segmentio/kafka-go`, обработка `ThreeDotsLabs/watermill-kafka`.
*   **NATS:** Клиент `nats-io/nats.go`.

### 6.4. Конфигурация (Go)
*   **Основной:** Viper (`github.com/spf13/viper`).
*   Переменные окружения: `godotenv`. Флаги: `cobra`.

### 6.5. Логирование (Go)
*   **Основной:** Zap (`github.com/uber-go/zap`). JSON-формат.

### 6.6. Трассировка и метрики (Go)
*   OpenTelemetry, Prometheus client, `otelgorm`.

### 6.7. Валидация (Go)
*   `go-playground/validator/v10`.

### 6.8. Авторизация и аутентификация (Go)
*   JWT: `golang-jwt/jwt/v5`. OAuth2: `golang.org/x/oauth2`. RBAC: `casbin/casbin/v2`.

### 6.9. Frontend (Flutter/Dart) - Основные Библиотеки и Пакеты
*   **State Management:**
    *   **`flutter_bloc` / `bloc`** (Primary)
    *   *Alternatives:* `provider`, `riverpod`.
*   **Routing / Navigation:**
    *   **`go_router`** (Primary)
    *   *Alternative:* `auto_route`.
*   **HTTP Client:**
    *   **`dio`** (Primary)
    *   *Alternative:* `http` (standard Dart package).
    *   *(Specialized network libraries like `grpc`, `web_socket_channel` can be used as needed.)*
*   **Local Storage:**
    *   **`hive` / `hive_flutter`**
    *   **`shared_preferences`**
    *   **`flutter_secure_storage`**
    *   *Alternative for SQL:* `sqflite`.
*   **JSON Serialization/Deserialization:**
    *   **`json_serializable`** (build_runner based)
    *   **`freezed`** (often used with `json_serializable` for model generation).
*   **Equality & Immutability for Models:**
    *   **`equatable`**
    *   **`freezed`** (also covers this).
*   **Dependency Injection:**
    *   **`get_it`** (Primary)
    *   *Alternative:* `injectable` (code generator for `get_it`).
*   **Testing:**
    *   **`flutter_test`** (SDK testing framework for unit and widget tests)
    *   **`bloc_test`** (for testing BLoCs/Cubits)
    *   **`mockito` / `mocktail`** (for creating mock objects)
    *   **`integration_test`** (SDK testing framework for integration tests).
*   **Linting:**
    *   **`flutter_lints` / `lints`** (Official lint rules)
    *   **`dart_code_metrics`** (Additional static analysis).
*   **Localization / Internationalization (i18n):**
    *   **`intl`** package with Flutter's `flutter_localizations` delegate.
*   **Utility:**
    *   **`dartz`** (Functional programming utilities)
    *   **`cached_network_image`** (For image caching; other UI utility libraries like `flutter_screenutil`, `flutter_svg`, `shimmer` can be used as per design needs).
*   **Аналитика/Мониторинг:** Для сбора ошибок и анализа производительности будет использоваться российский сервис (например, AppMetrica) или self-hosted Sentry. `flutter_fimber` или аналоги для логирования. Использование `firebase_crashlytics` исключено.
*   *Примечание: Выбор конкретных библиотек из альтернатив и их версии должны быть зафиксированы и согласованы командой frontend-разработки. Список приоритетных библиотек также отражен в `PACKAGE_STANDARDIZATION.md`.*

### 6.10. Тестирование (Go)
*   `testing`, `testify/mock`, `testify/assert`, `net/http/httptest`, `testcontainers-go`.

## 7. Управление Зависимостями

### 7.1. Версионирование
*   SemVer. Фиксация версий в `go.mod` / `pubspec.yaml`. Регулярное обновление.

### 7.2. Внутренние библиотеки
*   Отдельные репозитории, версионирование.

### 7.3. Управление вендорами (Go)
*   `go mod vendor` (при необходимости). `GOPROXY`.

### 7.4. Управление пакетами (Flutter)
*   `pub get`, `pub upgrade`, `pub outdated`. Стабильные версии.

## 8. Тестирование

### 8.1. Модульные тесты (Go)
*   Для всех публичных функций/методов. Табличные тесты. Моки. Покрытие > 80%.

### 8.2. Интеграционные тесты (Go)
*   `testcontainers`. Взаимодействие с реальными системами. Изоляция.

### 8.3. Нагрузочные тесты (Go)
*   k6. Определение SLO. Включение в CI/CD.

### 8.4. Тестирование Flutter
*   Модульные, виджет-тесты, интеграционные, скриншот-тесты, тестирование производительности.

### 8.5. Тестирование в CI/CD
*   Запуск всех тестов. Блокировка мержа при падении. Отчеты о покрытии. Матрицы тестирования.

## 9. Документация

### 9.1. Документация кода (Go)
*   godoc. Примеры использования. Генерация `go doc` / `godoc`.

### 9.2. Документация кода (Flutter)
*   dartdoc. Примеры. Генерация `dart doc`.

### 9.3. API-документация
*   OpenAPI (Swagger) для REST. `protoc-gen-doc` для gRPC. Хранение в репозитории. Автогенерация.

### 9.4. Документация для разработчиков
*   README.md (установка, запуск). Архитектура, компоненты. Процессы разработки.

## 10. Заключение

Стандартизация технологического стека важна для согласованности, упрощения разработки и поддержки. Выбор Go для бэкенда, PostgreSQL для БД и Flutter для фронтенда обеспечивает производительность и кроссплатформенность. Следование данным стандартам обеспечит высокое качество и масштабируемость платформы. Стандарты должны регулярно пересматриваться.

# Спецификация Микросервиса: API Gateway

**Версия:** 1.0
**Дата последнего обновления:** {{YYYY-MM-DD}} <!-- TODO: Update date -->

## 1. Обзор Сервиса (Overview)

### 1.1. Назначение и Роль
*   **Назначение документа:** Данный документ представляет собой полную спецификацию микросервиса API Gateway для российского аналога платформы Steam. Он описывает назначение, архитектуру, функциональные возможности, конфигурацию, интеграции и нефункциональные требования.
*   **Роль в общей архитектуре платформы:** API Gateway выступает в роли фасада для всей микросервисной архитектуры платформы. Он принимает все входящие запросы от внешних клиентов, выполняет общие задачи (аутентификация, авторизация, rate limiting, CORS) и маршрутизирует запросы к соответствующим внутренним микросервисам.
*   **Основные бизнес-задачи:**
    *   Предоставление единой, стабильной и безопасной точки входа для всех типов внешних клиентов.
    *   Абстрагирование внутренней сложности и топологии микросервисов.
    *   Централизация и унификация применения сквозных политик.
    *   Упрощение разработки клиентских приложений.
    *   Повышение уровня безопасности системы.
    *   Обеспечение гибкости для рефакторинга и масштабирования внутренних сервисов.

### 1.2. Ключевые Функциональности
*   Маршрутизация запросов (Path-based, Host-based, Method-based, Header-based, Path rewriting).
*   Аутентификация и Авторизация (интеграция с Auth Service, валидация JWT, API-ключи, передача контекста пользователя).
*   Ограничение скорости (Rate Limiting) на основе IP, user_id, API-ключа.
*   Управление CORS.
*   Безопасность (SSL/TLS Termination, защита от базовых атак, интеграция с WAF).
*   Мониторинг и Логирование (сбор метрик, детальное логирование, поддержка распределенной трассировки).
*   Обработка ошибок (стандартизированные сообщения, обработка таймаутов).
*   Обнаружение сервисов (Service Discovery) через интеграцию с Kubernetes.
*   Трансформация запросов/ответов (опционально).
*   Поддержка WebSocket (опционально).
*   Динамическое управление конфигурацией.

### 1.3. Основные Технологии
*   Рекомендуемые готовые решения: Kong Gateway (Nginx, Lua/OpenResty) или Tyk Gateway (Go).
*   Оркестрация: Kubernetes (v1.21+).
*   Контейнеризация: Docker.
*   Обнаружение сервисов: Kubernetes Services.
*   Мониторинг: Prometheus + Grafana.
*   Логирование: Loki + Promtail или ELK Stack.
*   Трассировка: Jaeger или Tempo.
*   Управление конфигурацией: Git, Kubernetes ConfigMaps/Secrets, CRDs (Kong/Tyk/Gateway API).
*   Балансировщик/Ingress: Nginx Ingress Controller или Traefik Proxy.

### 1.4. Термины и Определения (Glossary)
*   **API Gateway**: Компонент инфраструктуры, предоставляющий единую точку входа для клиентских приложений к API бэкенд-сервисов.
*   **Маршрутизация (Routing)**: Процесс направления входящего запроса к соответствующему внутреннему сервису.
*   **Аутентификация (Authentication)**: Проверка подлинности клиента.
*   **Авторизация (Authorization)**: Проверка прав доступа аутентифицированного клиента.
*   **Ограничение скорости (Rate Limiting)**: Механизм контроля количества запросов.
*   **CORS (Cross-Origin Resource Sharing)**: Механизм безопасности браузера для междоменных запросов.
*   **Проксирование (Proxying)**: Перенаправление запроса другому серверу.
*   **Агрегация API (API Aggregation)**: Объединение данных из нескольких API.
*   **Трансформация запроса/ответа (Request/Response Transformation)**: Изменение заголовков или тела запроса/ответа.
*   **Обнаружение сервисов (Service Discovery)**: Динамическое нахождение сетевых адресов микросервисов.
*   **SSL/TLS Termination**: Расшифровка HTTPS-трафика на шлюзе.
*   **Middleware**: Программные компоненты для обработки запроса/ответа.
*   (Ссылка на Единый глоссарий терминов и определений для российского аналога Steam.txt)

## 2. Внутренняя Архитектура (Internal Architecture)

### 2.1. Общее Описание
*   API Gateway реализуется как отдельный, горизонтально масштабируемый сервис, развернутый в Kubernetes. Он действует как обратный прокси и точка применения политик. Его архитектура основана на ядре проксирования и конвейере обработчиков (middleware).
*   Основные компоненты: Внешний Балансировщик Нагрузки, Экземпляр API Gateway (Ядро проксирования, Конвейер обработчиков, Менеджер конфигурации, Клиент обнаружения сервисов), Хранилище конфигурации, Системы мониторинга, логирования и трассировки.
*   Диаграмма компонентов:
    ```mermaid
    graph LR
        subgraph Internet
            Clients[Clients (Web, Mobile, Desktop, API)]
        end

        subgraph Infrastructure
            LB(External Load Balancer / Ingress)
            subgraph K8s Cluster
                GW1(API Gateway Instance 1)
                GW2(API Gateway Instance 2)
                GWN(API Gateway Instance N)

                subgraph GW1 [API Gateway Instance]
                    direction TB
                    RE[Routing Engine]
                    subgraph Middleware Pipeline
                        direction TB
                        LogM1(Logging In) --> MetricsM1(Metrics In) --> TraceM(Tracing) --> CORSM(CORS) --> AuthM(Auth) --> RateM(Rate Limiting) --> ReqTransM(Request Transform) --> ProxyM(Proxy) --> RespTransM(Response Transform) --> ErrM(Error Handling) --> MetricsM2(Metrics Out) --> LogM2(Logging Out)
                    end
                    RE --> Middleware
                    ProxyM --> SDC(Service Discovery Client)
                    CM(Configuration Manager) --> RE
                    CM --> Middleware
                end

                ServiceA1(Service A Instance 1)
                ServiceB1(Service B Instance 1)

                K8sAPI(Kubernetes API / Service Discovery)
                ConfigStore[(Configuration Storage: Git/ConfigMaps/CRDs)]
            end
        end

        Clients --> LB
        LB --> GW1; LB --> GW2; LB --> GWN
        GW1 -- Proxy Request --> ServiceA1
        GW1 -- Proxy Request --> ServiceB1
        SDC --> K8sAPI
        CM --> ConfigStore
    ```

### 2.2. Слои Сервиса
API Gateway, особенно при использовании готовых решений как Kong или Tyk, не всегда строго следует классической слоистой архитектуре (Domain, Application, Infrastructure), так как его основная задача - проксирование и применение политик через конфигурируемый конвейер. Однако, его компоненты можно соотнести следующим образом:

#### 2.2.1. Presentation Layer (Слой Представления)
*   Ответственность: Прием входящих HTTP/HTTPS/WebSocket запросов от клиентов, терминирование SSL/TLS.
*   Ключевые компоненты/модули:
    *   Listeners (Слушатели): Настроенные на определенных портах для приема трафика (например, Kong listeners).
    *   Ingress Controller (если используется как часть шлюза, например, Nginx Ingress Controller).

#### 2.2.2. Application Layer (Прикладной Слой / Слой Сценариев Использования)
*   Ответственность: Оркестрация обработки запроса, включая маршрутизацию, применение политик (аутентификация, авторизация, rate limiting, CORS, трансформация).
*   Ключевые компоненты/модули:
    *   **Ядро Проксирования и Маршрутизации (Proxy & Routing Engine)**: Сопоставляет запросы с настроенными маршрутами и направляет их к внутренним сервисам.
    *   **Конвейер Обработчиков (Middleware Pipeline / Plugins)**: Цепочка последовательно применяемых обработчиков (в Kong это плагины, в Tyk - middleware). Примеры:
        *   Аутентификация (JWT, API Key)
        *   Авторизация (базовая проверка ролей)
        *   Rate Limiting
        *   CORS
        *   Трансформация запросов/ответов
        *   Логирование, метрики, трассировка.
    *   **Менеджер Конфигурации (Configuration Manager)**: Загружает и применяет конфигурацию маршрутов и политик.

#### 2.2.3. Domain Layer (Доменный Слой)
*   Ответственность: Для API Gateway доменными сущностями являются его конфигурационные объекты.
*   Ключевые компоненты/модули:
    *   Конфигурационные сущности: Routes, Services, Consumers, Plugins (для Kong); API Definitions, Policies (для Tyk); HTTPRoute, Gateway (для Kubernetes Gateway API).

#### 2.2.4. Infrastructure Layer (Инфраструктурный Слой)
*   Ответственность: Взаимодействие с нижележащей инфраструктурой и внешними системами.
*   Ключевые компоненты/модули:
    *   **Клиент Обнаружения Сервисов (Service Discovery Client)**: Интеграция с Kubernetes API для обнаружения экземпляров внутренних сервисов.
    *   Интеграция с системами хранения конфигурации (ConfigMaps, CRDs, Git).
    *   Клиенты для систем мониторинга (Prometheus), логирования (ELK/Loki), трассировки (Jaeger).
    *   Сетевой стек для проксирования запросов.
    *   (Опционально) Взаимодействие с Redis/PostgreSQL для хранения состояния плагинов (например, rate limiting counters).

## 3. API Endpoints

### 3.1. REST API
*   API Gateway в основном проксирует и управляет API других микросервисов. Его собственная API поверхность для конечных пользователей — это совокупность API всех этих сервисов.
*   **Структура внешнего API (примеры маршрутизации):**
    *   `/api/v1/auth/*` → Auth Service
    *   `/api/v1/users/*` → Account Service
    *   `/api/v1/games/*` → Catalog Service
    *   `/api/v1/library/*` → Library Service
    *   `/api/v1/payments/*` → Payment Service
    *   `/api/v1/social/*` → Social Service
    *   `/api/v1/downloads/*` → Download Service
    *   `/api/v1/notifications/*` → Notification Service
    *   `/api/v1/analytics/*` → Analytics Service
    *   `/api/v1/developers/*` → Developer Service
    *   `/api/v1/admin/*` → Admin Service
*   **Версионирование API:** Через префикс пути (например, `/api/v1/`).
*   **Аутентификация:** Централизована на API Gateway, обычно через JWT (валидация и передача контекста пользователя внутренним сервисам через заголовки `X-User-Id`, `X-User-Roles`). Поддержка API-ключей.

#### 3.1.1. Специальные эндпоинты API Gateway
*   **`GET /api/health`**
    *   Описание: Проверка работоспособности шлюза.
    *   Аутентификация: Не требуется.
    *   Пример ответа (Успех 200 OK): `{"status": "healthy"}`
*   **`GET /api/status`**
    *   Описание: Расширенная информация о статусе системы (может включать статус подключенных сервисов).
    *   Аутентификация: Требуются административные права.
    *   Пример ответа: TODO: Define response
*   **`GET /api/docs`**
    *   Описание: Документация API (агрегированная, например, через Swagger/OpenAPI).
    *   Аутентификация: Может не требоваться или требовать базовых прав.
    *   Пример ответа: HTML страница Swagger UI или OpenAPI JSON.

### 3.2. gRPC API
*   API Gateway может проксировать gRPC запросы. Конкретные сервисы и методы определяются внутренними микросервисами.
*   Готовые решения, такие как Kong, поддерживают проксирование gRPC и gRPC-Web.
*   Аутентификация: Метаданные gRPC могут использоваться для передачи токенов.
*   TODO: Детализировать конфигурацию gRPC проксирования, если необходимо.

### 3.3. WebSocket API (если применимо)
*   API Gateway может проксировать WebSocket соединения.
*   Пример маршрута: `/api/v1/notifications/ws` → Notification Service (WebSocket endpoint).
*   Аутентификация: JWT токен может передаваться при установлении WebSocket соединения.

## 4. Модели Данных (Data Models)

Основной моделью данных для API Gateway является его конфигурация.

### 4.1. Конфигурационные Сущности (на примере Kubernetes Gateway API CRDs)
*   **GatewayClass**: Определяет тип шлюза (например, Kong, Istio).
*   **Gateway**: Экземпляр шлюза, слушатели (порты, протоколы), настройки TLS.
*   **HTTPRoute**: Правила маршрутизации для HTTP-трафика.
    *   **Hostnames**: Доменные имена.
    *   **Rules**:
        *   **Matches**: Критерии сопоставления (путь, метод, заголовки, query-параметры).
        *   **Filters**: Middleware (модификация заголовков, перезапись URL, политики).
        *   **BackendRefs**: Ссылки на внутренние сервисы Kubernetes.
*   **ReferencePolicy**: Политики (аутентификация, rate limiting, CORS).

### 4.2. Пример HTTPRoute
```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: account-service-api
spec:
  parentRefs:
  - name: main-api-gateway
  hostnames: ["api.gamestore.ru"]
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /api/v1/users
    filters:
    - type: RequestHeaderModifier # Пример модификации заголовка
      requestHeaderModifier:
        add:
        - name: x-user-id
          value: "{jwt.claims.sub}" # Значение извлекается плагином JWT
    - type: ExtensionRef # Пример ссылки на политику (зависит от реализации)
      extensionRef:
        group: security.konghq.com # Пример для Kong
        kind: KongPlugin
        name: jwt-validation
    backendRefs:
    - name: account-service # Имя Kubernetes Service
      port: 80
```

## 5. Потоковая Обработка Событий (Event Streaming)
*   API Gateway обычно не является активным участником потоковой обработки событий (не производит и не потребляет события Kafka напрямую в рамках своей основной логики). Его роль - проксирование запросов, которые могут инициировать или быть частью потоков событий во внутренних сервисах.
*   Исключение: Плагины логирования могут отправлять логи в системы сбора событий.
*   Статус: Информация не найдена в существующей документации относительно производства/потребления бизнес-событий.

## 6. Интеграции (Integrations)

### 6.1. Внутренние Микросервисы
API Gateway интегрируется со всеми внутренними микросервисами платформы для маршрутизации запросов к ним.
*   **Auth Service**:
    *   Тип: Синхронная (HTTP/REST или gRPC) для валидации токенов. API Gateway проксирует запросы к Auth Service.
    *   Назначение: Аутентификация, получение публичных ключей для JWT.
*   **Account Service, Catalog Service, Library Service, Payment Service, Social Service, Download Service, Notification Service, Analytics Service, Developer Service, Admin Service**:
    *   Тип: Синхронная (HTTP/REST, gRPC, WebSocket) - API Gateway проксирует запросы к этим сервисам.
    *   Назначение: Предоставление бизнес-логики платформы.
    *   Контракт: Определяется API этих сервисов.

### 6.2. Внешние Системы
*   **Kubernetes API**:
    *   Тип интеграции: Прямое взаимодействие.
    *   Назначение: Обнаружение сервисов (Service Discovery).
*   **Система Мониторинга (Prometheus)**:
    *   Тип интеграции: Экспорт метрик.
    *   Назначение: Сбор и визуализация метрик работы шлюза.
*   **Система Логирования (ELK Stack / Loki)**:
    *   Тип интеграции: Экспорт логов.
    *   Назначение: Сбор, агрегация и анализ логов шлюза.
*   **Система Трассировки (Jaeger / Tempo)**:
    *   Тип интеграции: Экспорт данных трассировки (OpenTelemetry).
    *   Назначение: Распределенная трассировка запросов.
*   **Хранилище Конфигурации (Git / Kubernetes CRDs)**:
    *   Тип интеграции: Чтение конфигурации.
    *   Назначение: Получение правил маршрутизации и политик.

## 7. Конфигурация (Configuration)

### 7.1. Переменные Окружения
*   TODO: Определить основные переменные окружения (зависят от выбранного ПО для API Gateway, например, Kong, Tyk). Примеры:
    *   `KONG_DATABASE_URL` / `TYK_STORAGE_CONNECTION_STRING`
    *   `KONG_ADMIN_LISTEN` / `TYK_API_LISTEN_PORT`
    *   `KONG_PROXY_LISTEN`
    *   `LOG_LEVEL`

### 7.2. Файлы Конфигурации
*   Конфигурация маршрутов, сервисов, плагинов и политик обычно определяется декларативно:
    *   Через Kubernetes Custom Resource Definitions (CRDs) (например, для Kong Ingress Controller, Tyk Operator, Kubernetes Gateway API).
    *   Через файлы YAML/JSON, загружаемые в шлюз.
*   Пример структуры (HTTPRoute) см. в разделе "4.2. Пример HTTPRoute".
*   Расположение: Зависит от метода развертывания (например, в Git-репозитории при GitOps подходе).

## 8. Обработка Ошибок (Error Handling)

### 8.1. Общие Принципы
*   Предоставление стандартизированных и информативных сообщений об ошибках клиентам, скрывая детали внутренних сбоев.
*   Генерация соответствующих HTTP-статусов ошибок (4xx, 5xx).
*   Включение `requestId` (trace_id) в ответы об ошибках для корреляции с логами.

### 8.2. Распространенные Коды Ошибок
*   **400 Bad Request** (`INVALID_INPUT`): Некорректные входные данные в запросе клиента.
    ```json
    { "error": { "code": "INVALID_INPUT", "message": "Детали ошибки валидации.", "requestId": "<trace_id>" } }
    ```
*   **401 Unauthorized** (`UNAUTHENTICATED` / `INVALID_TOKEN`): Ошибка аутентификации (невалидный, просроченный токен).
    ```json
    { "error": { "code": "INVALID_TOKEN", "message": "Authentication token is invalid or expired.", "requestId": "<trace_id>" } }
    ```
*   **403 Forbidden** (`PERMISSION_DENIED`): Недостаточно прав для выполнения операции (после успешной аутентификации).
    ```json
    { "error": { "code": "PERMISSION_DENIED", "message": "Access denied.", "requestId": "<trace_id>" } }
    ```
*   **404 Not Found** (`RESOURCE_NOT_FOUND`): Запрашиваемый ресурс (маршрут) не найден.
    ```json
    { "error": { "code": "RESOURCE_NOT_FOUND", "message": "The requested path was not found.", "requestId": "<trace_id>" } }
    ```
*   **429 Too Many Requests** (`RATE_LIMIT_EXCEEDED`): Превышен лимит запросов.
    ```json
    { "error": { "code": "RATE_LIMIT_EXCEEDED", "message": "Too many requests. Please try again later.", "requestId": "<trace_id>" } }
    ```
*   **500 Internal Server Error** (`INTERNAL_SERVER_ERROR`): Ошибка на стороне самого шлюза.
    ```json
    { "error": { "code": "INTERNAL_SERVER_ERROR", "message": "An unexpected error occurred.", "requestId": "<trace_id>" } }
    ```
*   **502 Bad Gateway** (`BAD_GATEWAY`): Ошибка ответа от внутреннего (upstream) сервиса.
    ```json
    { "error": { "code": "BAD_GATEWAY", "message": "Upstream service error.", "requestId": "<trace_id>" } }
    ```
*   **503 Service Unavailable** (`SERVICE_UNAVAILABLE`): Внутренний сервис недоступен (например, из-за Circuit Breaker).
    ```json
    { "error": { "code": "SERVICE_UNAVAILABLE", "message": "Upstream service unavailable.", "requestId": "<trace_id>" } }
    ```
*   **504 Gateway Timeout** (`GATEWAY_TIMEOUT`): Таймаут ожидания ответа от внутреннего сервиса.
    ```json
    { "error": { "code": "GATEWAY_TIMEOUT", "message": "Upstream service timeout.", "requestId": "<trace_id>" } }
    ```

## 9. Безопасность (Security)

### 9.1. Аутентификация
*   Централизованная проверка JWT-токенов (выданных Auth Service) для большинства запросов.
*   Поддержка аутентификации по статическим API-ключам для доверенных сервисов.
*   Передача идентификатора пользователя и ролей внутренним сервисам через HTTP-заголовки (`X-User-Id`, `X-User-Roles`).
*   (Ссылка на спецификацию Auth Service для деталей JWT).

### 9.2. Авторизация
*   Опциональная базовая проверка авторизации на уровне шлюза (например, проверка наличия определенной роли для доступа к группе маршрутов).
*   Основная логика авторизации делегируется внутренним микросервисам.
*   (Ссылка на Единый реестр ролей пользователей и матрица доступа.txt).

### 9.3. Защита Данных
*   **SSL/TLS Termination**: Завершение SSL/TLS соединений с использованием актуальных сертификатов и современных протоколов/шифров.
*   **Защита от базовых атак**: Ограничение максимального размера тела запроса, защита от распространенных веб-уязвимостей (OWASP Top 10) через конфигурацию или интеграцию с WAF.
*   **Управление CORS**: Централизованная настройка CORS для веб-приложений.
*   **Заголовки безопасности**: Настройка HSTS, X-Frame-Options, X-Content-Type-Options и т.д.

### 9.4. Управление Секретами
*   Использование Kubernetes Secrets или HashiCorp Vault для хранения чувствительных данных (TLS сертификаты, ключи для подписи/шифрования конфигурации плагинов).
*   Регулярная ротация ключей и сертификатов.

## 10. Развертывание (Deployment)

### 10.1. Инфраструктурные Файлы
*   **Dockerfile**: Зависит от выбранного ПО (Kong, Tyk предоставляют официальные образы). Если кастомный, то `path/to/Dockerfile`.
*   **Helm-чарты/Kubernetes манифесты**: Используются для развертывания и управления шлюзом в Kubernetes (например, официальные Helm-чарты Kong/Tyk или кастомные). `path/to/helm/chart`.
*   Процесс сборки и развертывания: Обычно включает настройку CRDs, конфигурационных файлов/ConfigMaps, развертывание подов шлюза и его зависимостей (например, БД для Kong).

### 10.2. Зависимости при Развертывании
*   Kubernetes кластер.
*   (Опционально, для некоторых шлюзов) База данных (PostgreSQL, Redis) для хранения конфигурации и состояния.
*   Интеграция с Auth Service.
*   Доступ к системе обнаружения сервисов (Kubernetes API).

### 10.3. CI/CD
*   Конфигурация API Gateway (маршруты, политики) управляется через Git (GitOps).
*   CI/CD пайплайн отвечает за валидацию конфигурации и ее применение в кластере Kubernetes.
*   (Ссылка на стандарт CI/CD платформы)

## 11. Мониторинг и Логирование (Logging and Monitoring)

### 11.1. Логирование
*   **Формат**: Структурированные логи (JSON).
*   **События**: Детальное логирование входящих запросов и исходящих ответов, ошибок, событий жизненного цикла шлюза.
*   **Уровни**: DEBUG, INFO, WARN, ERROR.
*   **Интеграция**: Сбор логов через Fluentd/Promtail в ELK Stack/Loki.
*   (Ссылка на стандарт логирования платформы)

### 11.2. Мониторинг
*   **Метрики**: Количество запросов (всего, по маршрутам, по статусам ответа), задержка обработки на шлюзе, задержка ответа от бэкенда, количество активных соединений, использование ресурсов (CPU, память).
*   **Эндпоинт**: `/metrics` (для Prometheus, если шлюз экспортирует в этом формате, или через адаптеры).
*   **Интеграция**: Prometheus + Grafana.
*   **Дашборды и алерты**: Настроены для отслеживания ключевых показателей и аномалий.
*   (Ссылка на стандарт мониторинга платформы)

### 11.3. Трассировка
*   **Интеграция**: Поддержка стандартов распределенной трассировки (OpenTelemetry, Jaeger, Tempo).
*   **Контекст**: Генерация/прием и передача заголовков трассировки (например, `traceparent`) внутренним сервисам.
*   (Ссылка на стандарт трассировки платформы)

## 12. Нефункциональные Требования (NFRs)

*   **Производительность**:
    *   Дополнительная задержка шлюза (Gateway Latency): P95 < 10 мс, P99 < 20 мс.
    *   Пропускная способность: Не менее 10 000 RPS на экземпляр.
*   **Надежность**:
    *   Доступность: 99.99%.
    *   Процент ошибок шлюза: < 0.01%.
*   **Масштабируемость**: Горизонтальное масштабирование для обработки пиковых нагрузок.
*   **Безопасность**: Соответствие требованиям (см. раздел 9), время реакции на инциденты < 15 мин.
*   **Сопровождаемость**: Конфигурация как код, автоматизированное развертывание.
*   **Ограничения**:
    *   Не должен реализовывать сложную бизнес-логику.
    *   Агрегация API используется ограниченно.
    *   Является единой точкой отказа, требует высокой отказоустойчивости.

## 13. Приложения (Appendices) (Опционально)
*   Детальные примеры конфигурации для Kong/Tyk.
*   Полные примеры запросов/ответов для специальных эндпоинтов шлюза.

---
*Этот шаблон является отправной точкой и может быть адаптирован под конкретные нужды проекта и сервиса.*

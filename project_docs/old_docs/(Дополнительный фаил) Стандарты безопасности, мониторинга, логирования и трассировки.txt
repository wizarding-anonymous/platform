# Стандарты безопасности, мониторинга, логирования и трассировки

## Содержание
1. [Введение](#введение)
2. [Стандарты безопасности](#стандарты-безопасности)
3. [Стандарты мониторинга](#стандарты-мониторинга)
4. [Стандарты логирования](#стандарты-логирования)
5. [Стандарты трассировки](#стандарты-трассировки)
6. [Интеграция компонентов](#интеграция-компонентов)
7. [Заключение](#заключение)

## Введение

Данный документ определяет единые стандарты безопасности, мониторинга, логирования и трассировки для российского аналога платформы Steam. Цель документа — обеспечить согласованный подход к обеспечению безопасности, наблюдаемости и отказоустойчивости всех микросервисов платформы.

Стандарты разработаны с учетом использования Go в качестве основного языка программирования для бэкенда и PostgreSQL в качестве основной базы данных.

## Стандарты безопасности

### 1. Аутентификация и авторизация

#### 1.1. Аутентификация пользователей

- **Протокол**: OAuth 2.0 с OpenID Connect
- **Токены**: JWT (JSON Web Tokens)
- **Хранение токенов**: 
  - Access token: в памяти клиента (не в localStorage/cookies)
  - Refresh token: в HttpOnly, Secure, SameSite=Strict cookie
- **Срок действия токенов**:
  - Access token: 15 минут
  - Refresh token: 7 дней
- **Ротация refresh токенов**: при каждом использовании
- **Библиотека для Go**: `github.com/golang-jwt/jwt/v5`

#### 1.2. Авторизация

- **Модель**: RBAC (Role-Based Access Control)
- **Проверка прав**: на уровне API Gateway и внутри каждого микросервиса
- **Формат передачи информации о ролях**: 
  - В JWT-токене: поле `roles` с массивом строк
  - В заголовках между сервисами: `X-User-Roles`
- **Библиотека для Go**: `github.com/casbin/casbin/v2`

#### 1.3. Межсервисная аутентификация

- **Протокол**: mTLS (mutual TLS)
- **Сертификаты**: выдаются внутренним CA (Certificate Authority)
- **Срок действия сертификатов**: 90 дней с автоматическим обновлением
- **Библиотека для Go**: стандартная библиотека `crypto/tls`

#### 1.4. Защита API

- **Rate limiting**: на уровне API Gateway
  - Глобальный лимит: 1000 запросов в минуту на IP
  - Лимит для аутентифицированных пользователей: 100 запросов в минуту на пользователя
  - Лимит для критичных эндпоинтов (аутентификация, платежи): 10 запросов в минуту
- **Защита от CSRF**: для всех модифицирующих операций (POST, PUT, DELETE)
  - Double Submit Cookie pattern
  - Библиотека для Go: `github.com/gorilla/csrf`
- **Защита от XSS**: 
  - Content-Security-Policy (CSP) заголовки
  - Экранирование всех пользовательских данных при выводе
- **Защита от SQL-инъекций**: 
  - Использование параметризованных запросов
  - ORM: `github.com/go-gorm/gorm`
- **Защита от DDOS**: 
  - WAF (Web Application Firewall) на уровне инфраструктуры
  - Cloudflare или российский аналог

### 2. Шифрование данных

#### 2.1. Данные в движении (Data in Transit)

- **Протокол**: TLS 1.3
- **Минимальный уровень шифрования**: TLS_AES_128_GCM_SHA256
- **Настройка HTTPS**: HSTS, secure cookies, правильные cipher suites

#### 2.2. Данные в покое (Data at Rest)

- **Шифрование базы данных**: на уровне файловой системы (LUKS)
- **Шифрование чувствительных данных в БД**: 
  - Пароли: bcrypt с фактором стоимости 12
  - Платежная информация: AES-256-GCM
  - Библиотека для Go: `golang.org/x/crypto/bcrypt`
- **Шифрование файлов**: AES-256-GCM для хранимых файлов игр

#### 2.3. Управление секретами

- **Хранение секретов**: HashiCorp Vault или российский аналог
- **Доступ к секретам**: через API с аутентификацией по сертификатам
- **Ротация секретов**: автоматическая, каждые 30 дней
- **Библиотека для Go**: `github.com/hashicorp/vault/api`

### 3. Безопасность кода и инфраструктуры

#### 3.1. Статический анализ кода

- **Инструменты для Go**: 
  - `gosec` для анализа безопасности
  - `golangci-lint` для общего анализа кода
- **Интеграция**: в CI/CD pipeline, блокирование сборки при критических уязвимостях

#### 3.2. Сканирование зависимостей

- **Инструменты**: 
  - `nancy` для Go-зависимостей
  - `trivy` для образов Docker
- **Интеграция**: в CI/CD pipeline, блокирование сборки при критических уязвимостях

#### 3.3. Безопасность контейнеров

- **Базовые образы**: минимальные образы (scratch, alpine)
- **Пользователь**: запуск от непривилегированного пользователя
- **Сканирование**: перед деплоем в любое окружение
- **Иммутабельность**: запрет на изменение запущенных контейнеров

#### 3.4. Безопасность Kubernetes

- **RBAC**: строгое разграничение прав
- **Network Policies**: изоляция сетевого трафика между подами
- **Pod Security Policies**: запрет на привилегированные контейнеры
- **Secrets**: шифрование секретов в etcd

### 4. Аудит безопасности

#### 4.1. Логирование событий безопасности

- **События для логирования**:
  - Все попытки аутентификации (успешные и неуспешные)
  - Изменения прав доступа
  - Доступ к чувствительным данным
  - Изменения в конфигурации системы
- **Формат логов**: JSON с обязательными полями (см. раздел Логирование)

#### 4.2. Мониторинг безопасности

- **Инструменты**: 
  - SIEM-система (Security Information and Event Management)
  - IDS/IPS (Intrusion Detection/Prevention System)
- **Метрики**: 
  - Количество неудачных попыток аутентификации
  - Аномальная активность пользователей
  - Подозрительные запросы к API

#### 4.3. Регулярные проверки

- **Penetration testing**: каждые 6 месяцев
- **Vulnerability assessment**: каждые 3 месяца
- **Compliance check**: каждый месяц

## Стандарты мониторинга

### 1. Инструменты мониторинга

#### 1.1. Основной стек

- **Сбор метрик**: Prometheus
- **Визуализация**: Grafana
- **Алертинг**: Alertmanager
- **Хранение долгосрочных метрик**: VictoriaMetrics или ClickHouse

#### 1.2. Интеграция с Go

- **Библиотека**: `github.com/prometheus/client_golang`
- **Экспозиция метрик**: HTTP-эндпоинт `/metrics` на отдельном порту (по умолчанию 9090)
- **Формат метрик**: Prometheus Text Format

#### 1.3. Интеграция с PostgreSQL

- **Экспортер**: `postgres_exporter`
- **Метрики**: стандартный набор метрик PostgreSQL (connections, transactions, locks, etc.)
- **Дополнительные метрики**: кастомные метрики для специфичных запросов

### 2. Типы метрик

#### 2.1. Системные метрики

- **CPU**: использование, нагрузка
- **Память**: использование, swap
- **Диск**: использование, IOPS, latency
- **Сеть**: трафик, ошибки, latency
- **Экспортер**: node_exporter

#### 2.2. Метрики приложения

- **Счетчики (Counters)**:
  - `http_requests_total{method="GET", path="/api/v1/games", status="200"}` - общее количество HTTP-запросов
  - `db_queries_total{operation="select", table="games"}` - общее количество запросов к БД
  - `errors_total{service="catalog", severity="error"}` - общее количество ошибок

- **Гистограммы (Histograms)**:
  - `http_request_duration_seconds{method="GET", path="/api/v1/games"}` - время обработки HTTP-запросов
  - `db_query_duration_seconds{operation="select", table="games"}` - время выполнения запросов к БД

- **Датчики (Gauges)**:
  - `active_sessions{service="auth"}` - количество активных сессий
  - `queue_size{service="notification", queue="email"}` - размер очереди
  - `connection_pool_size{service="catalog", db="postgres"}` - размер пула соединений

#### 2.3. Бизнес-метрики

- **Пользователи**:
  - `active_users_total` - количество активных пользователей
  - `new_users_total` - количество новых регистраций

- **Игры**:
  - `game_purchases_total{game_id="..."}` - количество покупок игр
  - `game_downloads_total{game_id="..."}` - количество загрузок игр

- **Платежи**:
  - `payment_amount_total{currency="RUB", status="success"}` - общая сумма платежей
  - `payment_count_total{payment_method="card", status="success"}` - количество платежей

### 3. Дашборды и алерты

#### 3.1. Стандартные дашборды

- **Системный дашборд**: общее состояние системы (CPU, память, диск, сеть)
- **Дашборд микросервиса**: метрики конкретного микросервиса (запросы, ошибки, latency)
- **Дашборд базы данных**: метрики PostgreSQL (connections, queries, locks, etc.)
- **Бизнес-дашборд**: ключевые бизнес-метрики (пользователи, покупки, загрузки)

#### 3.2. Алерты

- **Критические алерты** (требуют немедленной реакции):
  - Высокая нагрузка на CPU (>90% в течение 5 минут)
  - Нехватка памяти (<10% свободной памяти)
  - Высокий процент ошибок (>5% запросов с ошибками)
  - Недоступность сервиса (>30 секунд)

- **Предупреждающие алерты** (требуют внимания в рабочее время):
  - Повышенная нагрузка на CPU (>70% в течение 15 минут)
  - Увеличение времени отклика (>500ms для 95% запросов)
  - Увеличение количества ошибок (>1% запросов с ошибками)
  - Приближение к лимитам ресурсов (>80% использования диска)

#### 3.3. Каналы оповещения

- **Критические алерты**: SMS, телефонный звонок, мессенджер (Telegram)
- **Предупреждающие алерты**: Email, мессенджер (Telegram)
- **Информационные алерты**: Только в системе мониторинга

## Стандарты логирования

### 1. Инструменты логирования

#### 1.1. Основной стек

- **Сбор логов**: Fluent Bit / Fluentd
- **Хранение и анализ**: Elasticsearch или ClickHouse
- **Визуализация**: Kibana или Grafana

#### 1.2. Интеграция с Go

- **Библиотека**: `github.com/uber-go/zap` или `github.com/sirupsen/logrus`
- **Формат логов**: JSON
- **Уровни логирования**: DEBUG, INFO, WARN, ERROR, FATAL

#### 1.3. Интеграция с PostgreSQL

- **Логирование запросов**: все запросы длительностью >100ms
- **Логирование ошибок**: все ошибки
- **Формат логов**: JSON или CSV

### 2. Структура логов

#### 2.1. Обязательные поля

- **timestamp**: время события в формате RFC3339 (2023-01-01T12:00:00Z)
- **level**: уровень логирования (debug, info, warn, error, fatal)
- **service**: название микросервиса
- **instance**: идентификатор экземпляра (pod name, container id)
- **message**: текстовое сообщение
- **trace_id**: идентификатор трассировки (для связи с системой трассировки)
- **span_id**: идентификатор спана (для связи с системой трассировки)

#### 2.2. Дополнительные поля для HTTP-запросов

- **http.method**: метод запроса (GET, POST, etc.)
- **http.path**: путь запроса
- **http.status_code**: код ответа
- **http.user_agent**: User-Agent клиента
- **http.request_id**: уникальный идентификатор запроса
- **http.remote_ip**: IP-адрес клиента
- **http.duration_ms**: время обработки запроса в миллисекундах

#### 2.3. Дополнительные поля для ошибок

- **error.message**: текст ошибки
- **error.stack**: стек вызовов (только для уровня DEBUG)
- **error.code**: код ошибки (если применимо)
- **error.context**: дополнительный контекст ошибки

#### 2.4. Дополнительные поля для бизнес-событий

- **user.id**: идентификатор пользователя (если применимо)
- **user.roles**: роли пользователя (если применимо)
- **entity.type**: тип сущности (game, user, payment, etc.)
- **entity.id**: идентификатор сущности
- **action**: действие (create, update, delete, etc.)

### 3. Пример структуры лога

```json
{
  "timestamp": "2023-01-01T12:00:00Z",
  "level": "info",
  "service": "catalog-service",
  "instance": "catalog-service-5d8d9f7b68-2jz9l",
  "message": "Успешная обработка запроса на получение игры",
  "trace_id": "0af7651916cd43dd8448eb211c80319c",
  "span_id": "b7ad6b7169203331",
  "http": {
    "method": "GET",
    "path": "/api/v1/games/123",
    "status_code": 200,
    "user_agent": "Mozilla/5.0 ...",
    "request_id": "5f6b7c8d-9e0f-1a2b-3c4d-5e6f7a8b9c0d",
    "remote_ip": "192.168.1.1",
    "duration_ms": 45
  },
  "user": {
    "id": "user-123",
    "roles": ["user"]
  },
  "entity": {
    "type": "game",
    "id": "game-123"
  },
  "action": "get"
}
```

### 4. Политика хранения логов

- **Оперативные логи**: 7 дней в полном объеме
- **Архивные логи**: 90 дней в агрегированном виде
- **Логи безопасности**: 1 год
- **Логи аудита**: 3 года (в соответствии с требованиями регуляторов)

## Стандарты трассировки

### 1. Инструменты трассировки

#### 1.1. Основной стек

- **Сбор и визуализация**: Jaeger или Zipkin
- **Протокол**: OpenTelemetry

#### 1.2. Интеграция с Go

- **Библиотека**: `go.opentelemetry.io/otel`
- **Автоматическая инструментация**: для HTTP-клиентов, серверов, gRPC, SQL

#### 1.3. Интеграция с PostgreSQL

- **Библиотека**: `github.com/uptrace/opentelemetry-go-extra/otelgorm`
- **Трассировка запросов**: все запросы с контекстом трассировки

### 2. Структура трассировки

#### 2.1. Основные компоненты

- **Trace**: полная трассировка запроса через все сервисы
- **Span**: отдельная операция в рамках трассировки
- **SpanContext**: контекст, передаваемый между сервисами

#### 2.2. Обязательные атрибуты спана

- **service.name**: название микросервиса
- **service.version**: версия микросервиса
- **operation.name**: название операции

#### 2.3. Дополнительные атрибуты для HTTP-запросов

- **http.method**: метод запроса
- **http.url**: URL запроса
- **http.status_code**: код ответа
- **http.user_agent**: User-Agent клиента

#### 2.4. Дополнительные атрибуты для DB-запросов

- **db.system**: тип БД (postgresql)
- **db.name**: название БД
- **db.statement**: SQL-запрос (без параметров)
- **db.operation**: тип операции (select, insert, update, delete)

### 3. Пример инструментации кода

```go
import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    tracer := otel.Tracer("catalog-service")
    
    ctx, span := tracer.Start(ctx, "GetGame", 
        trace.WithAttributes(
            attribute.String("http.method", r.Method),
            attribute.String("http.url", r.URL.String()),
        ),
    )
    defer span.End()
    
    // Получение ID игры из запроса
    gameID := r.URL.Query().Get("id")
    span.SetAttributes(attribute.String("game.id", gameID))
    
    // Получение игры из БД
    game, err := getGameFromDB(ctx, gameID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        http.Error(w, "Game not found", http.StatusNotFound)
        return
    }
    
    // Успешный ответ
    span.SetAttributes(attribute.String("game.name", game.Name))
    span.SetStatus(codes.Ok, "")
    
    // Отправка ответа
    json.NewEncoder(w).Encode(game)
}

func getGameFromDB(ctx context.Context, gameID string) (*Game, error) {
    ctx, span := otel.Tracer("catalog-service").Start(ctx, "DB:GetGame")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.name", "catalog"),
        attribute.String("db.operation", "select"),
    )
    
    // Запрос к БД
    var game Game
    result := db.WithContext(ctx).Where("id = ?", gameID).First(&game)
    if result.Error != nil {
        span.RecordError(result.Error)
        span.SetStatus(codes.Error, result.Error.Error())
        return nil, result.Error
    }
    
    span.SetStatus(codes.Ok, "")
    return &game, nil
}
```

### 4. Политика сэмплирования

- **Разработка**: 100% запросов
- **Тестирование**: 50% запросов
- **Продакшен**: 10% запросов по умолчанию, 100% для ошибок
- **Специальные случаи**: 100% для критичных операций (платежи, аутентификация)

## Интеграция компонентов

### 1. Взаимосвязь логирования и трассировки

- **Связующие поля**: trace_id и span_id в каждом логе
- **Корреляция**: возможность перехода от лога к трассировке и обратно
- **Библиотека для Go**: `go.opentelemetry.io/otel/exporters/stdout/stdouttrace`

### 2. Взаимосвязь мониторинга и трассировки

- **Exemplars**: связь метрик с трассировками
- **Библиотека для Go**: `go.opentelemetry.io/otel/exporters/prometheus`

### 3. Взаимосвязь безопасности и логирования

- **Аудит**: логирование всех событий безопасности
- **Алерты**: генерация алертов на основе логов безопасности
- **SIEM**: интеграция логов с системой управления информационной безопасностью

### 4. Централизованное управление

- **Конфигурация**: централизованное управление конфигурацией через ConfigMap в Kubernetes
- **Обновление**: возможность обновления конфигурации без перезапуска сервисов
- **Мониторинг компонентов**: отдельные дашборды для мониторинга систем логирования, трассировки и безопасности

## Заключение

Данные стандарты безопасности, мониторинга, логирования и трассировки обеспечивают единый подход к обеспечению безопасности и наблюдаемости всех микросервисов российского аналога платформы Steam. Следование этим стандартам позволит создать надежную, безопасную и наблюдаемую систему, готовую к эксплуатации в продакшен-среде.

Важно регулярно пересматривать и обновлять эти стандарты в соответствии с изменениями в технологиях, угрозах безопасности и требованиях бизнеса.

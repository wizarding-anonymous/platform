# Спецификация Frontend Приложения: Клиентское приложение платформы 'Российский Аналог Steam'

---
**Примечание:** Этот документ основан на `standard_frontend_template.md`. Он должен быть детализирован и адаптирован командой frontend-разработки по мере развития приложения. Разделы, требующие дополнительной информации или специфичных для проекта решений, помечены как "[TODO: ...]" или содержат общие формулировки, которые необходимо конкретизировать.
---

**Версия:** 1.0
**Дата последнего обновления:** 2024-07-16
**Ответственная команда:** Frontend Team

## 1. Обзор Приложения (Overview)

### 1.1. Назначение и Роль
*   Основной клиентский интерфейс для взаимодействия пользователей с платформой 'Российский Аналог Steam', предоставляющий доступ ко всем функциям платформы.
*   Целевые платформы: Web, Android (API [Минимальный Android API уровень: УТОЧНИТЬ, например, 21]+), iOS (версия [Минимальная версия iOS: УТОЧНИТЬ, например, 11.0]+), Desktop (Windows x64, Linux x64, macOS x64 и Apple Silicon [Поддержка Apple Silicon: УТОЧНИТЬ тип - нативная или Rosetta 2]). Подробнее см. `../../../../CROSS_PLATFORM_SUPPORT.md`.
*   Ключевые бизнес-задачи: Регистрация и аутентификация, просмотр каталога игр и другого контента, управление личной библиотекой (покупка, загрузка, установка, запуск игр), взаимодействие с социальными функциями (профиль, друзья, чаты, отзывы), управление настройками аккаунта и приложения.

### 1.2. Ключевые Функциональности
*   Регистрация/вход (email/пароль, OAuth через VK/Telegram), просмотр каталога игр (поиск, фильтры), страница деталей игры, управление библиотекой (просмотр купленных игр, загрузка, установка, запуск), управление профилем пользователя (просмотр, базовое редактирование), процесс покупки игры, список желаемого, базовые социальные функции (просмотр профилей, добавление в друзья - Phase 2), уведомления (In-App, Push, Email - Phase 2), поддержка (просмотр FAQ, отправка тикета - Phase 3).

### 1.3. Основные Технологии
*   **Язык:** Dart (версия 3.0+)
*   **Framework:** Flutter (версия 3.10+)
*   **Ключевые библиотеки и пакеты (согласно `../../../../PACKAGE_STANDARDIZATION.md` и `../../../../project_technology_stack.md`):**
    *   **Управление состоянием:** `flutter_bloc` / `bloc` (основное решение).
    *   **Навигация:** `go_router` (основное решение).
    *   **HTTP Клиент:** `dio` (основное решение).
    *   **Локальное хранилище:** `hive` / `hive_flutter` (для структурированных данных), `shared_preferences` (для простых ключ-значение), `flutter_secure_storage` (для чувствительных данных).
    *   **Сериализация JSON:** `json_serializable` (с `build_runner`), `freezed`.
    *   **Равенство и неизменяемость моделей:** `equatable` или `freezed`.
    *   **Внедрение зависимостей (DI):** `get_it` (с `injectable` для генерации кода).
    *   **Тестирование:** `flutter_test`, `bloc_test`, `mockito` (или `mocktail`), `integration_test`.
    *   **Линтинг:** `flutter_lints`, `dart_code_metrics`.
    *   **Локализация:** `intl` с ARB-файлами.
    *   **Утилиты:** `dartz` (для функционального программирования), `cached_network_image` (для изображений из сети).
*   Ссылка на `../../../../CODING_STANDARDS.md` для стандартов кодирования.

## 2. Архитектура Приложения (Application Architecture)

### 2.1. Общее Описание
*   Приложение следует принципам **Чистой Архитектуры (Clean Architecture)**, разделяя код на три основных слоя: Presentation, Domain и Data. Этот подход выбран для обеспечения высокой тестируемости, модульности, слабой связанности компонентов и облегчения поддержки и дальнейшего развития приложения.
*   Диаграмма верхнеуровневой архитектуры (если есть, можно вставить Mermaid диаграмму).
    ```mermaid
    graph TD
        A[Presentation Layer (UI, Widgets, BLoCs/Controllers)] --> B(Domain Layer (Entities, Use Cases, Repository Interfaces));
        B --> C(Data Layer (Repository Implementations, Data Sources));
        C --> D[External (API, Local Storage, Platform Services)];
    ```
*   Основные принципы (например, SOLID, DRY, KISS).

### 2.2. Слои Приложения (Layers)

#### 2.2.1. Presentation Layer (Слой Представления)
*   Ответственность: Отображение UI, обработка пользовательского ввода, взаимодействие с Domain Layer через BLoCs/Controllers/ViewModels.
*   Компоненты:
    *   **Widgets (Виджеты):** Структура (атомарные, компоненты, экраны), кастомные виджеты.
    *   **BLoCs/Cubits/Controllers/ViewModels:** Управление состоянием UI, обработка событий от UI и вызов Use Cases.
    *   **Навигация (Routing):** Как определяются и управляются маршруты.

#### 2.2.2. Domain Layer (Доменный Слой / Бизнес-логика)
*   Ответственность: Бизнес-правила, сущности, сценарии использования (Use Cases). Независим от UI и деталей источников данных.
*   Компоненты:
    *   **Entities (Сущности):** Модели данных бизнес-домена.
    *   **Use Cases (Сценарии использования):** Реализация конкретных бизнес-операций.
    *   **Repository Interfaces (Интерфейсы Репозиториев):** Абстракции для доступа к данным.

#### 2.2.3. Data Layer (Слой Данных)
*   Ответственность: Реализация интерфейсов репозиториев, взаимодействие с источниками данных (API, локальное хранилище).
*   Компоненты:
    *   **Repository Implementations (Реализации Репозиториев):** Конкретные классы, реализующие интерфейсы из Domain Layer.
    *   **Data Sources (Источники данных):**
        *   Remote Data Sources (API клиенты, работа с HTTP/gRPC).
        *   Local Data Sources (Работа с базами данных SQLite/Hive, SharedPreferences, Secure Storage).
    *   **Models (Модели данных):** DTO для API, модели для локального хранения.

### 2.3. Структура Директорий Проекта
*   Описание принятой структуры папок и файлов в проекте.
    ```
    /lib
        /src
            /app                # Инициализация приложения, DI, темы, роутинг
            /core               # Базовые утилиты, константы, расширения
            /features           # Функциональные модули (например, auth, catalog, profile)
                /[feature_name]
                    /data           # Data sources, repositories impl, models
                    /domain         # Entities, use cases, repository interfaces
                    /presentation   # BLoCs/Cubits, screens/pages, widgets
            /generated          # Сгенерированный код (локализация, моки)
        main.dart
    /test
        /features
            /[feature_name]
                /data
                /domain
                /presentation
        /mocks
    ...
    ```

## 3. Управление Состоянием (State Management)

*   Основным решением для управления состоянием в приложении является библиотека **`flutter_bloc` / `bloc`**. Этот выбор обусловлен ее предсказуемостью, хорошей тестируемостью, масштабируемостью и поддержкой разделения бизнес-логики от UI. BLoC (Business Logic Component) позволяет обрабатывать события от UI, выполнять бизнес-логику и выдавать новые состояния, на которые реагирует UI.
*   Для простых случаев управления локальным состоянием виджетов могут использоваться стандартные механизмы Flutter (`StatefulWidget`, `ValueNotifier`).
*   Основные паттерны использования (например, разделение на локальное состояние виджетов и глобальное состояние приложения).
*   Примеры реализации для типичных сценариев.

## 4. Навигация (Routing)

*   Для навигации в приложении используется пакет **`go_router`**. Он выбран за его декларативный подход к определению маршрутов, поддержку deep linking, удобную передачу параметров и интеграцию с навигационной системой Flutter 2.0.
*   Маршруты определяются централизованно. Для защиты маршрутов (например, требующих аутентификации) используются route guards, предоставляемые `go_router`.
*   Определение маршрутов, передача параметров.
*   Защита маршрутов (Route guards), аутентификация.
*   Deep linking.

## 5. Взаимодействие с API (API Integrations)

### 5.1. HTTP Клиент
*   Выбранный HTTP клиент: **`dio`**.
*   Настройка клиента: Базовый URL API Gateway ([API_GATEWAY_BASE_URL_PLACEHOLDER] - см. раздел 8.1). Таймауты: connectTimeout [CONNECT_TIMEOUT_MS]ms, receiveTimeout [RECEIVE_TIMEOUT_MS]ms. Interceptors используются для:
            *   Автоматического добавления JWT Access Token в заголовки `Authorization: Bearer <token>`.
            *   Обработки обновления Access Token при получении ошибки 401 (с использованием Refresh Token).
            *   Логирования запросов и ответов (в dev-режиме).
            *   Стандартизированной обработки ошибок API.
*   Формат запросов и ответов (JSON).
*   Модели данных для запросов/ответов (Data Transfer Objects - DTOs), использование `json_serializable` или `freezed`.

### 5.2. Обработка Ошибок API
*   Стандартные ошибки, возвращаемые API Gateway и микросервисами.
*   Ошибки от API Gateway (согласно `../../../../project_api_standards.md`) парсятся, и пользователю отображаются локализованные сообщения. Для UI используются состояния BLoC, отражающие ошибки загрузки данных или выполнения операций. Реализованы retry-механизмы для временных сетевых ошибок (например, при отсутствии интернет-соединения).
*   Обработка сетевых ошибок, таймаутов.

### 5.3. WebSocket (если используется)
*   Назначение: Используется для real-time уведомлений (например, новые сообщения в чате, разблокировка достижений, системные оповещения от Notification Service), обновления онлайн-статусов пользователей (Social Service).
*   Выбранная библиотека: `web_socket_channel` (или более высокоуровневая обертка над ним).
*   Формат сообщений: JSON, согласно `../../../../project_api_standards.md` (раздел 4).
*   Обработка: Управление состоянием WebSocket соединения (подключение, переподключение при обрывах), парсинг входящих сообщений и передача их в соответствующие BLoCs для обновления UI.

## 6. Управление Ресурсами (Asset Management)

*   Изображения (форматы, оптимизация, использование `flutter_svg` для векторной графики).
*   Шрифты (подключение кастомных шрифтов).
*   Другие ресурсы (например, JSON-файлы с конфигурацией).
*   Структура папки `assets`.

## 7. Локализация (Localization - l10n)

*   Подход к локализации (например, использование пакета `intl` и ARB-файлов).
*   Процесс добавления новых языков и строк.
*   Автоматическая генерация кода для локализации.
*   Поддерживаемые языки: Русский (основной), Английский.

## 8. Сборка Приложения (Build Process)

### 8.1. Окружения (Environments)
*   Описание различных окружений (например, dev, staging, prod):
            *   `dev`: Разработка. API URL: `https://api.dev.mygameplatform.ru` [ЗАГЛУШКА_URL_DEV]
            *   `staging`: Тестирование. API URL: `https://api.stage.mygameplatform.ru` [ЗАГЛУШКА_URL_STAGING]
            *   `prod`: Продакшен. API URL: `https://api.mygameplatform.ru` [ЗАГЛУШКА_URL_PROD]
*   Управление конфигурациями для разных окружений осуществляется через Flutter flavors и файлы `.env` (или аналогичные файлы конфигурации, специфичные для каждого flavor), которые не коммитятся в репозиторий и содержат URL API, ключи аналитики и другие специфичные для окружения параметры.

### 8.2. Сборка для Различных Платформ
*   **Web:** `flutter build web --release --dart-define=ENV=prod` (пример). Особенности сборки (renderers: canvaskit, html).
*   **Android:** `flutter build apk --release --flavor prod`, `flutter build appbundle --release --flavor prod`. Подпись приложения.
*   **iOS:** `flutter build ios --release --flavor prod`. Подпись и настройка в Xcode.
*   **Desktop (Windows, Linux, macOS):** `flutter build <platform> --release --flavor prod`. Особенности сборки для каждой платформы.

## 9. Тестирование (Testing)

### 9.1. Типы Тестов
*   **Unit Tests (Модульные тесты):** Тестирование отдельных функций, методов, классов (BLoCs, Use Cases, утилиты).
*   **Widget Tests (Виджет-тесты):** Тестирование отдельных виджетов, проверка их отображения и взаимодействия.
*   **Integration Tests (Интеграционные тесты):** Тестирование взаимодействия нескольких компонентов или всего приложения. Для Flutter это часто тесты, запускаемые на устройстве/эмуляторе.
*   (Опционально) **Golden Tests (Скриншот-тесты):** Проверка UI на соответствие эталонным изображениям.

### 9.2. Инструменты и Библиотеки
*   `flutter_test` (встроенный).
*   `mockito` или `mocktail` для создания моков.
*   `bloc_test` для тестирования BLoCs/Cubits.
*   `integration_test` (встроенный).

### 9.3. Покрытие Тестами (Test Coverage)
*   Целевое покрытие кода тестами (например, >80% для Domain и Data layers).
*   Команда для генерации отчета о покрытии: `flutter test --coverage`.

### 9.4. Запуск Тестов
*   Локально: `flutter test`.
*   CI: Автоматический запуск всех тестов на CI/CD.

## 10. Стандарты Кода и Линтинг (Linting and Formatting)

*   Использование `flutter_lints` или кастомного набора правил в `analysis_options.yaml`.
*   Автоматическое форматирование кода (`dart format`).
*   Соблюдение принципов чистого кода, DRY, SOLID.
*   Соглашения по именованию файлов, классов, переменных.

## 11. Зависимости и Управление Пакетами (Dependencies)

*   Файл `pubspec.yaml`.
*   Политика обновления зависимостей (например, регулярный просмотр `flutter pub outdated`).
*   Использование стабильных версий пакетов.

## 12. Безопасность (Security Best Practices)

*   Хранение чувствительных данных (токены, ключи API) с использованием `flutter_secure_storage`.
*   Защита от распространенных уязвимостей (XSS для Web, небезопасная передача данных).
*   Проверка SSL-сертификатов.
*   Обфускация кода (`flutter build --obfuscate --split-debug-info=./debug_info_prod`) используется для release-сборок для усложнения реверс-инжиниринга.
*   Регулярный аудит зависимостей на уязвимости.
*   Ссылка на `../../../../project_security_standards.md`.

## 13. Производительность (Performance Considerations)

*   Профилирование приложения (Flutter DevTools).
*   Оптимизация отрисовки виджетов (использование `const` конструкторов, `ListView.builder`, избегание ненужных перестроений).
*   Работа с изображениями (кэширование, правильные размеры).
*   Минимизация использования ресурсов устройства (батарея, CPU, память).
*   Асинхронные операции и изоляты для тяжелых вычислений.

## 14. Логирование и Отчеты об Ошибках (Logging and Error Reporting)

*   Используемые инструменты: пакет `logging` для локального логирования, интеграция с российским сервисом APM (например, **AppMetrica**) или self-hosted **Sentry** для сбора и анализа ошибок и крэшей в release-сборках. Пакет `flutter_fimber` может использоваться для более гибкого логирования.
*   Уровни логирования.
*   Сбор и отправка отчетов об ошибках в централизованную систему.

## 15. Приложения (Appendices) (Опционально)

*   Примеры кода для ключевых паттернов.
*   Ссылки на полезные ресурсы, статьи.
*   Другая вспомогательная информация.

---
*Этот шаблон является отправной точкой и должен быть адаптирован и детализирован командой frontend-разработки.*

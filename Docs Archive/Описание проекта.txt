Платформа: Российский аналог Steam

# Детальное описание границ ответственности микросервисов

## 1. Account Service (Сервис управления пользователями)

### Назначение
Управление пользовательскими аккаунтами, профилями и связанными с ними данными.

### Области ответственности
- Регистрация новых пользователей
- Хранение и управление базовой информацией о пользователях
- Управление профилями пользователей
- Верификация пользователей (email, телефон)
- Управление настройками пользователей
- Обработка CRUD-операций с аккаунтами

### Хранимые данные
- Основная информация о пользователях (ID, email, телефон, имя)
- Профили пользователей (личные данные, настройки, аватары)
- История изменений профилей
- Настройки пользователей
- Статусы верификации

### API
- `/users` - CRUD для пользователей
- `/users/{id}/profile` - управление профилем
- `/users/{id}/verification` - управление верификацией
- `/users/{id}/settings` - настройки пользователя

### Взаимодействия
- **Предоставляет данные для:** Auth Service, Social Service, Library Service, Payment Service
- **Потребляет данные от:** Нет (корневой сервис)

### Технические особенности
- Использует собственную базу данных PostgreSQL
- Шардирование по user_id для масштабируемости
- Кэширование часто запрашиваемых данных в Redis
- Репликация данных для отказоустойчивости

## 2. Auth Service (Сервис аутентификации)

### Назначение
Управление аутентификацией, авторизацией и сессиями пользователей.

### Области ответственности
- Аутентификация пользователей (логин/пароль, 2FA, соц. сети)
- Выдача и валидация JWT-токенов
- Управление сессиями пользователей
- Реализация двухфакторной аутентификации
- Управление паролями (сброс, обновление)
- Интеграция с внешними провайдерами аутентификации (ВКонтакте, Госуслуги)
- Аудит действий входа/выхода

### Хранимые данные
- Хеши паролей и соли
- Сессии пользователей
- Токены доступа и их статусы
- Настройки 2FA
- Привязки к внешним аккаунтам
- Журналы попыток входа

### API
- `/auth/login` - аутентификация пользователей
- `/auth/refresh` - обновление токенов
- `/auth/2fa` - управление 2FA
- `/auth/sessions` - управление сессиями
- `/auth/password` - управление паролями
- `/auth/providers` - интеграции с внешними провайдерами

### Взаимодействия
- **Предоставляет данные для:** Все сервисы (через токены)
- **Потребляет данные от:** Account Service

### Технические особенности
- Использует Redis для хранения сессий и временных токенов
- Асимметричное шифрование для JWT (RS256)
- Интеграция с SMS-шлюзами для 2FA
- Механизмы защиты от брутфорс-атак
- Высокая доступность через кластеризацию

## 3. Catalog Service (Сервис каталога игр)

### Назначение
Управление каталогом игр, метаданными, ценами и медиа-контентом игр.

### Области ответственности
- Хранение информации об играх (метаданные, версии, цены)
- Категоризация и тегирование игр
- Управление ценообразованием и скидками
- Организация поиска и фильтрации игр
- Управление медиа-контентом игр (скриншоты, трейлеры)
- Модерация контента игр

### Хранимые данные
- Метаданные игр (названия, описания, даты выхода)
- Цены и скидки
- Жанры, теги, категории
- Ссылки на медиа-файлы
- Системные требования
- Возрастные рейтинги

### API
- `/games` - CRUD операции с играми
- `/games/search` - поиск и фильтрация
- `/games/categories` - управление категориями
- `/games/prices` - управление ценами и скидками
- `/games/{id}/media` - управление медиа-контентом
- `/games/recommendations` - рекомендации игр

### Взаимодействия
- **Предоставляет данные для:** Library Service, Payment Service, Developer Service, Download Service
- **Потребляет данные от:** Developer Service

### Технические особенности
- Использует PostgreSQL с полнотекстовым поиском
- Интеграция с Elasticsearch для расширенного поиска
- Кэширование популярных запросов
- CDN для доставки медиа-контента
- Шардирование по game_id

## 4. Library Service (Сервис библиотеки пользователя)

### Назначение
Управление личными библиотеками пользователей, отслеживание игрового времени, прогресса и достижений.

### Области ответственности
- Управление библиотекой игр пользователя
- Отслеживание игрового времени
- Управление прогрессом в играх
- Обработка достижений пользователей
- Обработка списков желаемого
- Синхронизация сохранений

### Хранимые данные
- Связи пользователь-игра (владение)
- Статистика игрового времени
- Достижения пользователей
- Списки желаемого
- Метаданные сохранений
- Настройки игр пользователя

### API
- `/library` - управление библиотекой пользователя
- `/library/achievements` - управление достижениями
- `/library/playtime` - отслеживание игрового времени
- `/library/wishlist` - управление списком желаемого
- `/library/saves` - синхронизация сохранений

### Взаимодействия
- **Предоставляет данные для:** Download Service, Social Service, Analytics Service
- **Потребляет данные от:** Account Service, Catalog Service, Payment Service

### Технические особенности
- Высокая частота обновления статистики игрового времени
- Оптимизированное хранение сжатых сохранений
- Асинхронная обработка достижений
- Интеграция с SDK для игр

## 5. Payment Service (Платежный сервис)

### Назначение
Обработка платежей, управление транзакциями и финансовыми операциями на платформе.

### Области ответственности
- Обработка платежей через различные платежные системы
- Управление транзакциями и финансовыми операциями
- Формирование и хранение чеков (фискализация)
- Обработка возвратов средств
- Управление балансами разработчиков
- Обработка подарков и промокодов
- Выплаты разработчикам

### Хранимые данные
- Транзакции и их статусы
- Финансовые балансы
- Информация о платежных методах пользователей
- Фискальные данные (чеки)
- История возвратов
- Промокоды и подарочные сертификаты
- Расчеты с разработчиками

### API
- `/payments/transactions` - управление транзакциями
- `/payments/methods` - управление платежными методами
- `/payments/refunds` - обработка возвратов
- `/payments/promocodes` - управление промокодами
- `/payments/balance` - управление балансами
- `/payments/payouts` - выплаты разработчикам

### Взаимодействия
- **Предоставляет данные для:** Library Service, Analytics Service, Developer Service, Admin Service
- **Потребляет данные от:** Account Service, Catalog Service

### Технические особенности
- Соответствие требованиям 54-ФЗ (фискализация)
- Интеграция с российскими платежными системами (СБП, МИР, ЮMoney)
- Транзакционная обработка платежей
- Высокий уровень безопасности и аудита операций
- Отказоустойчивая архитектура с синхронной репликацией данных

## 6. Download Service (Сервис загрузки)

### Назначение
Управление загрузкой, обновлением и установкой игр на устройства пользователей.

### Области ответственности
- Организация загрузки игровых файлов
- Управление очередью загрузок
- Распределение нагрузки между CDN
- Проверка целостности файлов
- Обработка дифференциальных обновлений
- Распределение обновлений клиентского приложения
- Мониторинг скорости загрузки

### Хранимые данные
- Метаданные файлов игр (пути, хеши, версии)
- Статусы и прогресс загрузок
- Статистика загрузок
- Версии установленных игр
- Информация о дельта-обновлениях
- Хеши файлов для проверки целостности

### API
- `/downloads/games` - управление загрузками игр
- `/downloads/updates` - управление обновлениями
- `/downloads/client` - обновления клиентского приложения
- `/downloads/status` - отслеживание статуса загрузок
- `/downloads/verify` - проверка целостности файлов

### Взаимодействия
- **Предоставляет данные для:** Клиентское приложение
- **Потребляет данные от:** Catalog Service, Library Service, Developer Service

### Технические особенности
- Интеграция с распределенной CDN сетью
- Механизмы дельта-патчей для экономии трафика
- Приоритизация загрузок
- Распределенное хранилище файлов
- Алгоритмы оптимизации маршрутизации к CDN

## 7. Social Service (Социальный сервис)

### Назначение
Обеспечение социальных функций платформы: друзья, сообщения, форумы, стриминг.

### Области ответственности
- Управление списками друзей
- Обмен сообщениями между пользователями
- Управление группами и сообществами
- Обработка комментариев и отзывов
- Организация форумов и обсуждений
- Уведомления и активность друзей
- Базовые функции стриминга

### Хранимые данные
- Отношения дружбы между пользователями
- Сообщения и их статусы
- Данные групп и сообществ
- Комментарии и отзывы
- Обсуждения на форумах
- Настройки приватности
- Данные о стримах

### API
- `/social/friends` - управление друзьями
- `/social/messages` - система сообщений
- `/social/communities` - управление сообществами
- `/social/reviews` - управление отзывами
- `/social/forums` - форумы и обсуждения
- `/social/streaming` - функции стриминга
- `/social/notifications` - уведомления

### Взаимодействия
- **Предоставляет данные для:** Analytics Service, Admin Service
- **Потребляет данные от:** Account Service, Library Service, Catalog Service

### Технические особенности
- WebSocket для real-time коммуникаций
- Оптимизированное хранение сообщений
- Фильтрация и модерация контента
- Масштабируемая архитектура для растущего объема социальных данных
- Поддержка RTMP для стриминга

## 8. Developer Service (Сервис разработчика)

### Назначение
Обеспечение функций для разработчиков и издателей по управлению своими играми и аналитикой.

### Области ответственности
- Управление аккаунтами разработчиков/издателей
- Загрузка и управление новыми играми и обновлениями
- Управление метаданными игр
- Предоставление аналитики продаж и использования
- Управление маркетинговыми акциями
- Обработка выплат разработчикам
- Интеграция SDK для игр

### Хранимые данные
- Аккаунты разработчиков и издателей
- Данные о загрузках новых игр и обновлений
- Черновики игр и их статусы
- Настройки маркетинговых акций
- Аналитические данные для разработчиков
- Информация о команде разработчиков

### API
- `/developer/games` - управление играми разработчика
- `/developer/versions` - управление версиями игр
- `/developer/analytics` - аналитика для разработчиков
- `/developer/marketing` - управление маркетингом
- `/developer/team` - управление командой
- `/developer/payouts` - информация о выплатах
- `/developer/sdk` - интеграция SDK

### Взаимодействия
- **Предоставляет данные для:** Catalog Service, Download Service, Analytics Service
- **Потребляет данные от:** Account Service, Payment Service

### Технические особенности
- Безопасная передача больших файлов
- Версионирование загружаемых игр
- API для интеграции с CI/CD системами разработчиков
- Аналитические отчеты в реальном времени
- Система управления доступом команды разработчиков

## 9. Admin Service (Административный сервис)

### Назначение
Обеспечение административных функций платформы для сотрудников.

### Области ответственности
- Модерация контента (игры, отзывы, сообщения)
- Управление пользователями и их правами
- Обработка запросов в поддержку
- Мониторинг безопасности и нарушений
- Управление системными настройками платформы
- Генерация административных отчетов
- Управление маркетинговыми акциями на уровне платформы

### Хранимые данные
- Запросы в поддержку и их статусы
- Записи о модерации контента
- Системные настройки платформы
- Администраторские учетные записи и права доступа
- Журналы административных действий
- Глобальные маркетинговые акции и баннеры

### API
- `/admin/support` - управление запросами в поддержку
- `/admin/moderation` - функции модерации
- `/admin/users` - управление пользователями
- `/admin/settings` - системные настройки
- `/admin/reports` - генерация отчетов
- `/admin/marketing` - управление маркетингом

### Взаимодействия
- **Предоставляет данные для:** Все сервисы (административные функции)
- **Потребляет данные от:** Все сервисы (для мониторинга и управления)

### Технические особенности
- Строгое логирование всех административных действий
- Расширенные права доступа через RBAC
- Инструменты массовой обработки контента
- Защищенная административная зона
- Система оповещений о критических событиях

## 10. Analytics Service (Сервис аналитики)

### Назначение
Сбор, обработка и предоставление аналитических данных о работе платформы.

### Области ответственности
- Сбор данных о пользовательской активности
- Формирование бизнес-метрик и KPI
- Генерация отчетов о продажах
- Анализ пользовательского поведения
- Сегментация аудитории
- Предиктивная аналитика
- Мониторинг производительности системы

### Хранимые данные
- Анонимизированные данные о пользовательской активности
- Агрегированные метрики и KPI
- Данные о продажах и трендах
- Статистика по сегментам пользователей
- Метрики использования платформы
- Данные о производительности системы

### API
- `/analytics/reports` - генерация отчетов
- `/analytics/metrics` - доступ к метрикам
- `/analytics/segments` - управление сегментацией
- `/analytics/performance` - метрики производительности
- `/analytics/predictions` - предиктивная аналитика

### Взаимодействия
- **Предоставляет данные для:** Developer Service, Admin Service
- **Потребляет данные от:** Все сервисы (сбор аналитических данных)

### Технические особенности
- Использование ClickHouse для аналитического хранилища
- Kafka для сбора и обработки событий
- Дашборды на основе Grafana
- Анонимизация и защита персональных данных
- Пакетная и потоковая обработка данных

## 11. Notification Service (Сервис уведомлений)

### Назначение
Централизованная система управления уведомлениями для всех компонентов платформы.

### Области ответственности
- Отправка email-уведомлений
- Отправка push-уведомлений
- Отправка SMS-уведомлений
- Отправка уведомлений внутри приложения
- Управление предпочтениями пользователей по уведомлениям
- Планирование и отправка маркетинговых рассылок
- Отслеживание доставки и открытия уведомлений

### Хранимые данные
- Шаблоны уведомлений
- История отправленных уведомлений
- Настройки пользователей по уведомлениям
- Статусы доставки уведомлений
- Маркетинговые кампании и расписания рассылок
- Метрики открытия и взаимодействия с уведомлениями

### API
- `/notifications/send` - отправка уведомлений
- `/notifications/templates` - управление шаблонами
- `/notifications/preferences` - настройки пользователей
- `/notifications/campaigns` - управление кампаниями
- `/notifications/stats` - статистика по уведомлениям

### Взаимодействия
- **Предоставляет данные для:** Analytics Service
- **Потребляет данные от:** Все сервисы (запросы на отправку уведомлений)

### Технические особенности
- Асинхронная обработка через очереди сообщений
- Интеграция с email-провайдерами
- Интеграция с SMS-шлюзами
- Поддержка Firebase Cloud Messaging для push-уведомлений
- Шаблонизация и персонализация сообщений
- Механизмы отложенной отправки и повторных попыток

# Системные требования российского аналога Steam (MVP)

## 1. Функциональные требования

### 1.1 Пользовательский сегмент (Игроки)
- Регистрация и аутентификация пользователей через email, телефон и российские социальные сети
- Личный кабинет с историей покупок, библиотекой игр и профилем
- Каталог игр с фильтрацией и поиском
- Интеграция с российскими платежными системами (МИР, СБП, ЮMoney)
- Загрузка и установка игр через клиентское приложение
- Автоматические обновления игр и клиента
- Возможность добавления игр в список желаемого
- Система отзывов и оценок игр
- Система достижений в играх
- Базовая социальная функциональность (друзья, сообщения)

### 1.2 Издательский сегмент (Разработчики/Издатели)
- Панель управления для загрузки и публикации игр
- Система аналитики продаж и статистики
- Инструменты для обновления контента
- Система модерации контента перед публикацией
- Управление ценами и скидками
- Личные кабинеты с финансовой отчетностью
- API для интеграции с системами разработчиков

### 1.3 Административный сегмент (Сотрудники)
- Панель администрирования платформы
- Система модерации контента, отзывов и пользователей
- Инструменты технической поддержки
- Система управления платежами и возвратами
- Аналитическая платформа для отслеживания показателей
- Система контроля версий программного обеспечения
- Управление маркетинговыми кампаниями и акциями

## 2. Нефункциональные требования

### 2.1 Производительность
- Поддержка не менее 100,000 одновременных пользователей на старте
- Время отклика веб-интерфейса: не более 2 секунд
- Скорость загрузки игр: не менее 10 МБ/с с российских серверов
- Доступность системы: не менее 99.5%

### 2.2 Безопасность
- Соответствие требованиям 152-ФЗ "О персональных данных"
- Двухфакторная аутентификация для всех типов пользователей
- Шифрование персональных данных и платежной информации
- Защита от DDoS-атак
- Регулярное резервное копирование данных

### 2.3 Масштабируемость
- Горизонтальное масштабирование серверов приложений
- Распределенная файловая система для хранения игр
- Возможность быстрого увеличения мощностей при росте нагрузки

### 2.4 Локализация
- Полностью русскоязычный интерфейс
- Поддержка дополнительных языков стран СНГ
- Соответствие законодательству РФ

### 2.5 Техническая совместимость
- Клиентское приложение для Windows, macOS и Linux
- Веб-интерфейс, оптимизированный для всех популярных браузеров
- Мобильное приложение для iOS и Android (базовый функционал)

### 2.6 Хранение данных
- Локализация серверов и хранилищ на территории РФ
- Резервирование данных в нескольких территориально разнесенных дата-центрах

# Архитектура платформы

## 1. Общая архитектура

### 1.1 Компонентная структура
- **Фронтенд-компоненты**:
  - Веб-портал для пользователей
  - Клиентское приложение для игроков
  - Панель управления для разработчиков
  - Административная панель для сотрудников
  - Мобильное приложение

- **Бэкенд-компоненты**:
  - Серверы API
  - Микросервисы обработки бизнес-логики
  - Сервис аутентификации и авторизации
  - Платежный шлюз
  - Система управления контентом
  - Серверы загрузки/скачивания контента
  - Система аналитики и отчетности

- **Инфраструктурные компоненты**:
  - Система кэширования (Redis)
  - База данных (PostgreSQL)
  - Хранилище контента (S3-совместимое)
  - Очереди сообщений (Kafka/RabbitMQ)
  - CDN для игровых файлов
  - Система мониторинга и логирования

### 1.2 Схема взаимодействия компонентов
- Клиентское приложение взаимодействует с API через REST и WebSocket
- Микросервисная архитектура для масштабируемости критических компонентов
- Асинхронная обработка тяжелых задач через очереди сообщений
- API Gateway для маршрутизации запросов к соответствующим микросервисам
- Единая система аутентификации для всех компонентов платформы

## 2. Детализация ключевых компонентов

### 2.1 Клиентское приложение
- Настольное приложение на основе Electron/Qt
- Модульная архитектура с ядром и плагинами
- Компоненты:
  - Модуль авторизации
  - Менеджер загрузок
  - Библиотека игр
  - Магазин
  - Социальный модуль
  - Модуль обновлений
  - Система достижений

### 2.2 Серверная часть
- Архитектура на основе микросервисов
- Основные сервисы:
  - Сервис пользователей
  - Сервис каталога игр
  - Сервис библиотеки пользователя
  - Платежный сервис
  - Сервис загрузки/распространения контента
  - Сервис социальных взаимодействий
  - Сервис аналитики
  - Сервис тех. поддержки
  - Сервис администрирования

### 2.3 Система хранения данных
- Реляционная БД (PostgreSQL) для структурированных данных
- NoSQL решения (MongoDB) для неструктурированных данных
- Распределенное файловое хранилище для игрового контента
- In-memory кэширование для часто запрашиваемых данных
- Система репликации и шардирования для масштабирования

### 2.4 Интеграционный слой
- REST API для основных взаимодействий
- WebSocket для real-time коммуникаций
- gRPC для межсервисного взаимодействия
- API Gateway для управления и маршрутизации запросов
- Система авторизации на основе JWT-токенов

## 3. Схема развертывания

### 3.1 Инфраструктура
- Размещение в российских дата-центрах
- Kubernetes для оркестрации контейнеров
- Минимум два региональных кластера для отказоустойчивости
- Автоматическое масштабирование на основе нагрузки
- Система мониторинга на базе Prometheus и Grafana

### 3.2 Сетевая архитектура
- Внутренние и внешние балансировщики нагрузки
- Защищенная DMZ для публичных сервисов
- VPN для административного доступа
- Распределенная CDN сеть для доставки контента
- Защита от DDoS на уровне провайдера и приложения

### 3.3 Резервирование и отказоустойчивость
- Активная-активная схема работы в нескольких дата-центрах
- Автоматическое переключение между дата-центрами
- Ежедневное резервное копирование данных
- Репликация данных между регионами
- Изоляция сбоев на уровне микросервисов

# Схема базы данных

## 1. Основные сущности

### 1.1 Пользователи и аккаунты

#### Таблица: Users
- `user_id` (Primary Key, UUID)
- `email` (String, Unique)
- `phone_number` (String, Unique, Optional)
- `password_hash` (String)
- `salt` (String)
- `username` (String, Unique)
- `display_name` (String)
- `registration_date` (DateTime)
- `last_login_date` (DateTime)
- `account_status` (Enum: active, suspended, banned)
- `two_factor_enabled` (Boolean)
- `profile_picture_url` (String, Optional)
- `is_verified` (Boolean)
- `verification_token` (String, Optional)
- `password_reset_token` (String, Optional)
- `password_reset_expiry` (DateTime, Optional)

#### Таблица: UserProfiles
- `profile_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `real_name` (String, Optional)
- `country` (String)
- `city` (String, Optional)
- `birth_date` (Date, Optional)
- `biography` (Text, Optional)
- `public_profile` (Boolean)
- `created_at` (DateTime)
- `updated_at` (DateTime)

#### Таблица: UserRoles
- `role_id` (Primary Key, Integer)
- `user_id` (Foreign Key → Users)
- `role_name` (Enum: user, developer, admin, support, moderator)
- `assigned_at` (DateTime)
- `assigned_by` (Foreign Key → Users, Optional)

### 1.2 Игры и контент

#### Таблица: Games
- `game_id` (Primary Key, UUID)
- `title` (String)
- `developer_id` (Foreign Key → DeveloperCompanies)
- `publisher_id` (Foreign Key → PublisherCompanies)
- `release_date` (DateTime)
- `base_price` (Decimal)
- `discount_price` (Decimal, Optional)
- `discount_start_date` (DateTime, Optional)
- `discount_end_date` (DateTime, Optional)
- `description` (Text)
- `short_description` (String)
- `system_requirements` (JSON)
- `tags` (Array)
- `genres` (Array)
- `age_rating` (String)
- `status` (Enum: draft, pending_review, approved, rejected, published, removed)
- `created_at` (DateTime)
- `updated_at` (DateTime)
- `total_reviews` (Integer)
- `positive_reviews_percent` (Decimal)

#### Таблица: GameVersions
- `version_id` (Primary Key, UUID)
- `game_id` (Foreign Key → Games)
- `version_number` (String)
- `build_id` (String)
- `release_notes` (Text)
- `release_date` (DateTime)
- `size_mb` (Integer)
- `status` (Enum: draft, testing, published)
- `created_by` (Foreign Key → Users)
- `created_at` (DateTime)

#### Таблица: GameAssets
- `asset_id` (Primary Key, UUID)
- `game_id` (Foreign Key → Games)
- `asset_type` (Enum: thumbnail, screenshot, video, logo, banner, icon)
- `url` (String)
- `order` (Integer)
- `created_at` (DateTime)

#### Таблица: GameFiles
- `file_id` (Primary Key, UUID)
- `game_id` (Foreign Key → Games)
- `version_id` (Foreign Key → GameVersions)
- `file_type` (Enum: installer, patch, dlc, soundtrack, artwork)
- `file_path` (String)
- `file_size` (BigInteger)
- `checksum` (String)
- `platform` (Enum: windows, macos, linux)
- `upload_date` (DateTime)
- `is_public` (Boolean)

### 1.3 Транзакции и библиотека

#### Таблица: UserLibrary
- `library_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `game_id` (Foreign Key → Games)
- `purchase_date` (DateTime)
- `last_played` (DateTime, Optional)
- `total_playtime_minutes` (Integer)
- `is_hidden` (Boolean)
- `acquisition_type` (Enum: purchase, gift, promotional)

#### Таблица: Transactions
- `transaction_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `transaction_type` (Enum: purchase, refund, payout, gift)
- `status` (Enum: pending, completed, failed, refunded)
- `amount` (Decimal)
- `currency` (String)
- `payment_method` (String)
- `payment_details` (JSON)
- `transaction_date` (DateTime)
- `reference_id` (String, Optional)
- `description` (String)

#### Таблица: OrderItems
- `order_item_id` (Primary Key, UUID)
- `transaction_id` (Foreign Key → Transactions)
- `game_id` (Foreign Key → Games)
- `price` (Decimal)
- `discount_amount` (Decimal)
- `is_gift` (Boolean)
- `gift_recipient_id` (Foreign Key → Users, Optional)
- `gift_message` (Text, Optional)

#### Таблица: Wishlists
- `wishlist_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `game_id` (Foreign Key → Games)
- `added_date` (DateTime)
- `notified_on_sale` (Boolean)

### 1.4 Социальные функции

#### Таблица: Friendships
- `friendship_id` (Primary Key, UUID)
- `user_id_1` (Foreign Key → Users)
- `user_id_2` (Foreign Key → Users)
- `status` (Enum: pending, accepted, blocked)
- `request_date` (DateTime)
- `accepted_date` (DateTime, Optional)

#### Таблица: Messages
- `message_id` (Primary Key, UUID)
- `sender_id` (Foreign Key → Users)
- `receiver_id` (Foreign Key → Users)
- `content` (Text)
- `sent_date` (DateTime)
- `read_date` (DateTime, Optional)
- `is_read` (Boolean)

#### Таблица: Reviews
- `review_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `game_id` (Foreign Key → Games)
- `rating` (Integer)
- `content` (Text)
- `playtime_at_review` (Integer)
- `created_at` (DateTime)
- `updated_at` (DateTime, Optional)
- `helpful_votes` (Integer)
- `is_recommended` (Boolean)
- `is_moderated` (Boolean)
- `moderation_status` (Enum: pending, approved, rejected)

#### Таблица: Achievements
- `achievement_id` (Primary Key, UUID)
- `game_id` (Foreign Key → Games)
- `title` (String)
- `description` (String)
- `icon_url` (String)
- `is_hidden` (Boolean)
- `points` (Integer, Optional)
- `created_at` (DateTime)

#### Таблица: UserAchievements
- `user_achievement_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `achievement_id` (Foreign Key → Achievements)
- `unlock_date` (DateTime)

### 1.5 Разработчики и издатели

#### Таблица: DeveloperCompanies
- `developer_id` (Primary Key, UUID)
- `company_name` (String)
- `description` (Text)
- `website` (String, Optional)
- `logo_url` (String, Optional)
- `country` (String)
- `verification_status` (Enum: unverified, pending, verified)
- `registration_date` (DateTime)
- `legal_entity_id` (String, Optional)
- `contact_email` (String)
- `contact_phone` (String, Optional)

#### Таблица: PublisherCompanies
- `publisher_id` (Primary Key, UUID)
- `company_name` (String)
- `description` (Text)
- `website` (String, Optional)
- `logo_url` (String, Optional)
- `country` (String)
- `verification_status` (Enum: unverified, pending, verified)
- `registration_date` (DateTime)
- `legal_entity_id` (String, Optional)
- `contact_email` (String)
- `contact_phone` (String, Optional)

#### Таблица: DeveloperMembers
- `member_id` (Primary Key, UUID)
- `developer_id` (Foreign Key → DeveloperCompanies)
- `user_id` (Foreign Key → Users)
- `role` (String)
- `permissions` (JSON)
- `joined_date` (DateTime)

#### Таблица: PublisherMembers
- `member_id` (Primary Key, UUID)
- `publisher_id` (Foreign Key → PublisherCompanies)
- `user_id` (Foreign Key → Users)
- `role` (String)
- `permissions` (JSON)
- `joined_date` (DateTime)

### 1.6 Администрирование и поддержка

#### Таблица: SupportTickets
- `ticket_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `subject` (String)
- `description` (Text)
- `status` (Enum: open, in_progress, resolved, closed)
- `priority` (Enum: low, medium, high, urgent)
- `category` (String)
- `created_at` (DateTime)
- `updated_at` (DateTime)
- `resolved_at` (DateTime, Optional)
- `assignee_id` (Foreign Key → Users, Optional)

#### Таблица: TicketResponses
- `response_id` (Primary Key, UUID)
- `ticket_id` (Foreign Key → SupportTickets)
- `user_id` (Foreign Key → Users)
- `content` (Text)
- `created_at` (DateTime)
- `is_internal_note` (Boolean)

#### Таблица: AuditLogs
- `log_id` (Primary Key, UUID)
- `user_id` (Foreign Key → Users)
- `action` (String)
- `entity_type` (String)
- `entity_id` (String)
- `old_values` (JSON, Optional)
- `new_values` (JSON, Optional)
- `ip_address` (String)
- `timestamp` (DateTime)
- `additional_details` (JSON, Optional)

## 2. Индексы и оптимизация
- Индексы на внешние ключи (user_id, game_id, и т.д.)
- Полнотекстовые индексы для поисковых полей
- Составные индексы для часто используемых запросов
- Партиционирование больших таблиц (например, Transactions, Messages)
- Индексы для диапазонных запросов (например, по датам)

## 3. Ограничения и связи
- Обеспечение целостности данных через внешние ключи
- Уникальные ограничения для критических полей
- Каскадное удаление/обновление где применимо
- Проверки на уровне БД для валидации данных

# Роли пользователей и разграничение прав

## 1. Типы пользователей

### 1.1 Игроки (основные пользователи)

#### Базовый пользователь
- **Права**:
  - Просмотр каталога игр
  - Покупка игр
  - Загрузка и установка приобретенных игр
  - Добавление игр в список желаемого
  - Оставление отзывов на приобретенные игры
  - Базовая настройка профиля
  - Общение с другими пользователями
  - Создание запросов в службу поддержки

#### Премиум-пользователь
- **Дополнительные права**:
  - Ранний доступ к новым функциям
  - Скидки на определенные категории игр
  - Более высокий приоритет при технической поддержке
  - Доступ к бета-тестированию игр (при согласии разработчика)

### 1.2 Разработчики и издатели

#### Разработчик
- **Права**:
  - Создание и управление страницей разработчика
  - Загрузка и обновление игр
  - Управление версиями игр
  - Просмотр статистики и аналитики своих игр
  - Настройка цен и скидок
  - Доступ к отчетам о продажах
  - Мониторинг отзывов пользователей
  - Ответы на отзывы пользователей
  - Загрузка дополнительного контента и DLC

#### Издатель
- **Права**:
  - Все права разработчика
  - Управление несколькими разработчиками
  - Расширенная аналитика продаж
  - Массовое управление ценами и акциями
  - Управление маркетинговыми кампаниями
  - Создание пакетов и бандлов игр

#### Менеджер аккаунта разработчика/издателя
- **Права**:
  - Управление членами команды
  - Назначение и изменение ролей
  - Ограниченный доступ к финансовым данным
  - Просмотр основных аналитических отчетов

#### Финансовый представитель разработчика/издателя
- **Права**:
  - Просмотр финансовых отчетов
  - Настройка банковских данных
  - Формирование налоговых документов
  - Выгрузка финансовых отчетов

### 1.3 Администраторы платформы

#### Модератор контента
- **Права**:
  - Проверка и одобрение/отклонение игр и обновлений
  - Модерация отзывов пользователей
  - Проверка соответствия контента правилам платформы
  - Модерация форумов и сообщений пользователей
  - Предупреждение нарушителей

#### Специалист технической поддержки
- **Права**:
  - Доступ к системе обращений пользователей
  - Просмотр базовой информации об аккаунтах
  - Сброс паролей и помощь с доступом
  - Базовые операции с библиотекой пользователя
  - Обработка запросов на возврат средств
  - Создание и редактирование статей базы знаний

#### Менеджер платежей
- **Права**:
  - Просмотр всех транзакций в системе
  - Управление возвратами средств
  - Разрешение споров по платежам
  - Блокировка подозрительных транзакций
  - Создание отчетов по продажам

#### Системный администратор
- **Права**:
  - Мониторинг и управление инфраструктурой
  - Управление учетными записями сотрудников
  - Настройка параметров безопасности
  - Доступ к логам системы
  - Создание и восстановление резервных копий
  - Развертывание обновлений платформы

#### Администратор платформы (высший уровень)
- **Права**:
  - Полный доступ ко всем функциям платформы
  - Создание и управление ролями пользователей
  - Просмотр и изменение всех данных в системе
  - Управление критическими настройками платформы
  - Экспорт/импорт данных
  - Запуск системных процессов

## 2. Матрица доступа к функциональным модулям

| Модуль/Функция | Игрок | Премиум | Разработчик | Издатель | Модератор | Тех. поддержка | Системный админ |
|----------------|-------|---------|-------------|----------|-----------|----------------|-----------------|
| Просмотр каталога | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| Покупка игр | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| Управление библиотекой | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| Публикация игр | - | - | ✓ | ✓ | - | - | ✓ |
| Управление ценами | - | - | ✓ | ✓ | - | - | ✓ |
| Анализ продаж | - | - | ✓ | ✓ | - | - | ✓ |
| Обновление контента | - | - | ✓ | ✓ | - | - | ✓ |
| Модерация игр | - | - | - | - | ✓ | - | ✓ |
| Обращения поддержки | ✓ | ✓ | ✓ | ✓ | - | ✓ | ✓ |
| Финансовые отчеты | - | - | ✓ | ✓ | - | - | ✓ |
| Работа с возвратами | - | - | - | - | - | ✓ | ✓ |
| Системные настройки | - | - | - | - | - | - | ✓ |
| Аналитика платформы | - | - | - | - | - | - | ✓ |

## 3. Управление правами

### 3.1 Принципы разграничения доступа
- Применение принципа минимальных привилегий
- Разделение ролей и обязанностей для исключения конфликта интересов
- Временное повышение привилегий с логированием действий
- Регулярный аудит прав доступа

### 3.2 Техническая реализация
- Использование RBAC (Role-Based Access Control)
- Проверка прав доступа на уровне API
- Кэширование разрешений для оптимизации производительности
- Дополнительные проверки для критических операций

### 3.3 Процесс назначения и изменения ролей
- Автоматическое назначение роли при регистрации
- Процедура верификации для повышения уровня доступа
- Документированный процесс запроса дополнительных прав
- Регулярный пересмотр и подтверждение прав доступа

### 3.4 Аудит действий пользователей
- Логирование всех действий с административными правами
- Мониторинг подозрительной активности
- Уведомления о критических изменениях
- Ежемесячные отчеты по активности пользователей с расширенными правами

# Документация API

## 1. Общая информация

### 1.1 Основные принципы API
- REST архитектура
- Формат обмена данными: JSON
- Базовый URL: `https://api.gameplatform.ru/v1`
- Аутентификация: JWT токены
- Пагинация: параметры `limit` и `offset`
- Версионирование через URL
- Поддержка CORS для веб-приложений

### 1.2 Аутентификация
- Авторизация через заголовок: `Authorization: Bearer {token}`
- Время жизни токена: 2 часа
- Refresh token для продления сессии с временем жизни 30 дней
- Endpoint для обновления токена: `/auth/refresh`

### 1.3 Обработка ошибок
- HTTP статус-коды для индикации результата
- Стандартизированный формат ответа об ошибке:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Человекочитаемое сообщение",
    "details": {} // Опциональные детали ошибки
  }
}
```

### 1.4 Ограничения запросов
- Rate limiting: 100 запросов в минуту для обычных пользователей
- Rate limiting: 1000 запросов в минуту для разработчиков
- Размер ответа: максимум 10MB
- Таймаут соединения: 30 секунд

## 2. Endpoints API

### 2.1 Аутентификация и пользователи

#### 2.1.1 Регистрация пользователя
- **URL**: `/auth/register`
- **Метод**: `POST`
- **Описание**: Регистрация нового пользователя
- **Тело запроса**:
```json
{
  "email": "user@example.com",
  "password": "securePassword",
  "username": "username",
  "phone_number": "+79001234567" // опционально
}
```
- **Успешный ответ** (201 Created):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "username",
  "access_token": "eyJhbGciOiJIUzI1...",
  "refresh_token": "eyJhbGciOiJIUzI1..."
}
```

#### 2.1.2 Авторизация пользователя
- **URL**: `/auth/login`
- **Метод**: `POST`
- **Описание**: Аутентификация пользователя
- **Тело запроса**:
```json
{
  "login": "user@example.com", // email или username
  "password": "securePassword"
}
```
- **Успешный ответ** (200 OK):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "username",
  "access_token": "eyJhbGciOiJIUzI1...",
  "refresh_token": "eyJhbGciOiJIUzI1..."
}
```

#### 2.1.3 Получение профиля пользователя
- **URL**: `/users/{user_id}`
- **Метод**: `GET`
- **Требуется аутентификация**: Да
- **Описание**: Получение профиля пользователя
- **Успешный ответ** (200 OK):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "username",
  "display_name": "User Display Name",
  "profile_picture_url": "https://...",
  "registration_date": "2023-01-01T12:00:00Z",
  "public_profile": true,
  "country": "RU"
}
```

#### 2.1.4 Обновление профиля пользователя
- **URL**: `/users/{user_id}`
- **Метод**: `PATCH`
- **Требуется аутентификация**: Да (только владелец профиля)
- **Описание**: Обновление данных профиля
- **Тело запроса**:
```json
{
  "display_name": "New Display Name",
  "biography": "Новая биография",
  "country": "RU",
  "public_profile": false
}
```
- **Успешный ответ** (200 OK):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "username",
  "display_name": "New Display Name",
  "biography": "Новая биография",
  "country": "RU",
  "public_profile": false
}
```

### 2.2 Каталог игр

#### 2.2.1 Получение списка игр
- **URL**: `/games`
- **Метод**: `GET`
- **Описание**: Получение списка игр с фильтрацией и сортировкой
- **Параметры запроса**:
  - `limit` (int, опционально): Количество результатов (по умолчанию 20)
  - `offset` (int, опционально): Смещение для пагинации
  - `sort_by` (string, опционально): Поле для сортировки (release_date, price, rating)
  - `sort_order` (string, опционально): Порядок сортировки (asc, desc)
  - `genre` (string, опционально): Фильтр по жанру
  - `price_min` (float, опционально): Минимальная цена
  - `price_max` (float, опционально): Максимальная цена
  - `search` (string, опционально): Поисковый запрос
- **Успешный ответ** (200 OK):
```json
{
  "total": 1500,
  "limit": 20,
  "offset": 0,
  "games": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "developer": "Разработчик",
      "publisher": "Издатель",
      "release_date": "2023-01-01T00:00:00Z",
      "price": 1999.00,
      "discount_price": 1499.00,
      "thumbnail_url": "https://...",
      "genres": ["Экшен", "Приключения"],
      "tags": ["Одиночная игра", "Открытый мир"],
      "rating": 4.8,
      "total_reviews": 1200
    },
    // ...
  ]
}
```

#### 2.2.2 Получение информации об игре
- **URL**: `/games/{game_id}`
- **Метод**: `GET`
- **Описание**: Получение детальной информации об игре
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "developer": {
    "developer_id": "12345678-1234-1234-1234-123456789012",
    "name": "Разработчик"
  },
  "publisher": {
    "publisher_id": "12345678-1234-1234-1234-123456789012",
    "name": "Издатель"
  },
  "description": "Полное описание игры...",
  "short_description": "Краткое описание",
  "release_date": "2023-01-01T00:00:00Z",
  "price": 1999.00,
  "discount_price": 1499.00,
  "discount_end_date": "2023-02-01T00:00:00Z",
  "genres": ["Экшен", "Приключения"],
  "tags": ["Одиночная игра", "Открытый мир"],
  "age_rating": "18+",
  "system_requirements": {
    "minimum": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i5-6600K",
      "memory": "8 GB RAM",
      "graphics": "NVIDIA GeForce GTX 970",
      "storage": "50 GB"
    },
    "recommended": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i7-8700K",
      "memory": "16 GB RAM",
      "graphics": "NVIDIA GeForce RTX 2070",
      "storage": "50 GB SSD"
    }
  },
  "screenshots": [
    {"url": "https://...", "caption": "Описание скриншота"}
  ],
  "videos": [
    {"url": "https://...", "title": "Трейлер игры"}
  ],
  "rating": 4.8,
  "total_reviews": 1200,
  "positive_reviews_percent": 92
}
```

#### 2.2.3 Получение отзывов об игре
- **URL**: `/games/{game_id}/reviews`
- **Метод**: `GET`
- **Описание**: Получение отзывов об игре
- **Параметры запроса**:
  - `limit` (int, опционально): Количество результатов (по умолчанию 20)
  - `offset` (int, опционально): Смещение для пагинации
  - `sort_by` (string, опционально): Поле для сортировки (date, helpful, playtime)
  - `sort_order` (string, опционально): Порядок сортировки (asc, desc)
  - `rating` (string, опционально): Фильтр по оценке (positive, negative, all)
- **Успешный ответ** (200 OK):
```json
{
  "total": 1200,
  "limit": 20,
  "offset": 0,
  "reviews": [
    {
      "review_id": "12345678-1234-1234-1234-123456789012",
      "user": {
        "user_id": "12345678-1234-1234-1234-123456789012",
        "username": "username",
        "display_name": "User Display Name"
      },
      "rating": 5,
      "is_recommended": true,
      "content": "Текст отзыва...",
      "created_at": "2023-01-10T12:00:00Z",
      "updated_at": "2023-01-10T14:30:00Z",
      "playtime_at_review": 120,
      "helpful_votes": 45
    },
    // ...
  ]
}
```

### 2.3 Библиотека пользователя

#### 2.3.1 Получение библиотеки игр пользователя
- **URL**: `/users/{user_id}/library`
- **Метод**: `GET`
- **Требуется аутентификация**: Да (только владелец)
- **Описание**: Получение списка игр пользователя
- **Параметры запроса**:
  - `limit` (int, опционально): Количество результатов (по умолчанию 20)
  - `offset` (int, опционально): Смещение для пагинации
  - `sort_by` (string, опционально): Поле для сортировки (title, purchase_date, last_played, playtime)
  - `sort_order` (string, опционально): Порядок сортировки (asc, desc)
- **Успешный ответ** (200 OK):
```json
{
  "total": 45,
  "limit": 20,
  "offset": 0,
  "games": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "thumbnail_url": "https://...",
      "purchase_date": "2023-01-01T12:00:00Z",
      "last_played": "2023-02-10T18:30:00Z",
      "total_playtime_minutes": 1250,
      "is_hidden": false
    },
    // ...
  ]
}
```

#### 2.3.2 Получение информации о владении игрой
- **URL**: `/users/{user_id}/games/{game_id}`
- **Метод**: `GET`
- **Требуется аутентификация**: Да (только владелец)
- **Описание**: Проверка владения игрой и получение связанной информации
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "purchase_date": "2023-01-01T12:00:00Z",
  "last_played": "2023-02-10T18:30:00Z",
  "total_playtime_minutes": 1250,
  "achievements": {
    "total": 50,
    "unlocked": 35
  },
  "version": {
    "current": "1.2.3",
    "available": "1.2.4",
    "update_size_mb": 150
  },
  "dlc": [
    {
      "dlc_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название DLC",
      "owned": true
    },
    {
      "dlc_id": "87654321-4321-4321-4321-210987654321",
      "title": "Название DLC 2",
      "owned": false,
      "price": 499.00
    }
  ]
}
```

### 2.4 Транзакции и платежи

#### 2.4.1 Создание заказа
- **URL**: `/orders`
- **Метод**: `POST`
- **Требуется аутентификация**: Да
- **Описание**: Создание нового заказа
- **Тело запроса**:
```json
{
  "items": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "is_gift": false
    },
    {
      "game_id": "87654321-4321-4321-4321-210987654321",
      "is_gift": true,
      "gift_recipient_id": "12345678-1234-1234-1234-123456789012",
      "gift_message": "Поздравляю с днем рождения!"
    }
  ],
  "payment_method": "card" // card, sbp, wallet, etc.
}
```
- **Успешный ответ** (201 Created):
```json
{
  "order_id": "12345678-1234-1234-1234-123456789012",
  "total_amount": 2498.00,
  "currency": "RUB",
  "status": "pending",
  "payment_url": "https://...",
  "expires_at": "2023-01-01T12:30:00Z"
}
```

#### 2.4.2 Получение информации о заказе
- **URL**: `/orders/{order_id}`
- **Метод**: `GET`
- **Требуется аутентификация**: Да (только владелец заказа)
- **Описание**: Получение информации о заказе
- **Успешный ответ** (200 OK):
```json
{
  "order_id": "12345678-1234-1234-1234-123456789012",
  "created_at": "2023-01-01T12:00:00Z",
  "status": "completed",
  "total_amount": 2498.00,
  "currency": "RUB",
  "payment_method": "card",
  "items": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "price": 1999.00,
      "discount_amount": 0.00,
      "is_gift": false
    },
    {
      "game_id": "87654321-4321-4321-4321-210987654321",
      "title": "Название игры 2",
      "price": 499.00,
      "discount_amount": 0.00,
      "is_gift": true,
      "gift_recipient": {
        "user_id": "12345678-1234-1234-1234-123456789012",
        "username": "username"
      },
      "gift_message": "Поздравляю с днем рождения!"
    }
  ]
}
```

### 2.5 API для разработчиков

#### 2.5.1 Загрузка новой игры
- **URL**: `/developer/games`
- **Метод**: `POST`
- **Требуется аутентификация**: Да (роль разработчика)
- **Описание**: Создание новой игры в системе
- **Тело запроса**:
```json
{
  "title": "Название игры",
  "short_description": "Краткое описание",
  "description": "Полное описание...",
  "genres": ["Экшен", "Приключения"],
  "tags": ["Одиночная игра", "Открытый мир"],
  "age_rating": "18+",
  "base_price": 1999.00,
  "system_requirements": {
    "minimum": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i5-6600K",
      "memory": "8 GB RAM",
      "graphics": "NVIDIA GeForce GTX 970",
      "storage": "50 GB"
    },
    "recommended": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i7-8700K",
      "memory": "16 GB RAM",
      "graphics": "NVIDIA GeForce RTX 2070",
      "storage": "50 GB SSD"
    }
  }
}
```
- **Успешный ответ** (201 Created):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "status": "draft",
  "created_at": "2023-01-01T12:00:00Z"
}
```

#### 2.5.2 Загрузка новой версии игры
- **URL**: `/developer/games/{game_id}/versions`
- **Метод**: `POST`
- **Требуется аутентификация**: Да (роль разработчика, владелец игры)
- **Описание**: Загрузка новой версии игры
- **Тело запроса**:
```json
{
  "version_number": "1.2.3",
  "release_notes": "Обновление включает...",
  "is_public": false
}
```
- **Успешный ответ** (201 Created):
```json
{
  "version_id": "12345678-1234-1234-1234-123456789012",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "version_number": "1.2.3",
  "status": "draft",
  "created_at": "2023-01-01T12:00:00Z",
  "upload_url": "https://..." // URL для загрузки файлов
}
```

#### 2.5.3 Получение статистики продаж
- **URL**: `/developer/games/{game_id}/sales`
- **Метод**: `GET`
- **Требуется аутентификация**: Да (роль разработчика, владелец игры)
- **Описание**: Получение статистики продаж игры
- **Параметры запроса**:
  - `period` (string, опционально): Период (day, week, month, year, all)
  - `start_date` (string, опционально): Начальная дата в формате ISO
  - `end_date` (string, опционально): Конечная дата в формате ISO
  - `group_by` (string, опционально): Группировка (day, week, month, country)
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "period": {
    "start_date": "2023-01-01T00:00:00Z",
    "end_date": "2023-01-31T23:59:59Z"
  },
  "total_sales": 1250,
  "total_revenue": 2498750.00,
  "currency": "RUB",
  "developer_revenue": 1749125.00,
  "platform_fee": 749625.00,
  "data": [
    {
      "date": "2023-01-01",
      "sales": 125,
      "revenue": 249875.00,
      "developer_revenue": 174912.50
    },
    // ...
  ],
  "by_country": [
    {
      "country": "RU",
      "sales": 1000,
      "revenue": 1999000.00
    },
    {
      "country": "KZ",
      "sales": 150,
      "revenue": 299850.00
    },
    // ...
  ]
}
```

### 2.6 API для администраторов

#### 2.6.1 Получение списка ожидающих проверки игр
- **URL**: `/admin/moderation/games`
- **Метод**: `GET`
- **Требуется аутентификация**: Да (роль модератора)
- **Описание**: Получение списка игр, ожидающих проверки модератором
- **Параметры запроса**:
  - `limit` (int, опционально): Количество результатов (по умолчанию 20)
  - `offset` (int, опционально): Смещение для пагинации
  - `status` (string, опционально): Статус (pending_review, all)
- **Успешный ответ** (200 OK):
```json
{
  "total": 15,
  "limit": 20,
  "offset": 0,
  "games": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "developer": {
        "developer_id": "12345678-1234-1234-1234-123456789012",
        "name": "Разработчик"
      },
      "submitted_at": "2023-01-01T12:00:00Z",
      "status": "pending_review",
      "type": "new_game" // new_game, update, dlc
    },
    // ...
  ]
}
```

## 3. Рекомендации по использованию API

### 3.1 Эффективная работа с API
- Запрашивайте только необходимые данные через параметры запроса
- Используйте пагинацию для больших наборов данных
- Сохраняйте полученные данные в локальном кэше, где это уместно
- Обрабатывайте ошибки и повторяйте запросы с экспоненциальной задержкой

### 3.2 Рекомендации по безопасности
- Храните токены в безопасном месте
- Обновляйте токены до их истечения
- Не передавайте токены в URL
- Используйте HTTPS для всех запросов
- Проверяйте возвращаемые данные перед их использованием

### 3.3 Ограничения API
- Избегайте превышения лимитов запросов (rate limits)
- Ограничивайте размер загружаемых файлов (максимум 100MB)
- Соблюдайте форматы данных для всех полей
- Учитывайте таймауты для долгих операций

# Список функций MVP российского аналога Steam

## 1. Пользовательский сегмент (Игроки)

### 1.1 Регистрация и авторизация
- Регистрация через email, телефон и российские социальные сети
- Двухфакторная аутентификация
- Восстановление пароля
- Верификация аккаунта

### 1.2 Личный кабинет
- Управление профилем пользователя
- История покупок
- Управление способами оплаты
- Настройки конфиденциальности
- Настройки двухфакторной аутентификации
- Настройки уведомлений

### 1.3 Библиотека игр
- Просмотр приобретенных игр
- Сортировка и фильтрация игр
- Установка игр
- Управление обновлениями
- Просмотр достижений
- Отслеживание времени в игре

### 1.4 Магазин игр
- Каталог игр с фильтрами и поиском
- Страницы игр с описанием, скриншотами и системными требованиями
- Рекомендации игр на основе библиотеки и предпочтений
- Категории и жанры игр
- Списки популярных и новых игр
- Специальные предложения и скидки

### 1.5 Система покупок
- Интеграция с российскими платежными системами
- Корзина покупок
- Оформление заказа
- Подарки другим пользователям
- Активация ключей
- Возврат средств (ограниченный период)

### 1.6 Социальные функции
- Профили пользователей
- Список друзей
- Личные сообщения
- Группы по интересам
- Обмен скриншотами и достижениями
- Статус онлайн/оффлайн/в игре

### 1.7 Отзывы и оценки
- Написание отзывов на игры
- Оценка игр
- Оценка полезности отзывов
- Просмотр отзывов с фильтрацией

### 1.8 Список желаемого
- Добавление игр в список желаемого
- Уведомления о скидках на игры из списка желаемого
- Управление списком желаемого

### 1.9 Клиентское приложение
- Установка и обновление клиента
- Автозапуск при старте системы (опционально)
- Встроенный браузер для магазина
- Оверлей в играх
- Автоматические обновления игр
- Управление загрузками

## 2. Издательский сегмент (Разработчики/Издатели)

### 2.1 Личный кабинет разработчика
- Регистрация как разработчика/издателя
- Верификация личности/компании
- Управление командой (добавление участников)
- Управление платежной информацией
- Настройка налоговых данных

### 2.2 Управление играми
- Создание страницы игры
- Загрузка игровых файлов
- Управление дополнительным контентом (DLC)
- Публикация обновлений
- Управление бета-тестированием
- Загрузка скриншотов и видео

### 2.3 Аналитика и статистика
- Статистика продаж
- Демографические данные пользователей
- Статистика использования игры
- Отчеты о доходах
- Анализ отзывов

### 2.4 Монетизация
- Установка цен на игры и DLC
- Настройка скидок и специальных предложений
- Планирование акций
- Интеграция с платежной системой
- Отчеты о выплатах

### 2.5 Поддержка пользователей
- Ответы на отзывы
- Обработка запросов на возврат средств
- Объявления для пользователей
- FAQ по игре

## 3. Административный сегмент (Сотрудники платформы)

### 3.1 Модерация контента
- Проверка новых игр и обновлений
- Модерация отзывов
- Модерация форумов и обсуждений
- Проверка скриншотов и видео

### 3.2 Техническая поддержка
- Система обработки обращений пользователей
- Внутренняя система коммуникации
- База знаний для сотрудников
- Инструменты для восстановления доступа пользователей

### 3.3 Финансовый модуль
- Обработка платежей
- Управление возвратами средств
- Выплаты разработчикам
- Финансовая отчетность

### 3.4 Администрирование платформы
- Управление учетными записями сотрудников
- Настройка прав доступа
- Мониторинг производительности системы
- Управление системными уведомлениями
- Статистика использования платформы

### 3.5 Маркетинг
- Управление баннерами и промо-материалами
- Настройка специальных акций
- A/B тестирование
- Управление рекомендательной системой
- Создание и рассылка новостей

## 4. Технические функции

### 4.1 Инсталлятор
- Установка клиентского приложения
- Проверка системных требований
- Выбор папки для установки игр
- Настройка автозапуска и других параметров

### 4.2 Менеджер загрузок
- Многопоточная загрузка игр
- Приоритизация загрузок
- Пауза и возобновление загрузок
- Проверка целостности файлов
- Дифференциальные обновления

### 4.3 Лаунчер игр
- Запуск игр из библиотеки
- Проверка обновлений перед запуском
- Сбор статистики времени игры
- Синхронизация сохранений (базовая)

### 4.4 Безопасность
- Проверка целостности клиента
- Защита от взлома игр
- Защита от несанкционированного доступа
- Проверка файлов игры на вирусы (базовая)

### 4.5 Облачное хранилище
- Синхронизация сохранений между устройствами (базовая)
- Резервное копирование пользовательских настроек
- Квота хранилища на пользователя

## 5. Отличительные особенности для российского рынка

### 5.1 Локализация
- Полностью русскоязычный интерфейс
- Поддержка региональных особенностей и праздников
- Российские категории и теги игр

### 5.2 Интеграции
- Интеграция с российскими платежными системами (СБП, МИР, ЮMoney)
- Интеграция с российскими социальными сетями (ВКонтакте, Одноклассники)
- Интеграция с российскими сервисами доставки подарочных карт

### 5.3 Соответствие законодательству
- Система возрастной классификации согласно российскому законодательству
- Хранение персональных данных на территории РФ
- Соблюдение требований ФНС для фискализации
- Соответствие требованиям 152-ФЗ "О персональных данных"

# Спецификации безопасности

## 1. Защита данных пользователей

### 1.1 Хранение персональных данных
- Хранение всех персональных данных на серверах на территории РФ в соответствии с 152-ФЗ
- Шифрование персональных данных в хранилище (AES-256)
- Разграничение доступа к персональным данным на уровне БД
- Маскирование конфиденциальных данных в логах и отчетах
- Минимизация хранимых данных (только необходимые поля)
- Реализация механизма автоматического удаления данных по запросу пользователя
- Физическое разделение хранения персональных данных и учетных записей

### 1.2 Защита паролей
- Хранение паролей с использованием современных алгоритмов хеширования (Argon2id)
- Индивидуальная соль для каждого пользователя минимум 16 байт
- Принудительные требования к сложности пароля:
  - Минимум 8 символов
  - Наличие заглавных и строчных букв
  - Наличие цифр или специальных символов
- Защита от перебора (ограничение попыток входа)
- Уведомление пользователя о смене пароля
- Запрет использования скомпрометированных паролей из известных утечек

### 1.3 Платежная информация
- Отсутствие хранения полных данных банковских карт
- Использование токенизации для повторных платежей
- Соответствие требованиям PCI DSS для процессинга платежных данных
- Шифрование всех платежных транзакций
- Интеграция с защищенными российскими платежными шлюзами
- Аудит всех финансовых операций

## 2. Защита аккаунтов

### 2.1 Аутентификация
- Многофакторная аутентификация (MFA):
  - SMS-аутентификация
  - Аутентификационные приложения (TOTP)
  - Email-подтверждение
- Обязательная MFA для сотрудников с административным доступом
- Опциональная MFA для пользователей
- Принудительная MFA при подозрительной активности или смене устройства

### 2.2 Сессии и токены доступа
- Статистика активных сессий с возможностью принудительного завершения
- Ограниченное время жизни токенов доступа (не более 2 часов)
- Ротация refresh токенов при использовании
- Привязка токенов к IP-адресу и/или устройству
- Автоматический выход при длительном бездействии
- Защита от CSRF с помощью токенов в заголовках
- Использование JWT с подписью для авторизации API

### 2.3 Обнаружение подозрительной активности
- Определение аномального поведения пользователя:
  - Вход с нетипичного местоположения
  - Необычное время доступа
  - Нетипичное устройство
- Блокировка подозрительных операций с запросом дополнительной аутентификации
- Уведомления пользователей о подозрительной активности
- Временная блокировка аккаунта при множественных неудачных попытках входа

## 3. Безопасность инфраструктуры

### 3.1 Сетевая безопасность
- Микросегментация сети с разделением на зоны безопасности
- Межсетевое экранирование (Firewall) на периметре и между зонами
- Защита от DDoS-атак на уровне сети и приложения:
  - Фильтрация трафика на уровне провайдера
  - Распределение нагрузки через CDN
  - Ограничение количества запросов с одного IP
- Шифрование всего внешнего трафика (TLS 1.3)
- Шифрование внутреннего трафика между компонентами системы
- Регулярное сканирование периметра на наличие уязвимостей

### 3.2 Защита серверов и приложений
- Регулярные обновления ПО и операционных систем
- Минимизация поверхности атаки (отключение ненужных сервисов)
- Использование контейнеризации с изоляцией процессов
- Защита от инъекций (SQL, NoSQL, OS Command)
- Защита от XSS, CSRF и других атак на веб-приложения
- Проактивный мониторинг безопасности серверов
- Контроль целостности файлов системы
- Защита от несанкционированного доступа к API

### 3.3 Безопасность баз данных
- Изоляция баз данных от публичных сетей
- Строгое разграничение прав доступа к БД
- Шифрование критичных данных на уровне колонок
- Аудит всех операций с чувствительными данными
- Регулярное резервное копирование с шифрованием
- Защита от SQL-инъекций через параметризованные запросы
- Ротация учетных данных доступа к БД

## 4. Безопасность клиентского приложения

### 4.1 Защита клиентского ПО
- Цифровая подпись исполняемых файлов
- Проверка целостности при запуске
- Защищенный канал обновлений
- Защита от реверс-инжиниринга критических компонентов
- Безопасное хранение локальных данных
- Шифрование кэшированного контента
- Защита от модификации клиента

### 4.2 Защита игрового контента
- DRM-защита игровых файлов
- Проверка целостности игровых файлов перед запуском
- Защита игр от несанкционированного копирования
- Античит-система для многопользовательских игр
- Безопасная доставка игрового контента

### 4.3 Безопасная коммуникация
- Использование TLS для всех коммуникаций
- Защита от перехвата сетевого трафика
- Валидация сертификатов на стороне клиента
- Защита от подмены DNS и атак "человек посередине"
- Проверка подлинности сервера

## 5. Процессы обеспечения безопасности

### 5.1 Управление уязвимостями
- Регулярные проверки безопасности (penetration testing)
- Сканирование кода на уязвимости в процессе разработки
- Программа Bug Bounty для выявления уязвимостей
- Матрица оценки и приоритизации уязвимостей
- Процесс реагирования на обнаруженные уязвимости
- Регулярные обновления безопасности всех компонентов

### 5.2 Мониторинг и обнаружение инцидентов
- Система мониторинга безопасности в режиме реального времени
- Централизованный сбор и анализ журналов безопасности
- Автоматическое обнаружение аномалий и вторжений
- Оповещение о подозрительных событиях
- Круглосуточный мониторинг системы
- Интеграция с SIEM-системой

### 5.3 Управление инцидентами
- Документированный план реагирования на инциденты
- Классификация инцидентов по степени критичности
- Процедуры эскалации при обнаружении инцидентов
- Регулярные учения по реагированию на инциденты
- Анализ первопричин после инцидентов
- Процесс извлечения уроков и улучшения систем защиты

### 5.4 Соответствие требованиям законодательства
- Соблюдение требований 152-ФЗ "О персональных данных"
- Соблюдение требований 187-ФЗ (для КИИ)
- Соответствие требованиям регуляторов (ФСТЭК, ФСБ)
- Регулярный аудит соответствия требованиям
- Локализация данных внутри РФ
- Документирование процессов обработки персональных данных

## 6. Аудит и контроль

### 6.1 Логирование действий
- Логирование всех административных действий
- Логирование критичных пользовательских операций (смена пароля, платежи)
- Защита целостности логов от модификации
- Централизованное хранение журналов безопасности
- Механизмы корреляции событий безопасности
- Долгосрочное хранение критичных журналов аудита (не менее 1 года)

### 6.2 Контроль доступа
- Принцип наименьших привилегий для всех пользователей
- Многоуровневая система разграничения доступа
- Матрица доступа с регулярным пересмотром
- Временное повышение привилегий для административных операций
- Автоматическая деактивация неиспользуемых учетных записей
- Требования к сложности паролей в зависимости от уровня доступа

### 6.3 Обучение и повышение осведомленности
- Регулярные тренинги по информационной безопасности для сотрудников
- Программа повышения осведомленности пользователей
- Рекомендации по безопасности для пользователей платформы
- Симуляции фишинговых атак для оценки готовности
- Документированные политики и процедуры безопасности

# План развертывания и инфраструктуры

## 1. Инфраструктурные требования

### 1.1 Серверная инфраструктура

#### 1.1.1 Вычислительные ресурсы (Production)
- **Серверы приложений**:
  - Минимум 10 виртуальных машин (8 vCPU, 32GB RAM каждая)
  - Операционная система: Ubuntu Server 22.04 LTS
  - Распределение по 2 разным дата-центрам
  - Автоматическое масштабирование при нагрузке до 30 экземпляров
  
- **Серверы баз данных**:
  - Первичный кластер: 3 мощных сервера (16 vCPU, 64GB RAM, SSD)
  - Реплика в резервном дата-центре: 3 сервера аналогичной конфигурации
  - Выделенные серверы для аналитических запросов: 2 сервера

- **Кэширующие серверы**:
  - Кластер Redis: 3 сервера (4 vCPU, 16GB RAM)
  - Дублирование в резервном дата-центре

- **Серверы очередей сообщений**:
  - Кластер Kafka: 5 брокеров (8 vCPU, 32GB RAM)
  - Распределение по разным дата-центрам

- **Серверы для хранения контента**:
  - Распределенное объектное хранилище: минимум 500TB
  - Специализированное оборудование для хранения с высокой пропускной способностью
  - Географическое распределение для оптимизации доставки контента

#### 1.1.2 Вычислительные ресурсы (Тестовая среда)
- Уменьшенная копия продакшн-инфраструктуры (30% мощности)
- Полное отделение от продакшн-окружения
- Виртуализированная среда для быстрого создания и удаления тестовых стендов

#### 1.1.3 Вычислительные ресурсы (Разработка)
- Локальное окружение для разработчиков
- CI/CD серверы: 3 сервера (8 vCPU, 32GB RAM)
- Среда для тестирования развертывания

### 1.2 Сетевая инфраструктура

#### 1.2.1 Внешняя связность
- Подключение к интернету: минимум 2 независимых канала по 10 Gbps
- BGP маршрутизация с несколькими провайдерами
- Защита от DDoS на уровне сети: 
  - Фильтрация трафика на уровне провайдера
  - Локальная система обнаружения и противодействия атакам

#### 1.2.2 Внутренняя сеть
- Сегментация сети на зоны безопасности (DMZ, внутренняя сеть)
- Минимум 40 Gbps внутренней связности между серверами
- Резервирование сетевого оборудования (N+1)
- Межсетевые экраны на границах сегментов

#### 1.2.3 Распределение контента
- CDN с точками присутствия в крупных городах России
- PoP в странах СНГ для улучшения доставки контента
- Локальные кэши у провайдеров для популярного контента

### 1.3 Системы хранения данных

#### 1.3.1 Базы данных
- PostgreSQL для основных данных:
  - Синхронная репликация в основном ДЦ
  - Асинхронная репликация в резервный ДЦ
  - Автоматический failover

- MongoDB для неструктурированных данных:
  - Реплицированный набор из 3 узлов в каждом ДЦ
  - Шардирование для масштабирования

- Redis для кэширования и временных данных:
  - Кластерная конфигурация
  - Репликация в резервный ДЦ

#### 1.3.2 Хранилище файлов
- S3-совместимое объектное хранилище:
  - Минимум 3 копии каждого объекта
  - Распределение между дата-центрами
  - Автоматическая проверка целостности

- Архивное хранилище:
  - Холодное хранение неактивных данных
  - Механизмы восстановления в случае необходимости

#### 1.3.3 Резервное копирование
- Полное резервное копирование баз данных: еженедельно
- Инкрементальное резервное копирование: ежедневно
- Логи транзакций: копирование каждые 15 минут
- Проверка целостности резервных копий: автоматическая
- Хранение резервных копий: минимум 3 месяца

## 2. Технологический стек

### 2.1 Серверная часть
- **Языки программирования**:
  - Go для высоконагруженных сервисов и микросервисов
  - Java/Kotlin для бизнес-логики
  - Python для аналитики и вспомогательных сервисов

- **Фреймворки**:
  - Go: Gin, Echo
  - Java: Spring Boot
  - Python: FastAPI, Django

- **Инфраструктура микросервисов**:
  - Контейнеризация: Docker
  - Оркестрация: Kubernetes
  - Service Mesh: Istio
  - API Gateway: Kong/Envoy

- **Обработка данных**:
  - Потоковая обработка: Kafka Streams
  - Пакетная обработка: Apache Spark
  - Аналитика в реальном времени: Flink

- **Мониторинг и логирование**:
  - Система мониторинга: Prometheus + Grafana
  - Логирование: ELK Stack (Elasticsearch, Logstash, Kibana)
  - Трассировка: Jaeger
  - Аналитика ошибок: Sentry

### 2.2 Клиентская часть
- **Настольный клиент**:
  - C++ / Qt для основного приложения
  - Механизмы обновления и управления версиями

- **Веб-интерфейс**:
  - React.js для пользовательского интерфейса
  - TypeScript для типизации
  - Redux для управления состоянием
  - Styled Components / Tailwind CSS для стилизации

- **Мобильные приложения**:
  - React Native для кроссплатформенной разработки
  - Kotlin для нативных компонентов Android
  - Swift для нативных компонентов iOS

## 3. Стратегия развертывания

### 3.1 Окружения
- **Разработка (DEV)**:
  - Индивидуальные окружения для разработчиков
  - Интеграционное окружение для командной работы
  - Автоматическое развертывание из ветки разработки

- **Тестирование (TEST)**:
  - Окружение для QA тестирования
  - Нагрузочное тестирование
  - Автоматизированные тесты интеграции

- **Предпродакшн (STAGING)**:
  - Полная копия продакшн-окружения
  - Финальная проверка перед релизом
  - Тестирование миграций данных

- **Продакшн (PROD)**:
  - Распределение между дата-центрами
  - Постепенное развертывание (rolling update)
  - Возможность быстрого отката

### 3.2 CI/CD пайплайн
- **Сборка**:
  - Автоматическая сборка при каждом коммите
  - Статический анализ кода
  - Проверка безопасности зависимостей

- **Тестирование**:
  - Модульные тесты
  - Интеграционные тесты
  - Функциональные тесты
  - Тесты производительности

- **Развертывание**:
  - Автоматическое развертывание в DEV/TEST
  - Полуавтоматическое развертывание в STAGING/PROD
  - Feature flags для контроля новой функциональности

- **Мониторинг**:
  - Проверка успешности развертывания
  - Автоматический откат при критических ошибках
  - Мониторинг производительности после развертывания

### 3.3 Управление релизами
- **Версионирование**:
  - Семантическое версионирование для всех компонентов
  - Независимые версии микросервисов с совместимостью API

- **График релизов**:
  - Регулярные релизы клиента: ежемесячно
  - Обновления бэкенда: непрерывно (CI/CD)
  - Крупные обновления платформы: ежеквартально

- **Управление изменениями**:
  - Документирование всех изменений
  - План отката для каждого развертывания
  - Постепенное внедрение крупных изменений

## 4. Масштабирование и отказоустойчивость

### 4.1 Стратегия масштабирования
- **Горизонтальное масштабирование**:
  - Автоматическое масштабирование на основе метрик нагрузки
  - Заблаговременное масштабирование перед плановыми пиками
  - Максимальное количество экземпляров: определяется для каждого сервиса

- **Вертикальное масштабирование**:
  - Для компонентов, которые сложно горизонтально масштабировать
  - Плановые миграции на более мощное оборудование

- **Масштабирование хранилища**:
  - Шардирование баз данных по мере роста
  - Разделение горячих и холодных данных
  - Увеличение объема хранилища для контента

### 4.2 Отказоустойчивость
- **Стратегия резервирования**:
  - Активно-активная конфигурация между дата-центрами
  - Автоматическое переключение при отказе компонентов
  - N+1 резервирование для критических систем

- **Изоляция сбоев**:
  - Использование circuit breaker для предотвращения каскадных сбоев
  - Разделение на домены отказа
  - Деградация функциональности вместо полного отказа

- **Восстановление после сбоев**:
  - RTO (Recovery Time Objective): не более 4 часов для критических систем
  - RPO (Recovery Point Objective): не более 15 минут потери данных
  - Автоматизированные процедуры восстановления

### 4.3 Планирование мощностей
- **Мониторинг использования ресурсов**:
  - Непрерывное отслеживание трендов использования
  - Прогнозирование будущих потребностей

- **Планирование расширения**:
  - Регулярный пересмотр требуемых мощностей
  - Заблаговременное приобретение ресурсов
  - Учет сезонности и маркетинговых кампаний

## 5. Мониторинг и эксплуатация

### 5.1 Система мониторинга
- **Инфраструктурный мониторинг**:
  - Мониторинг всех физических и виртуальных компонентов
  - Контроль сетевой доступности и производительности
  - Мониторинг дисковой подсистемы и баз данных

- **Мониторинг приложений**:
  - Отслеживание работоспособности API
  - Мониторинг времени отклика сервисов
  - Отслеживание ошибок и исключений

- **Мониторинг бизнес-метрик**:
  - Количество активных пользователей
  - Количество транзакций
  - Объем загрузок и установок

### 5.2 Логирование и аналитика
- **Централизованный сбор логов**:
  - Агрегация логов со всех компонентов системы
  - Структурированное логирование в JSON-формате
  - Долгосрочное хранение критичных логов

- **Аналитика логов**:
  - Поиск и фильтрация по логам
  - Автоматическое обнаружение аномалий
  - Корреляция событий между компонентами

- **Трассировка запросов**:
  - Сквозная трассировка через все микросервисы
  - Анализ узких мест производительности
  - Детальное отслеживание запросов пользователей

### 5.3 Процессы поддержки
- **Управление инцидентами**:
  - Классификация инцидентов по приоритету
  - Процедуры эскалации для критичных проблем
  - Пост-мортем анализ после серьезных инцидентов

- **Управление изменениями**:
  - Согласование всех изменений в продакшн
  - Окна обслуживания для плановых работ
  - Минимизация простоев при обновлениях

- **Дежурство и реагирование**:
  - 24/7 дежурство команды поддержки
  - Система оповещения о критичных событиях
  - Автоматизация рутинных задач

## 6. Стратегия запуска и миграции

### 6.1 Фазы запуска
- **Фаза 1: Закрытое альфа-тестирование**
  - Ограниченный доступ для внутренних тестировщиков
  - Базовый набор функций
  - Фокус на стабильность системы

- **Фаза 2: Закрытое бета-тестирование**
  - Приглашение ограниченного числа внешних пользователей
  - Расширенный набор функций
  - Сбор обратной связи и исправление ошибок

- **Фаза 3: Публичное бета-тестирование**
  - Открытый доступ для всех желающих
  - Предупреждение о возможных проблемах
  - Активный сбор обратной связи

- **Фаза 4: Полный запуск**
  - Официальный релиз платформы
  - Поэтапное масштабирование для обеспечения стабильности
  - Полноценная маркетинговая кампания

### 6.2 Миграция разработчиков
- **Программа раннего доступа**:
  - Привлечение ключевых российских разработчиков
  - Специальные условия для первых участников
  - Техническая помощь в миграции игр

- **Документация и инструменты**:
  - Подробные руководства по публикации
  - API для интеграции с существующими системами
  - Инструменты для миграции метаданных игр

- **Поддержка разработчиков**:
  - Выделенная команда для помощи в миграции
  - Приоритетная обработка обращений от разработчиков
  - Обучающие вебинары и материалы

### 6.3 Управление рисками запуска
- **Идентификация рисков**:
  - Технические риски (стабильность, производительность)
  - Риски принятия пользователями
  - Регуляторные риски

- **Планы смягчения рисков**:
  - Резервные мощности для непредвиденных пиков
  - Поэтапный запуск для контроля нагрузки
  - Тесное взаимодействие с регуляторами

- **Метрики успеха**:
  - Количество активных пользователей
  - Количество опубликованных игр
  - Стабильность платформы
  - Время отклика системы

# Интеграционная стратегия

## 1. Платежные интеграции

### 1.1 Российские платежные системы
- **Банковские карты МИР**
  - Прямая интеграция с НСПК (Национальная система платежных карт)
  - Поддержка всех банков-эмитентов карт МИР
  - Особые условия эквайринга для поддержки отечественной платежной системы

- **Система быстрых платежей (СБП)**
  - Интеграция для моментальных платежей по QR-коду
  - Оплата по номеру телефона
  - Сниженная комиссия по сравнению с карточным эквайрингом
  - Прямая интеграция через API Банка России или через банк-посредник

- **ЮMoney (бывшие Яндекс.Деньги)**
  - Интеграция через API ЮMoney
  - Поддержка платежей с кошелька пользователя
  - Возможность пополнения кошелька различными способами

- **QIWI**
  - API для прямых платежей с QIWI-кошелька
  - Интеграция с терминальной сетью QIWI для офлайн-платежей
  - Система генерации ваучеров для предоплаты

- **Единый платежный агрегатор**
  - Интеграция с агрегатором для обеспечения резервного канала платежей
  - Поддержка операций возврата средств
  - Управление рекуррентными платежами

### 1.2 Электронная фискализация
- **Интеграция с операторами фискальных данных (ОФД)**
  - Автоматическая передача данных о транзакциях в ФНС
  - Соответствие 54-ФЗ "О применении контрольно-кассовой техники"
  - Формирование кассовых чеков в электронном виде

- **Хранение фискальных документов**
  - Архивирование всех фискальных документов
  - Предоставление чеков пользователям
  - Возможность повторной отправки чека

### 1.3 Международные платежные системы (опционально)
- **Банковские карты Visa/Mastercard**
  - Поддержка через российские банки-эквайеры
  - Учет санкционных ограничений
  - Резервные маршруты проведения транзакций

- **Электронные кошельки**
  - WebMoney
  - Криптовалютные платежи (при соответствии законодательству)

## 2. Интеграция с системами авторизации

### 2.1 Российские социальные сети и сервисы
- **ВКонтакте**
  - OAuth авторизация
  - Получение базового профиля пользователя
  - Публикация активности пользователя (опционально)
  - Интеграция с группами по играм

- **Одноклассники**
  - OAuth авторизация
  - Импорт списка друзей (с разрешения пользователя)
  - Шаринг достижений в игре

- **Госуслуги (ЕСИА)**
  - Авторизация через государственную систему идентификации
  - Верификация возраста для выполнения требований возрастной классификации
  - Подтверждение личности для ограниченного доступа к контенту

- **Сбер ID**
  - Единая авторизация пользователей экосистемы Сбера
  - Получение верифицированных данных пользователя

### 2.2 Верификация
- **Верификация номера телефона**
  - Интеграция с SMS-шлюзами российских операторов
  - Система одноразовых кодов подтверждения
  - Защита от массовой регистрации

- **Система подтверждения возраста**
  - Интеграция с ЕСИА для государственной верификации
  - Альтернативные механизмы верификации возраста
  - Соответствие требованиям о защите детей от информации

## 3. Интеграция с разработчиками и издателями

### 3.1 API для разработчиков
- **Панель разработчика**
  - API для управления играми и контентом
  - Система уведомлений о критических событиях
  - Интеграция с CI/CD процессами разработчиков

- **SDK для издателей**
  - Библиотеки для интеграции с платформой
  - Компоненты для встраивания в игры (достижения, облачные сохранения)
  - Поддержка популярных игровых движков (Unity, Unreal Engine)
  - Инструменты локализации и адаптации

### 3.2 Система защиты DRM
- **Собственная система DRM**
  - API для интеграции защиты в игры
  - Проверка лицензий при запуске
  - Механизмы защиты от взлома

- **SDK для разработчиков**
  - Готовые библиотеки для основных платформ
  - Документация по интеграции
  - Примеры реализации

### 3.3 Аналитика для разработчиков
- **Сбор и предоставление данных**
  - API для получения аналитики продаж
  - Статистика использования игр
  - Демографические данные пользователей (анонимизированные)
  - Поведенческие паттерны игроков

- **Инструменты отчетности**
  - Готовые шаблоны отчетов
  - Возможность экспорта данных
  - Панель визуализации данных

## 4. Системные интеграции

### 4.1 Интеграция с CDN
- **Собственная CDN**
  - Размещение серверов в ключевых регионах России
  - Оптимизация маршрутизации для уменьшения задержек
  - Протоколы ускорения загрузки (HTTP/2, QUIC)

- **Интеграция с российскими CDN-провайдерами**
  - API для автоматической публикации контента
  - Система инвалидации кэша
  - Мониторинг доступности и производительности

### 4.2 Облачное хранение
- **Облачное хранилище для сохранений**
  - API для синхронизации игровых сохранений
  - Квотирование пространства для пользователей
  - Версионирование сохранений

- **Интеграция с российскими облачными провайдерами**
  - Использование российских облачных платформ для соответствия 152-ФЗ
  - Резервирование данных в нескольких независимых облаках
  - Шифрование данных в хранилище

### 4.3 Интеграция с антивирусными системами
- **Проверка загружаемого контента**
  - Интеграция с российскими антивирусными решениями
  - Автоматическое сканирование загружаемых игр
  - Мониторинг подозрительной активности

- **Защита от вредоносного ПО**
  - Проверка исполняемых файлов перед запуском
  - Система репутации контента
  - Быстрое реагирование на угрозы

## 5. Маркетинговые интеграции

### 5.1 Интеграция с аналитическими системами
- **Системы веб-аналитики**
  - Интеграция с Яндекс.Метрика
  - Отслеживание пользовательских путей
  - A/B тестирование интерфейса

- **Системы трекинга конверсий**
  - Отслеживание источников регистраций
  - Анализ путей к покупке
  - Оценка эффективности маркетинговых каналов

### 5.2 Система рекомендаций и персонализации
- **Рекомендательный движок**
  - Собственный алгоритм рекомендаций на основе поведения пользователя
  - Коллаборативная фильтрация игр
  - Персонализация главной страницы магазина

- **Таргетированные предложения**
  - Система персонализированных скидок
  - Уведомления о релевантных новинках
  - Рекомендации на основе предпочтений друзей

### 5.3 Программа лояльности
- **Система бонусов и баллов**
  - Интеграция с внутренней валютой платформы
  - Начисление за активность и покупки
  - Обмен на игры или внутриигровые бонусы

- **Интеграция с партнерскими программами**
  - API для подключения партнерских сервисов
  - Кросс-промо с другими российскими сервисами
  - Система промокодов и ваучеров

## 6. Интеграция с системами технической поддержки

### 6.1 Система управления поддержкой
- **Тикетная система**
  - Интеграция с внутренней системой обращений
  - Автоматическая категоризация обращений
  - Отслеживание статуса обращений пользователями

- **База знаний**
  - Система автоматических рекомендаций по решению проблем
  - Интеграция контекстной помощи в интерфейс
  - Поиск по базе знаний с учетом контекста пользователя

### 6.2 Интеграция с системами коммуникации
- **Чат-боты**
  - Интеграция с российскими платформами чат-ботов
  - Автоматизация ответов на типовые вопросы
  - Эскалация сложных вопросов на операторов

- **Система уведомлений**
  - Push-уведомления на мобильных устройствах
  - Email-уведомления
  - Интеграция с мессенджерами (Telegram)
  - Система приоритизации уведомлений

## 7. Интеграция со стриминговыми сервисами

### 7.1 Собственный стриминговый функционал
- **Встроенная система трансляций**
  - Возможность стримить прямо из клиента
  - Интеграция с игровым оверлеем
  - Система комментариев и взаимодействия

### 7.2 Интеграция с внешними сервисами
- **Российские стриминговые платформы**
  - API для интеграции с VK Play Live
  - Автоматическая публикация активности
  - Система наград за просмотры стримов

- **Интеграция с YouTube**
  - API для публикации контента
  - Система достижений за стриминговую активность
  - Привлечение новых пользователей через стримеров

## 8. Стратегия управления интеграциями

### 8.1 Приоритизация интеграций
- **Критически важные для MVP**
  - Платежные системы (МИР, СБП, ЮMoney)
  - Базовая авторизация (Email, телефон, ВКонтакте)
  - CDN для доставки контента
  - Система фискализации

- **Важные для роста**
  - Расширенные социальные авторизации
  - Стриминговые интеграции
  - Расширенные платежные опции

- **Перспективные**
  - Интеграция с ЕСИА
  - Расширенная аналитика для разработчиков
  - Дополнительные маркетинговые интеграции

### 8.2 Техническая реализация
- **API Gateway**
  - Единая точка интеграции для внешних сервисов
  - Версионирование API
  - Управление доступом

- **Сервисная шина**
  - Асинхронное взаимодействие между компонентами
  - Гарантированная доставка сообщений
  - Маршрутизация событий

- **Система мониторинга интеграций**
  - Отслеживание доступности внешних сервисов
  - Автоматическое переключение на резервные каналы
  - Алертинг при проблемах с интеграциями

# План тестирования

## 1. Типы тестирования

### 1.1 Функциональное тестирование
- **Объем тестирования**: Проверка всех функций платформы согласно спецификациям
- **Подход**: 
  - Ручное тестирование на основе тест-кейсов
  - Автоматизированное тестирование критических функций
  - Тестирование пользовательских сценариев
- **Инструменты**: 
  - Selenium для автоматизации веб-интерфейса
  - Appium для тестирования мобильных приложений
  - Собственные инструменты для тестирования десктопного клиента
- **Критерии приемки**: 
  - 100% прохождение критических тест-кейсов
  - 95% прохождение всех функциональных тест-кейсов
  - Отсутствие блокирующих и критических дефектов

### 1.2 Тестирование безопасности
- **Объем тестирования**: Полная проверка безопасности всех компонентов системы
- **Подход**:
  - Статический анализ кода
  - Динамический анализ безопасности
  - Penetration testing (внешний и внутренний)
  - Тестирование защиты от основных видов атак (OWASP Top 10)
- **Инструменты**:
  - SonarQube для статического анализа
  - OWASP ZAP для автоматизированного сканирования
  - Burp Suite для ручного тестирования
  - Metasploit для имитации атак
- **Критерии приемки**:
  - Отсутствие критических и высоких уязвимостей
  - Устранение всех средних уязвимостей до релиза
  - Успешное прохождение penetration testing
  - Соответствие требованиям 152-ФЗ

### 1.3 Нагрузочное тестирование
- **Объем тестирования**: Проверка работоспособности системы под нагрузкой
- **Подход**:
  - Стресс-тестирование до отказа системы
  - Тестирование производительности под ожидаемой нагрузкой
  - Тестирование масштабирования
  - Длительные тесты стабильности (24+ часов)
- **Инструменты**:
  - JMeter для тестирования API
  - Gatling для имитации пользовательских сценариев
  - Собственные инструменты для тестирования специфических функций
- **Критерии приемки**:
  - Поддержка 100,000 одновременных пользователей
  - Время отклика API не более 500мс для 95% запросов
  - Время загрузки страниц не более 2 секунд
  - Стабильная работа под нагрузкой 24 часа

### 1.4 Тестирование пользовательского интерфейса
- **Объем тестирования**: Проверка всех пользовательских интерфейсов
- **Подход**:
  - Кроссбраузерное тестирование
  - Тестирование на различных устройствах
  - Проверка адаптивности интерфейса
  - Тестирование доступности (accessibility)
- **Инструменты**:
  - BrowserStack для кроссбраузерного тестирования
  - Lighthouse для проверки производительности и доступности
  - Ручное тестирование на реальных устройствах
- **Критерии приемки**:
  - Корректное отображение и функционирование во всех поддерживаемых браузерах
  - Соответствие дизайн-системе
  - Минимальный уровень доступности WCAG 2.1 AA

### 1.5 Интеграционное тестирование
- **Объем тестирования**: Проверка взаимодействия между компонентами системы
- **Подход**:
  - Тестирование API между микросервисами
  - End-to-end тестирование бизнес-процессов
  - Тестирование интеграций с внешними системами
- **Инструменты**:
  - Postman для тестирования API
  - Cucumber для BDD тестирования
  - Mock-сервисы для имитации внешних систем
- **Критерии приемки**:
  - 100% прохождение интеграционных тестов
  - Корректная обработка ошибок интеграции
  - Соответствие контрактам API

### 1.6 Тестирование локализации
- **Объем тестирования**: Проверка корректности локализации на всех поддерживаемых языках
- **Подход**:
  - Проверка текстов интерфейса
  - Тестирование специфичных для регионов функций
  - Проверка форматирования чисел, дат, валют
- **Инструменты**:
  - Crowdin для управления локализацией
  - Автоматизированная проверка строк локализации
  - Ручная проверка носителями языка
- **Критерии приемки**:
  - Отсутствие нелокализованных строк в интерфейсе
  - Корректное отображение всех символов
  - Правильное форматирование региональных данных

### 1.7 Юзабилити-тестирование
- **Объем тестирования**: Оценка удобства использования для конечных пользователей
- **Подход**:
  - Тестирование с реальными пользователями
  - Анализ пользовательских путей
  - A/B тестирование ключевых элементов интерфейса
- **Инструменты**:
  - UserTesting для тестирования с реальными пользователями
  - Hotjar для анализа поведения пользователей
  - Метрики удовлетворенности (SUS, CSAT)
- **Критерии приемки**:
  - Минимальный SUS-score 75
  - Успешное выполнение ключевых сценариев 90% тестировщиков
  - Позитивная обратная связь от тестировщиков

## 2. Тестовые окружения

### 2.1 Окружение разработки (DEV)
- **Назначение**: Тестирование в процессе разработки
- **Конфигурация**:
  - Упрощенная инфраструктура
  - Тестовые наборы данных
  - Мокированные внешние сервисы
- **Ограничения**:
  - Ограниченная производительность
  - Возможны частые изменения
  - Нестабильность в период активной разработки

### 2.2 Тестовое окружение (TEST)
- **Назначение**: Автоматизированное и ручное тестирование
- **Конфигурация**:
  - Полная инфраструктура сервисов
  - Изолированные тестовые данные
  - Стабилизированные версии компонентов
- **Ограничения**:
  - Меньшая производительность по сравнению с PROD
  - Ограниченное количество тестовых пользователей
  - Интеграция с тестовыми версиями внешних систем

### 2.3 Окружение предпродакшн (STAGING)
- **Назначение**: Финальное тестирование перед релизом
- **Конфигурация**:
  - Полная копия продакшн-инфраструктуры
  - Реальные (анонимизированные) данные
  - Интеграция с продакшн-версиями внешних систем в тестовом режиме
- **Ограничения**:
  - Доступ только для тестировщиков и команды разработки
  - Строгий контроль изменений
  - Ограниченное время жизни тестовых данных

### 2.4 Окружение для нагрузочного тестирования (PERF)
- **Назначение**: Специализированное окружение для нагрузочных тестов
- **Конфигурация**:
  - Масштабируемая инфраструктура
  - Генераторы нагрузки
  - Инструменты мониторинга производительности
- **Ограничения**:
  - Использование только для запланированных нагрузочных тестов
  - Изолированность от других сред
  - Фокус на метриках производительности

### 2.5 Окружение для тестирования безопасности (SEC)
- **Назначение**: Специализированное окружение для тестов безопасности
- **Конфигурация**:
  - Изолированная инфраструктура
  - Расширенное логирование
  - Дополнительные инструменты мониторинга безопасности
- **Ограничения**:
  - Доступ только для специалистов по безопасности
  - Изолированность от других окружений
  - Особые правила проведения тестов

## 3. Процесс тестирования

### 3.1 Тестирование в процессе разработки
- **Ответственные**: Разработчики
- **Активности**:
  - Написание и выполнение модульных тестов
  - Покрытие кода тестами не менее 80%
  - Базовое функциональное тестирование
  - Статический анализ кода
- **Результаты**:
  - Отчеты о покрытии кода
  - Результаты статического анализа
  - Проверка основных функциональных сценариев

### 3.2 Регрессионное тестирование
- **Ответственные**: Команда QA
- **Периодичность**: После каждого значимого изменения, минимум раз в неделю
- **Активности**:
  - Выполнение автоматизированных тестов
  - Проверка основных пользовательских сценариев
  - Приоритизация тестирования на основе изменений
- **Результаты**:
  - Отчет о регрессии
  - Список выявленных дефектов
  - Рекомендации по устранению дефектов

### 3.3 Релизное тестирование
- **Ответственные**: Команда QA, специалисты по безопасности
- **Периодичность**: Перед каждым релизом
- **Активности**:
  - Полное функциональное тестирование
  - Тестирование безопасности
  - Нагрузочное тестирование
  - Тестирование интеграций
  - Финальная проверка локализации
- **Результаты**:
  - Релизный отчет о тестировании
  - Список критических и некритических дефектов
  - Go/No-Go решение о релизе

### 3.4 Бета-тестирование
- **Ответственные**: Команда QA, менеджеры продукта
- **Периодичность**: Перед публичным релизом
- **Активности**:
  - Привлечение внешних тестировщиков
  - Сбор обратной связи от реальных пользователей
  - Мониторинг поведения системы в условиях реального использования
- **Результаты**:
  - Отчет о бета-тестировании
  - Анализ пользовательской обратной связи
  - Приоритизированный список улучшений

## 4. Автоматизация тестирования

### 4.1 Стратегия автоматизации
- **Приоритетные области**:
  - Критические бизнес-процессы
  - Регулярно повторяющиеся тест-кейсы
  - Регрессионное тестирование
  - API-тестирование
- **Уровни автоматизации**:
  - Модульное тестирование: 80% покрытия
  - API-тестирование: 70% покрытия основных эндпоинтов
  - UI-тестирование: 50% критических сценариев

### 4.2 Инструменты автоматизации
- **Фреймворки тестирования**:
  - JUnit/TestNG для Java
  - PyTest для Python
  - Jest для JavaScript
- **Инструменты UI-автоматизации**:
  - Selenium WebDriver
  - Cypress для веб-интерфейса
  - Appium для мобильных приложений
- **API-тестирование**:
  - REST Assured
  - Postman/Newman
  - Contract testing с Pact

### 4.3 Интеграция в CI/CD
- **Пайплайн тестирования**:
  - Запуск модульных тестов при каждом коммите
  - Запуск интеграционных тестов при мерже в основную ветку
  - Запуск полного набора тестов перед релизом
- **Отчетность**:
  - Интеграция с системой трекинга задач
  - Автоматическая генерация отчетов о тестировании
  - Визуализация результатов тестирования

## 5. Тестовые данные

### 5.1 Управление тестовыми данными
- **Стратегия создания данных**:
  - Скрипты генерации тестовых данных
  - Анонимизация продакшн-данных
  - Создание данных в процессе автотестов
- **Хранение и версионирование**:
  - Управление тестовыми данными в репозитории
  - Маркировка наборов данных по версиям
  - Изоляция тестовых пользователей

### 5.2 Типы тестовых данных
- **Тестовые пользователи**:
  - Различные типы пользователей (игроки, разработчики, администраторы)
  - Пользователи с разными уровнями доступа
  - Пользователи в разных состояниях жизненного цикла
- **Тестовые игры**:
  - Разные жанры и категории
  - Игры с различными рейтингами и оценками
  - Игры в разных состояниях (черновик, на модерации, опубликованные)
- **Транзакционные данные**:
  - Тестовые платежи разных типов
  - Возвраты и отмены платежей
  - Историческая активность пользователей

## 6. Тестирование специфических компонентов

### 6.1 Тестирование клиентского приложения
- **Объем тестирования**:
  - Установка и обновление
  - Загрузка и управление играми
  - Авторизация и безопасность
  - Производительность и стабильность
- **Подход**:
  - Автоматизированное функциональное тестирование
  - Тестирование на различных конфигурациях ПК
  - Мониторинг использования ресурсов
- **Критерии приемки**:
  - Успешная установка на 99% поддерживаемых конфигураций
  - Стабильная работа без сбоев в течение 24 часов
  - Использование ресурсов в установленных пределах

### 6.2 Тестирование API
- **Объем тестирования**:
  - Функциональное тестирование всех эндпоинтов
  - Проверка контрактов API
  - Тестирование производительности и отказоустойчивости
- **Подход**:
  - Автоматизированное тестирование с помощью Postman/Newman
  - Contract testing для проверки совместимости
  - Fuzz-тестирование для проверки обработки некорректных данных
- **Критерии приемки**:
  - 100% соответствие спецификации API
  - Корректная обработка ошибок и граничных случаев
  - Время отклика в пределах SLA

### 6.3 Тестирование платежной системы
- **Объем тестирования**:
  - Поддержка всех платежных методов
  - Обработка различных сценариев платежей
  - Возвраты и отмены платежей
  - Фискализация
- **Подход**:
  - Тестирование на тестовых средах платежных провайдеров
  - Имитация различных сценариев платежей
  - Проверка корректности финансовых данных
- **Критерии приемки**:
  - Успешная обработка 99.9% платежей
  - Корректное проведение всех финансовых операций
  - Соответствие требованиям фискализации

### 6.4 Тестирование системы авторизации
- **Объем тестирования**:
  - Регистрация и авторизация всеми способами
  - Двухфакторная аутентификация
  - Управление сессиями
  - Восстановление доступа
- **Подход**:
  - Автоматизированные тесты основных сценариев
  - Ручное тестирование сложных кейсов
  - Тестирование безопасности аутентификации
- **Критерии приемки**:
  - Безопасный и надежный процесс авторизации
  - Корректная обработка всех сценариев аутентификации
  - Соответствие требованиям безопасности

## 7. Управление дефектами

### 7.1 Процесс регистрации дефектов
- **Система трекинга**: Jira
- **Классификация дефектов**:
  - По серьезности (блокирующие, критические, высокие, средние, низкие)
  - По приоритету (P0-P4)
  - По компонентам системы
- **Обязательные поля**:
  - Описание проблемы и ожидаемое поведение
  - Шаги воспроизведения
  - Окружение и версия
  - Скриншоты/видео демонстрирующие проблему

### 7.2 Приоритизация и устранение дефектов
- **Критерии приоритизации**:
  - Влияние на бизнес-процессы
  - Количество затронутых пользователей
  - Наличие обходных путей
  - Видимость для пользователей
- **SLA по устранению дефектов**:
  - Блокирующие: немедленно (до 24 часов)
  - Критические: до 3 дней
  - Высокие: до 7 дней
  - Средние: в следующем релизе
  - Низкие: по согласованию

### 7.3 Метрики качества
- **Ключевые показатели**:
  - Количество открытых/закрытых дефектов
  - Распределение дефектов по серьезности
  - Среднее время устранения дефектов
  - Процент успешных автотестов
  - Плотность дефектов (на KLOC)
- **Отчетность**:
  - Еженедельный отчет о состоянии тестирования
  - Отчет о готовности к релизу
  - Ретроспективный анализ найденных дефектов

## 8. Риски и митигации

### 8.1 Риски процесса тестирования
- **Идентифицированные риски**:
  - Недостаточное время на тестирование
  - Сложность воспроизведения определенных сценариев
  - Ограниченные ресурсы для нагрузочного тестирования
  - Зависимость от внешних систем
- **Планы митигации**:
  - Автоматизация критических тест-кейсов
  - Создание моков внешних систем
  - Приоритизация тестирования на основе рисков
  - Раннее начало тестирования в процессе разработки

### 8.2 Критерии готовности к релизу
- **Минимальные требования**:
  - 100% прохождение критических тест-кейсов
  - Отсутствие блокирующих и критических дефектов
  - Успешное прохождение нагрузочного тестирования
  - Соответствие требованиям безопасности
  - Подтверждение от бизнес-стейкхолдеров

# Бизнес-процессы

## 1. Процессы пользовательского сегмента

### 1.1 Регистрация и адаптация пользователя
- **Триггер**: Пользователь начинает регистрацию на платформе
- **Шаги процесса**:
  1. Пользователь заполняет форму регистрации (email/телефон, пароль)
  2. Система проверяет уникальность email/телефона
  3. Система отправляет код подтверждения
  4. Пользователь подтверждает email/телефон
  5. Система создает учетную запись пользователя
  6. Система предлагает заполнить профиль (опционально)
  7. Система предлагает установить клиентское приложение
  8. Система предлагает персонализированные рекомендации игр
- **Выход**: Созданная учетная запись пользователя
- **Метрики процесса**:
  - Конверсия регистрации (% завершенных регистраций)
  - Время завершения процесса регистрации
  - % пользователей, установивших клиентское приложение

### 1.2 Покупка игры
- **Триггер**: Пользователь добавляет игру в корзину
- **Шаги процесса**:
  1. Пользователь выбирает игру для покупки
  2. Система проверяет доступность игры для аккаунта
  3. Система добавляет игру в корзину пользователя
  4. Пользователь переходит к оформлению заказа
  5. Пользователь выбирает способ оплаты
  6. Система перенаправляет на страницу оплаты
  7. Пользователь подтверждает оплату
  8. Система получает подтверждение от платежной системы
  9. Система добавляет игру в библиотеку пользователя
  10. Система генерирует и отправляет электронный чек
  11. Система уведомляет пользователя о возможности скачать игру
- **Выход**: Игра добавлена в библиотеку пользователя
- **Метрики процесса**:
  - Конверсия корзины (% завершенных покупок)
  - Среднее время завершения покупки
  - % брошенных корзин
  - Средний чек

### 1.3 Установка и запуск игры
- **Триггер**: Пользователь выбирает игру для установки
- **Шаги процесса**:
  1. Пользователь инициирует установку игры через клиент
  2. Система проверяет наличие игры в библиотеке пользователя
  3. Система проверяет достаточность свободного места
  4. Система инициирует загрузку файлов игры
  5. Клиент отображает прогресс загрузки
  6. Система устанавливает игру на устройство пользователя
  7. Система проверяет целостность файлов
  8. Система регистрирует игру в клиенте
  9. Пользователь инициирует запуск игры
  10. Система проверяет наличие обновлений
  11. Система запускает исполняемый файл игры
  12. Система отслеживает время игры
- **Выход**: Запущенная игра
- **Метрики процесса**:
  - Средняя скорость загрузки игры
  - % успешных установок
  - Время от покупки до первого запуска
  - Среднее время игровой сессии

### 1.4 Возврат средств
- **Триггер**: Пользователь инициирует возврат средств
- **Шаги процесса**:
  1. Пользователь выбирает игру для возврата
  2. Система проверяет соответствие условиям возврата (время с момента покупки, игровое время)
  3. Пользователь указывает причину возврата
  4. Система проверяет автоматические критерии для мгновенного возврата
  5. При соответствии критериям - автоматическое одобрение возврата
  6. При несоответствии - создание заявки на ручную обработку
  7. Сотрудник поддержки рассматривает заявку
  8. При одобрении - система инициирует возврат средств
  9. Система удаляет игру из библиотеки пользователя
  10. Система уведомляет пользователя о статусе возврата
  11. Система обновляет финансовые данные
- **Выход**: Возвращенные средства, игра удалена из библиотеки
- **Метрики процесса**:
  - % автоматически одобренных возвратов
  - Среднее время обработки возврата
  - % возвратов от общего числа продаж

### 1.5 Техническая поддержка пользователя
- **Триггер**: Пользователь создает обращение в поддержку
- **Шаги процесса**:
  1. Пользователь выбирает тему обращения
  2. Система предлагает подходящие статьи базы знаний
  3. Если проблема не решена - пользователь создает обращение
  4. Система автоматически классифицирует обращение
  5. Система назначает приоритет обращения
  6. Система назначает обращение на специалиста поддержки
  7. Специалист обрабатывает обращение
  8. Специалист запрашивает дополнительную информацию (при необходимости)
  9. Специалист решает проблему или эскалирует её
  10. Система фиксирует решение и уведомляет пользователя
  11. Пользователь оценивает качество поддержки
- **Выход**: Решенное обращение
- **Метрики процесса**:
  - Среднее время решения обращения
  - % решенных обращений с первого контакта
  - Удовлетворенность пользователей (CSAT)
  - % эскалаций

## 2. Процессы издательского сегмента

### 2.1 Регистрация разработчика/издателя
- **Триггер**: Разработчик/издатель начинает регистрацию
- **Шаги процесса**:
  1. Разработчик заполняет форму регистрации
  2. Система проверяет уникальность данных
  3. Разработчик загружает документы для верификации
  4. Система создает временный аккаунт разработчика
  5. Модератор проверяет документы и информацию
  6. При одобрении - система активирует аккаунт
  7. Система уведомляет разработчика о результате
  8. Разработчик заполняет платежные реквизиты
  9. Система верифицирует платежные реквизиты
  10. Разработчик получает доступ к панели разработчика
- **Выход**: Верифицированный аккаунт разработчика/издателя
- **Метрики процесса**:
  - % завершенных регистраций
  - Среднее время верификации
  - % отклоненных регистраций

### 2.2 Публикация игры
- **Триггер**: Разработчик инициирует публикацию игры
- **Шаги процесса**:
  1. Разработчик создает страницу игры
  2. Разработчик заполняет метаданные игры (название, описание, системные требования, возрастной рейтинг)
  3. Разработчик загружает графические материалы (скриншоты, баннеры, иконки)
  4. Разработчик устанавливает цену и региональные настройки
  5. Разработчик загружает файлы игры
  6. Система проверяет загруженные файлы на вирусы и целостность
  7. Разработчик отправляет игру на модерацию
  8. Система назначает модератора для проверки
  9. Модератор проверяет соответствие контента правилам платформы
  10. Модератор проверяет корректность работы игры
  11. При одобрении - система публикует игру в магазине
  12. При отклонении - система уведомляет разработчика о причинах
  13. Система уведомляет пользователей из списка желаемого
- **Выход**: Опубликованная игра в магазине
- **Метрики процесса**:
  - Среднее время модерации
  - % одобренных с первого раза игр
  - Время от создания до публикации

### 2.3 Обновление игры
- **Триггер**: Разработчик инициирует обновление игры
- **Шаги процесса**:
  1. Разработчик создает новую версию игры
  2. Разработчик загружает обновленные файлы
  3. Разработчик заполняет информацию об обновлении (список изменений)
  4. Система проверяет размер и формат обновления
  5. Система создает дифференциальное обновление (патч)
  6. Разработчик отправляет обновление на модерацию
  7. Модератор проверяет обновление на соответствие правилам
  8. При одобрении - система публикует обновление
  9. Система уведомляет пользователей о доступности обновления
  10. Клиентское приложение автоматически загружает обновление
- **Выход**: Опубликованное обновление
- **Метрики процесса**:
  - Среднее время модерации обновления
  - % пользователей, установивших обновление
  - Размер патча относительно полной версии

### 2.4 Финансовые выплаты разработчикам
- **Триггер**: Наступление периода выплат
- **Шаги процесса**:
  1. Система формирует отчет о продажах за период
  2. Система рассчитывает комиссию платформы
  3. Система вычисляет налоговые отчисления
  4. Система формирует сумму к выплате
  5. Финансовый менеджер проверяет и подтверждает выплаты
  6. Система инициирует выплаты на счета разработчиков
  7. Система отслеживает статус платежей
  8. Система уведомляет разработчиков о выплатах
  9. Система обновляет финансовую статистику
  10. Система предоставляет разработчику детальный отчет
- **Выход**: Проведенные выплаты разработчикам
- **Метрики процесса**:
  - % успешных выплат с первой попытки
  - Среднее время проведения выплат
  - Объем выплат разработчикам

### 2.5 Аналитика для разработчиков
- **Триггер**: Разработчик запрашивает аналитические данные
- **Шаги процесса**:
  1. Разработчик выбирает игру и период для анализа
  2. Система агрегирует данные о продажах
  3. Система собирает демографические данные пользователей
  4. Система анализирует статистику использования игры
  5. Система формирует аналитический отчет
  6. Система предоставляет визуализацию данных
  7. Разработчик исследует данные через интерактивные дашборды
  8. Разработчик экспортирует отчеты (при необходимости)
- **Выход**: Аналитический отчет для разработчика
- **Метрики процесса**:
  - Частота использования аналитики
  - Полнота собираемых данных
  - Удовлетворенность разработчиков аналитическими инструментами

## 3. Процессы административного сегмента

### 3.1 Модерация контента
- **Триггер**: Поступление нового контента на модерацию
- **Шаги процесса**:
  1. Система формирует очередь контента на модерацию
  2. Система распределяет задачи между модераторами
  3. Модератор получает уведомление о новой задаче
  4. Модератор проверяет контент на соответствие правилам
  5. Модератор проверяет технические аспекты (работоспособность)
  6. Модератор верифицирует возрастной рейтинг
  7. Модератор принимает решение (одобрить/отклонить/запросить изменения)
  8. Модератор указывает причины отклонения (при необходимости)
  9. Система уведомляет разработчика о решении
  10. Система обновляет статус контента
- **Выход**: Промодерированный контент
- **Метрики процесса**:
  - Среднее время модерации
  - % контента, требующего повторной модерации
  - Равномерность распределения нагрузки между модераторами

### 3.2 Обработка жалоб на контент
- **Триггер**: Пользователь отправляет жалобу на контент
- **Шаги процесса**:
  1. Пользователь отправляет жалобу через интерфейс
  2. Система классифицирует жалобу по категории
  3. Система оценивает приоритет жалобы
  4. Система назначает жалобу соответствующему модератору
  5. Модератор рассматривает жалобу
  6. Модератор проверяет указанный контент
  7. Модератор принимает решение (отклонить жалобу/принять меры)
  8. При обоснованности жалобы - модератор применяет соответствующие меры
  9. Система уведомляет заявителя о решении
  10. Система уведомляет владельца контента о принятых мерах
  11. Система обновляет статистику жалоб
- **Выход**: Обработанная жалоба
- **Метрики процесса**:
  - Среднее время обработки жалобы
  - % обоснованных жалоб
  - Распределение жалоб по категориям

### 3.3 Разрешение спорных ситуаций с платежами
- **Триггер**: Возникновение спорной ситуации с платежом
- **Шаги процесса**:
  1. Пользователь или система инициирует запрос на разрешение спора
  2. Система собирает всю информацию о транзакции
  3. Система классифицирует спорную ситуацию
  4. Финансовый специалист анализирует информацию
  5. Финансовый специалист связывается с платежной системой (при необходимости)
  6. Финансовый специалист принимает решение
  7. При решении в пользу пользователя - инициируется возврат
  8. При отклонении - система предоставляет объяснение
  9. Система уведомляет пользователя о решении
  10. Система обновляет финансовые данные
  11. Система фиксирует результат для аналитики
- **Выход**: Разрешенная спорная ситуация
- **Метрики процесса**:
  - Среднее время разрешения спора
  - % споров, решенных в пользу пользователя
  - Распределение споров по типам

### 3.4 Мониторинг и обеспечение производительности
- **Триггер**: Регулярный мониторинг или алерт о проблеме
- **Шаги процесса**:
  1. Система непрерывно собирает метрики производительности
  2. Система сравнивает текущие показатели с базовыми
  3. При отклонении - система генерирует алерт
  4. Дежурный инженер получает уведомление
  5. Инженер анализирует проблему
  6. Инженер локализует источник проблемы
  7. Инженер применяет корректирующие меры
  8. Система верифицирует эффективность мер
  9. Инженер документирует инцидент и решение
  10. Команда проводит анализ первопричин (при необходимости)
  11. Система обновляет базовые показатели
- **Выход**: Стабильно работающая система
- **Метрики процесса**:
  - Среднее время реакции на инцидент
  - Среднее время восстановления
  - % автоматически разрешенных инцидентов

### 3.5 Управление маркетинговыми акциями
- **Триггер**: Инициирование новой маркетинговой акции
- **Шаги процесса**:
  1. Маркетолог создает концепцию акции
  2. Маркетолог определяет условия и сроки проведения
  3. Маркетолог выбирает целевую аудиторию
  4. Система проверяет техническую возможность реализации
  5. Маркетолог согласовывает акцию с разработчиками игр
  6. Технический специалист настраивает акцию в системе
  7. Система тестирует акцию в тестовом окружении
  8. Маркетолог подготавливает креативные материалы
  9. Система активирует акцию по расписанию
  10. Система отслеживает эффективность акции
  11. Система уведомляет целевую аудиторию
  12. Система завершает акцию по расписанию
  13. Маркетолог анализирует результаты акции
- **Выход**: Проведенная маркетинговая акция
- **Метрики процесса**:
  - Конверсия акции
  - ROI маркетинговой акции
  - Прирост новых пользователей

## 4. Технические процессы

### 4.1 Обновление клиентского приложения
- **Триггер**: Выпуск новой версии клиентского приложения
- **Шаги процесса**:
  1. Система определяет пользователей для обновления
  2. Система уведомляет пользователей о доступном обновлении
  3. Пользователь подтверждает установку или система устанавливает автоматически
  4. Система загружает файлы обновления
  5. Система проверяет целостность загруженных файлов
  6. Система останавливает работу клиента (при необходимости)
  7. Система устанавливает обновление
  8. Система проверяет успешность установки
  9. При успехе - система запускает обновленное приложение
  10. При неудаче - система выполняет откат к предыдущей версии
  11. Система отправляет статистику обновления
- **Выход**: Обновленное клиентское приложение
- **Метрики процесса**:
  - % успешных обновлений
  - Среднее время обновления
  - % откатов к предыдущей версии

### 4.2 Резервное копирование и восстановление
- **Триггер**: Регулярное расписание или ручная инициация
- **Шаги процесса**:
  1. Система определяет данные для резервного копирования
  2. Система создает снапшоты баз данных
  3. Система архивирует файлы
  4. Система проверяет целостность резервных копий
  5. Система шифрует резервные копии
  6. Система передает копии в хранилище
  7. Система верифицирует передачу
  8. Система удаляет устаревшие резервные копии
  9. Система обновляет каталог резервных копий
  10. Система отправляет отчет о резервном копировании
- **Выход**: Актуальная резервная копия данных
- **Метрики процесса**:
  - % успешных резервных копирований
  - Среднее время восстановления
  - Объем резервных копий

### 4.3 Развертывание обновлений платформы
- **Триггер**: Запланированный релиз новой версии
- **Шаги процесса**:
  1. Система создает план развертывания
  2. DevOps инженер подготавливает изменения
  3. Система выполняет автоматические тесты
  4. QA инженер выполняет проверку в тестовом окружении
  5. DevOps инженер развертывает изменения в staging-окружении
  6. Система выполняет тесты в staging-окружении
  7. DevOps инженер подтверждает готовность к продакшн
  8. Система выполняет поэтапное развертывание в продакшн
  9. Система мониторит метрики производительности
  10. При обнаружении проблем - автоматический откат
  11. Система верифицирует успешность развертывания
  12. Система обновляет документацию версий
- **Выход**: Обновленная версия платформы
- **Метрики процесса**:
  - % успешных развертываний
  - Среднее время развертывания
  - % откатов

### 4.4 Обработка нагрузки в пиковые периоды
- **Триггер**: Прогнозируемый или наблюдаемый скачок нагрузки
- **Шаги процесса**:
  1. Система определяет текущую нагрузку на компоненты
  2. Система сравнивает с пороговыми значениями
  3. Система прогнозирует рост нагрузки
  4. Система инициирует горизонтальное масштабирование
  5. Система распределяет нагрузку между экземплярами
  6. Система активирует дополнительные ресурсы кэширования
  7. Система мониторит эффективность масштабирования
  8. При нормализации нагрузки - система освобождает ресурсы
  9. Система документирует параметры нагрузки для анализа
- **Выход**: Стабильная работа системы под нагрузкой
- **Метрики процесса**:
  - Время реакции на скачок нагрузки
  - Эффективность масштабирования
  - Стоимость обработки пиковой нагрузки

## 5. Бизнес-процессы интеграции

### 5.1 Интеграция новой платежной системы
- **Триггер**: Принятие решения о поддержке новой платежной системы
- **Шаги процесса**:
  1. Бизнес-аналитик формирует требования к интеграции
  2. Технический специалист оценивает сложность интеграции
  3. Юрист проверяет соответствие требованиям законодательства
  4. Разработчик реализует интеграцию в тестовой среде
  5. Тестировщик проверяет все сценарии работы
  6. Финансовый специалист верифицирует корректность расчетов
  7. Технический писатель обновляет документацию
  8. DevOps инженер развертывает интеграцию в продакшн
  9. Маркетолог информирует пользователей о новой опции
  10. Система мониторит стабильность работы
- **Выход**: Функционирующая интеграция с новой платежной системой
- **Метрики процесса**:
  - Время от принятия решения до запуска
  - % транзакций через новую платежную систему
  - Конверсия платежей с использованием новой системы

### 5.2 Партнерская программа с разработчиками
- **Триггер**: Запуск программы или привлечение нового партнера
- **Шаги процесса**:
  1. Менеджер по работе с партнерами определяет условия сотрудничества
  2. Юрист подготавливает партнерское соглашение
  3. Разработчик создает техническую возможность интеграции
  4. Партнер подписывает соглашение
  5. Технический специалист настраивает интеграцию
  6. Тестировщик проверяет работоспособность
  7. Менеджер по работе с партнерами активирует партнерство
  8. Система настраивает отслеживание активности партнера
  9. Маркетолог запускает совместную кампанию
  10. Система формирует отчеты по результатам партнерства
  11. Финансовый специалист обрабатывает выплаты партнеру
- **Выход**: Функционирующее партнерство
- **Метрики процесса**:
  - Количество привлеченных пользователей
  - Конверсия партнерского трафика
  - ROI партнерской программы

### 5.3 Добавление нового контента по запросу пользователей
- **Триггер**: Массовые запросы на добавление определенной игры/контента
- **Шаги процесса**:
  1. Система агрегирует запросы от пользователей
  2. Аналитик оценивает потенциальный спрос
  3. Менеджер по работе с разработчиками связывается с правообладателем
  4. Менеджер проводит переговоры об условиях размещения
  5. Юрист оформляет соглашение
  6. Технический специалист проверяет техническую совместимость
  7. Правообладатель предоставляет контент
  8. Система верифицирует соответствие контента требованиям
  9. Маркетолог готовит анонс
  10. Система публикует контент
  11. Система уведомляет заинтересованных пользователей
- **Выход**: Новый контент на платформе
- **Метрики процесса**:
  - Время от запросов до публикации
  - Количество покупок в первую неделю
  - Соотношение запросов и фактических покупок

# Пользовательские сценарии

## 1. Сценарии для игроков

### 1.1 Регистрация и установка клиента
**Пользователь**: Новый пользователь, желающий начать использовать платформу.

**Сценарий**:
1. Пользователь заходит на веб-сайт платформы
2. Нажимает кнопку "Регистрация"
3. Заполняет форму регистрации, указывая email, телефон и пароль
4. Получает и вводит код подтверждения
5. Выбирает имя пользователя и настраивает профиль
6. Скачивает клиентское приложение
7. Устанавливает клиент на компьютер
8. Авторизуется в клиенте с созданными учетными данными
9. Проходит краткое обучение по интерфейсу
10. Знакомится с предложенными играми

**Ожидаемый результат**: Пользователь зарегистрирован, клиент установлен, пользователь ознакомлен с основным функционалом.

### 1.2 Поиск и покупка игры
**Пользователь**: Зарегистрированный пользователь, ищущий новую игру.

**Сценарий**:
1. Пользователь открывает клиент или веб-интерфейс магазина
2. Использует поиск или категории для нахождения игры
3. Просматривает страницу игры (скриншоты, описание, системные требования)
4. Читает отзывы других пользователей
5. Проверяет системные требования и сравнивает с характеристиками своего ПК
6. Добавляет игру в корзину
7. Переходит к оформлению заказа
8. Выбирает способ оплаты (банковская карта, электронный кошелек, СБП)
9. Подтверждает покупку
10. Получает подтверждение о покупке и электронный чек
11. Игра добавляется в библиотеку пользователя

**Ожидаемый результат**: Пользователь успешно приобрел игру, игра доступна в библиотеке.

### 1.3 Загрузка и установка игры
**Пользователь**: Пользователь, который приобрел игру и хочет начать играть.

**Сценарий**:
1. Пользователь открывает свою библиотеку в клиенте
2. Находит приобретенную игру
3. Нажимает кнопку "Установить"
4. Выбирает папку для установки игры
5. Подтверждает начало загрузки
6. Отслеживает прогресс загрузки и установки
7. После завершения установки нажимает "Играть"
8. Игра запускается через клиент
9. Клиент начинает отслеживать время игры

**Ожидаемый результат**: Игра успешно загружена, установлена и запущена.

### 1.4 Обновление игры
**Пользователь**: Пользователь, у которого есть установленная игра с доступным обновлением.

**Сценарий**:
1. Пользователь получает уведомление о доступном обновлении
2. Открывает библиотеку в клиенте
3. Видит отметку о доступном обновлении у игры
4. Нажимает кнопку "Обновить"
5. Клиент загружает и устанавливает обновление
6. Пользователь просматривает список изменений
7. После установки обновления запускает игру

**Ожидаемый результат**: Игра успешно обновлена до актуальной версии.

### 1.5 Общение с другими игроками
**Пользователь**: Пользователь, желающий найти друзей на платформе.

**Сценарий**:
1. Пользователь открывает раздел "Сообщество" в клиенте
2. Ищет других игроков по имени пользователя или через список игроков в конкретной игре
3. Отправляет запрос в друзья интересующему пользователю
4. После принятия запроса видит пользователя в списке друзей
5. Отправляет личное сообщение
6. Предлагает совместную игру через функцию приглашения
7. Просматривает активность друга в его профиле

**Ожидаемый результат**: Пользователь установил социальные связи на платформе.

### 1.6 Возврат игры
**Пользователь**: Пользователь, недовольный приобретенной игрой.

**Сценарий**:
1. Пользователь открывает историю покупок в личном кабинете
2. Находит нужную игру
3. Выбирает опцию "Запросить возврат"
4. Выбирает причину возврата из списка
5. Дает дополнительные пояснения (опционально)
6. Отправляет запрос
7. Получает подтверждение о начале обработки запроса
8. Получает уведомление о решении (автоматическое одобрение или отказ)
9. При одобрении средства возвращаются на счет пользователя
10. Игра удаляется из библиотеки

**Ожидаемый результат**: Запрос на возврат обработан, пользователь получил решение.

### 1.7 Написание отзыва на игру
**Пользователь**: Пользователь, поигравший в игру и желающий поделиться мнением.

**Сценарий**:
1. Пользователь открывает страницу игры в магазине
2. Переходит в раздел отзывов
3. Нажимает "Написать отзыв"
4. Выставляет оценку (рекомендую/не рекомендую)
5. Пишет текстовый отзыв
6. Прикрепляет скриншоты (опционально)
7. Отправляет отзыв
8. Отзыв проходит автоматическую модерацию
9. При одобрении отзыв публикуется на странице игры
10. Пользователь получает уведомление о публикации

**Ожидаемый результат**: Отзыв опубликован и доступен другим пользователям.

### 1.8 Получение технической поддержки
**Пользователь**: Пользователь, столкнувшийся с технической проблемой.

**Сценарий**:
1. Пользователь открывает раздел "Поддержка" в клиенте или на сайте
2. Выбирает категорию проблемы
3. Система предлагает подходящие статьи из базы знаний
4. Если проблема не решена, пользователь нажимает "Создать обращение"
5. Описывает проблему, прикладывает скриншоты или логи
6. Отправляет обращение
7. Получает номер обращения и расчетное время ответа
8. Получает уведомление о ответе специалиста
9. Взаимодействует со специалистом до решения проблемы
10. Оценивает качество поддержки после закрытия обращения

**Ожидаемый результат**: Проблема пользователя решена, обращение закрыто.

### 1.9 Добавление средств на кошелек платформы
**Пользователь**: Пользователь, желающий пополнить внутренний счет.

**Сценарий**:
1. Пользователь открывает раздел "Кошелек" в личном кабинете
2. Нажимает "Пополнить"
3. Выбирает сумму пополнения
4. Выбирает способ оплаты
5. Вводит необходимые платежные данные
6. Подтверждает операцию
7. Переходит на страницу платежной системы (при необходимости)
8. Подтверждает платеж в своем банке/платежной системе
9. Получает уведомление об успешном пополнении
10. Видит обновленный баланс в кошельке

**Ожидаемый результат**: Счет пополнен, средства доступны для покупок.

### 1.10 Добавление игры в список желаемого
**Пользователь**: Пользователь, заинтересованный в игре, но не готовый к покупке.

**Сценарий**:
1. Пользователь просматривает страницу игры
2. Нажимает кнопку "Добавить в список желаемого"
3. Игра добавляется в список
4. Пользователь проверяет список желаемого в личном кабинете
5. Настраивает уведомления о скидках на эту игру
6. Позже получает уведомление о скидке
7. Переходит из уведомления на страницу игры
8. Совершает покупку со скидкой

**Ожидаемый результат**: Пользователь отслеживает интересующую игру и покупает ее при хорошей цене.

## 2. Сценарии для разработчиков/издателей

### 2.1 Регистрация разработчика
**Пользователь**: Представитель студии разработки игр.

**Сценарий**:
1. Разработчик открывает страницу регистрации для разработчиков
2. Заполняет форму с данными компании и контактными данными
3. Загружает документы для верификации (свидетельство о регистрации, ИНН)
4. Принимает условия сотрудничества
5. Отправляет заявку
6. Получает уведомление о начале рассмотрения заявки
7. Получает запрос дополнительных документов (при необходимости)
8. Дополняет заявку запрошенными документами
9. Получает уведомление об одобрении регистрации
10. Получает доступ к панели разработчика

**Ожидаемый результат**: Разработчик зарегистрирован и верифицирован, имеет доступ к панели.

### 2.2 Загрузка и публикация игры
**Пользователь**: Верифицированный разработчик с готовой игрой.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Создает новую страницу игры, нажав "Добавить игру"
3. Заполняет основную информацию (название, жанр, возрастной рейтинг)
4. Загружает медиа-материалы (скриншоты, трейлер, обложку)
5. Добавляет подробное описание и системные требования
6. Устанавливает цену и настраивает скидки
7. Загружает файлы игры через загрузчик
8. Проверяет корректность всех данных
9. Отправляет игру на модерацию
10. Получает уведомления о статусе модерации
11. При необходимости вносит исправления по замечаниям модераторов
12. Получает уведомление об одобрении и публикации
13. Устанавливает дату релиза

**Ожидаемый результат**: Игра опубликована в магазине и доступна для покупки.

### 2.3 Анализ продаж и статистики
**Пользователь**: Разработчик, чья игра опубликована на платформе.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Переходит в раздел "Аналитика"
3. Выбирает игру и период для анализа
4. Просматривает графики продаж и конверсии
5. Анализирует демографические данные покупателей
6. Изучает ключевые метрики (ARPU, retention)
7. Экспортирует данные для внутреннего анализа
8. Сравнивает результаты с предыдущими периодами
9. Принимает решения на основе аналитики

**Ожидаемый результат**: Разработчик получил аналитические данные для принятия решений.

### 2.4 Обновление опубликованной игры
**Пользователь**: Разработчик, желающий выпустить обновление.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Выбирает игру в списке
3. Переходит в раздел "Управление версиями"
4. Создает новую версию игры
5. Загружает файлы обновления
6. Заполняет список изменений
7. Указывает тип обновления (патч, мажорное обновление)
8. Отправляет обновление на модерацию
9. Получает уведомление об одобрении
10. Публикует обновление
11. Отслеживает процесс обновления у пользователей

**Ожидаемый результат**: Обновление опубликовано и доступно пользователям.

### 2.5 Ответ на отзывы пользователей
**Пользователь**: Разработчик, взаимодействующий с сообществом.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Переходит в раздел "Отзывы"
3. Видит список всех отзывов на свои игры
4. Фильтрует отзывы по оценке/дате
5. Выбирает отзыв для ответа
6. Пишет ответ от имени разработчика
7. Отправляет ответ
8. Ответ публикуется под отзывом пользователя
9. Пользователь получает уведомление об ответе

**Ожидаемый результат**: Разработчик поддерживает коммуникацию с пользователями.

### 2.6 Настройка скидок и акций
**Пользователь**: Разработчик/издатель, планирующий маркетинговую акцию.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Переходит в раздел "Маркетинг и скидки"
3. Выбирает игру для скидки
4. Устанавливает процент скидки
5. Указывает период действия скидки
6. Настраивает отображение баннера акции
7. Отправляет настройки на проверку
8. Получает подтверждение от платформы
9. Скидка активируется в запланированное время
10. Разработчик отслеживает влияние скидки на продажи

**Ожидаемый результат**: Скидка настроена и активирована, увеличение продаж игры.

### 2.7 Получение финансовых отчетов
**Пользователь**: Финансовый представитель компании-разработчика.

**Сценарий**:
1. Представитель входит в панель разработчика
2. Переходит в раздел "Финансы"
3. Выбирает период для отчета
4. Указывает формат отчета
5. Формирует отчет
6. Просматривает детализацию по продажам
7. Видит размер комиссии платформы
8. Экспортирует отчет в нужном формате
9. Использует данные для внутреннего учета

**Ожидаемый результат**: Получен подробный финансовый отчет за период.

### 2.8 Добавление DLC для игры
**Пользователь**: Разработчик, создавший дополнительный контент для своей игры.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Выбирает игру в списке
3. Переходит в раздел "Дополнения и DLC"
4. Создает новое DLC
5. Заполняет информацию о DLC (название, описание)
6. Загружает медиа-материалы
7. Устанавливает цену
8. Загружает файлы DLC
9. Настраивает зависимости от основной игры
10. Отправляет DLC на модерацию
11. Получает уведомление о публикации

**Ожидаемый результат**: DLC опубликовано и доступно для покупки.

### 2.9 Управление правами команды разработчиков
**Пользователь**: Руководитель команды разработчиков.

**Сценарий**:
1. Руководитель входит в панель разработчика
2. Переходит в раздел "Управление командой"
3. Просматривает список текущих участников
4. Нажимает "Добавить участника"
5. Указывает email нового участника
6. Выбирает роль и уровень доступа
7. Отправляет приглашение
8. Новый участник получает email с приглашением
9. После принятия приглашения пользователь появляется в команде
10. Руководитель может изменять права или удалять участников

**Ожидаемый результат**: Команда разработчиков настроена с корректными правами доступа.

### 2.10 Техническая поддержка разработчика
**Пользователь**: Разработчик, столкнувшийся с проблемой на платформе.

**Сценарий**:
1. Разработчик входит в панель разработчика
2. Переходит в раздел "Поддержка"
3. Создает новый запрос
4. Выбирает категорию проблемы
5. Описывает проблему, прикладывает скриншоты
6. Отправляет запрос
7. Получает подтверждение с номером запроса
8. Получает ответ от специалиста поддержки разработчиков
9. Взаимодействует со специалистом до решения проблемы
10. Оценивает качество поддержки

**Ожидаемый результат**: Проблема разработчика решена.

## 3. Сценарии для администраторов платформы

### 3.1 Модерация новой игры
**Пользователь**: Модератор контента платформы.

**Сценарий**:
1. Модератор входит в административную панель
2. Видит уведомление о новой игре на модерации
3. Открывает заявку
4. Проверяет корректность заполнения информации
5. Просматривает скриншоты и трейлер
6. Проверяет соответствие контента указанному возрастному рейтингу
7. Скачивает и тестирует игру на базовую функциональность
8. Проверяет на соответствие техническим требованиям платформы
9. При наличии проблем отправляет разработчику замечания
10. При отсутствии проблем одобряет публикацию
11. Заполняет отчет о модерации

**Ожидаемый результат**: Игра проверена и либо опубликована, либо возвращена на доработку.

### 3.2 Обработка жалобы на контент
**Пользователь**: Модератор сообщества.

**Сценарий**:
1. Модератор получает уведомление о новой жалобе
2. Открывает детали жалобы
3. Видит тип жалобы и объект (отзыв, игра, профиль)
4. Просматривает сам объект жалобы
5. Оценивает обоснованность жалобы
6. При необходимости проверяет историю пользователя
7. Принимает решение (отклонить жалобу или принять меры)
8. В случае нарушения правил применяет соответствующие меры
9. Уведомляет заявителя о принятом решении
10. Закрывает жалобу с указанием результата рассмотрения

**Ожидаемый результат**: Жалоба обработана, приняты необходимые меры.

### 3.3 Управление промо-акцией
**Пользователь**: Маркетолог платформы.

**Сценарий**:
1. Маркетолог входит в административную панель
2. Переходит в раздел "Маркетинговые кампании"
3. Создает новую акцию
4. Указывает название и описание акции
5. Настраивает баннеры для акции
6. Выбирает игры для участия в акции
7. Согласовывает условия с разработчиками
8. Устанавливает сроки проведения
9. Настраивает таргетинг аудитории
10. Настраивает уведомления пользователей
11. Запускает акцию или устанавливает отложенный запуск
12. Отслеживает результаты акции

**Ожидаемый результат**: Акция настроена и запущена, охват целевой аудитории.

### 3.4 Обработка проблемного платежа
**Пользователь**: Специалист финансового отдела.

**Сценарий**:
1. Специалист получает уведомление о проблемном платеже
2. Открывает детали транзакции
3. Проверяет историю платежей пользователя
4. Связывается с платежной системой для уточнения статуса
5. Анализирует причину проблемы
6. Предпринимает действия по устранению проблемы
7. При необходимости связывается с пользователем
8. Завершает транзакцию или инициирует возврат
9. Документирует инцидент
10. Обновляет статус платежа в системе

**Ожидаемый результат**: Проблема с платежом решена, пользователь удовлетворен.

### 3.5 Мониторинг производительности системы
**Пользователь**: Системный администратор платформы.

**Сценарий**:
1. Администратор открывает панель мониторинга
2. Проверяет основные метрики производительности
3. Обнаруживает отклонение от нормы в одном из компонентов
4. Детально анализирует проблемный компонент
5. Определяет причину проблемы
6. Принимает решение о методе устранения
7. Применяет корректирующие меры
8. Мониторит эффект от внесенных изменений
9. Документирует инцидент и принятые меры
10. Настраивает оповещения для предотвращения повторения

**Ожидаемый результат**: Проблема производительности обнаружена и устранена.

### 3.6 Запуск обновления платформы
**Пользователь**: DevOps инженер.

**Сценарий**:
1. Инженер получает подтверждение о готовности новой версии
2. Проверяет результаты тестирования в тестовой среде
3. Создает план развертывания
4. Уведомляет команду о предстоящем обновлении
5. Создает резервные копии системы
6. Публикует анонс о техническом обслуживании для пользователей
7. В запланированное время начинает развертывание
8. Поэтапно обновляет компоненты системы
9. Мониторит процесс обновления и метрики системы
10. При обнаружении проблем выполняет откат или исправление
11. После успешного обновления информирует команду
12. Обновляет документацию

**Ожидаемый результат**: Система успешно обновлена без критических сбоев.

### 3.7 Обработка запроса на верификацию разработчика
**Пользователь**: Специалист по работе с разработчиками.

**Сценарий**:
1. Специалист получает уведомление о новой заявке
2. Открывает детали заявки от разработчика
3. Проверяет предоставленные документы
4. Проверяет историю компании
5. Верифицирует контактные данные
6. При необходимости запрашивает дополнительные документы
7. Принимает решение о верификации
8. В случае одобрения активирует аккаунт разработчика
9. Отправляет уведомление разработчику
10. Документирует процесс верификации

**Ожидаемый результат**: Разработчик проверен и получил соответствующий статус.

### 3.8 Создание технической документации
**Пользователь**: Технический писатель.

**Сценарий**:
1. Писатель получает задание на создание документации
2. Изучает функциональность, для которой требуется документация
3. Создает структуру документа
4. Пишет черновик документации
5. Согласовывает черновик с техническими специалистами
6. Вносит корректировки по комментариям
7. Подготавливает финальную версию
8. Согласовывает с руководителем
9. Публикует документацию в базе знаний
10. Обновляет индекс поиска

**Ожидаемый результат**: Новая документация доступна пользователям и разработчикам.

### 3.9 Анализ пользовательской активности
**Пользователь**: Аналитик данных.

**Сценарий**:
1. Аналитик входит в систему аналитики
2. Определяет период и метрики для анализа
3. Формирует запросы к базе данных
4. Получает и визуализирует данные
5. Анализирует тренды и аномалии
6. Формирует гипотезы о причинах изменений
7. Проводит дополнительный анализ для проверки гипотез
8. Готовит аналитический отчет
9. Представляет выводы и рекомендации команде
10. Настраивает регулярный мониторинг ключевых метрик

**Ожидаемый результат**: Получены инсайты о пользовательской активности, предложены меры по улучшению.

### 3.10 Управление баннерами и промо-материалами
**Пользователь**: Контент-менеджер.

**Сценарий**:
1. Менеджер входит в административную панель
2. Переходит в раздел "Управление контентом"
3. Выбирает расположение нового баннера
4. Загружает изображение для баннера
5. Устанавливает ссылку и целевую страницу
6. Настраивает период отображения
7. Настраивает таргетинг аудитории
8. Предпросматривает баннер в разных размерах
9. Публикует баннер или планирует публикацию
10. Отслеживает эффективность (клики, конверсии)

**Ожидаемый результат**: Новый промо-материал опубликован и привлекает целевую аудиторию.

# Дорожная карта MVP (детальный план)

## Фаза 1: Подготовка и планирование (1-2 месяца)

### Неделя 1-2: Формирование команды и инфраструктуры
- **Кадровые решения**:
  - Найм ключевых специалистов (архитектор, тимлид бэкенда, тимлид фронтенда, DevOps инженер)
  - Формирование основных команд разработки
  - Определение ролей и ответственных за направления
- **Инфраструктурные решения**:
  - Выбор облачного провайдера или дата-центра для размещения
  - Настройка базовой инфраструктуры для разработки
  - Создание репозиториев и настройка систем CI/CD
  - Настройка тестовых окружений
- **Организационные вопросы**:
  - Настройка процессов разработки и коммуникации
  - Определение методологии разработки
  - Настройка трекера задач и документации

### Неделя 3-4: Детализация архитектуры и начало разработки
- **Проектирование**:
  - Финализация архитектуры системы
  - Детализация API и интерфейсов взаимодействия
  - Создание базовых прототипов интерфейсов
- **Запуск разработки**:
  - Настройка базы данных и миграций
  - Создание базовой структуры проекта
  - Разработка прототипа клиентского приложения
  - Настройка аутентификации и базовой безопасности

### Неделя 5-6: Административная часть и документация
- **Юридические вопросы**:
  - Подготовка пользовательского соглашения
  - Подготовка соглашения для разработчиков
  - Политика конфиденциальности и обработки данных
- **Интеграции**:
  - Начало интеграции с платежными системами
  - Настройка систем мониторинга
- **Документация**:
  - Создание технической документации
  - Документирование API
  - Определение форматов и протоколов обмена данными

### Неделя 7-8: Завершение подготовительного этапа
- **Инфраструктура**:
  - Настройка окружений для различных этапов разработки
  - Настройка системы резервного копирования
  - Настройка системы логирования
- **Безопасность**:
  - Аудит безопасности инфраструктуры
  - Настройка базовых механизмов защиты
- **Планирование**:
  - Детальное планирование следующих фаз
  - Распределение задач между командами
  - Настройка процессов контроля качества

## Фаза 2: Разработка базового функционала (2-3 месяца)

### Неделя 9-10: Разработка ядра системы
- **Бэкенд**:
  - Реализация базового API для регистрации и аутентификации
  - Разработка микросервисов каталога игр
  - Реализация системы управления пользователями
- **Фронтенд**:
  - Разработка базовых компонентов интерфейса
  - Создание страниц входа и регистрации
  - Прототип личного кабинета пользователя
- **Клиентское приложение**:
  - Базовая структура клиента
  - Механизм авторизации в клиенте
  - Прототип интерфейса библиотеки игр

### Неделя 11-12: Каталог игр и панель разработчика
- **Каталог игр**:
  - Реализация поиска и фильтрации
  - Страница детальной информации об игре
  - Система категорий и тегов
- **Панель разработчика**:
  - Базовый функционал управления играми
  - Система загрузки и управления файлами
  - Формы создания и редактирования игр
- **Интеграция контента**:
  - Система хранения и доставки игровых файлов
  - Механизм проверки целостности файлов
  - Базовая система версионирования

### Неделя 13-14: Система платежей и библиотека
- **Платежи**:
  - Интеграция с платежными шлюзами (МИР, СБП, ЮMoney)
  - Реализация корзины покупок
  - Механизм применения скидок
  - Система чеков и фискализации
- **Библиотека игр**:
  - Реализация библиотеки пользователя
  - Механизм отображения приобретенных игр
  - Базовый функционал управления библиотекой

### Неделя 15-16: Загрузка и установка игр
- **Клиентское приложение**:
  - Система загрузки и установки игр
  - Механизм контроля версий игр
  - Обновление установленных игр
- **Бэкенд**:
  - API для управления загрузками
  - Система учета установленных игр
  - Механизм доставки обновлений

### Неделя 17-18: Административная панель и модерация
- **Панель администратора**:
  - Базовый интерфейс администратора
  - Система управления пользователями
  - Механизм модерации контента
- **Модерация**:
  - Процесс модерации новых игр
  - Система обработки жалоб
  - Инструменты управления контентом

### Неделя 19-20: Интеграция и стабилизация
- **Интеграция компонентов**:
  - Связывание всех компонентов системы
  - Обеспечение бесшовной работы между модулями
  - Интеграционное тестирование
- **Стабилизация**:
  - Оптимизация производительности
  - Исправление выявленных ошибок
  - Подготовка к первому внутреннему релизу

## Фаза 3: Доработка и тестирование (1-2 месяца)

### Неделя 21-22: Базовые социальные функции
- **Профили пользователей**:
  - Настраиваемые профили
  - Система друзей
  - Статусы и активность
- **Коммуникация**:
  - Базовая система сообщений
  - Механизм комментирования
  - Система уведомлений

### Неделя 23-24: Отзывы и оценки
- **Система отзывов**:
  - Механизм написания отзывов
  - Оценка игр (рекомендую/не рекомендую)
  - Модерация отзывов
- **Аналитика для разработчиков**:
  - Базовая статистика продаж
  - Анализ активности пользователей
  - Отчеты по отзывам

### Неделя 25-26: Финансовые операции
- **Финансы разработчиков**:
  - Система выплат разработчикам
  - Финансовая отчетность
  - Управление налоговой информацией
- **Пользовательские финансы**:
  - Система возвратов средств
  - История транзакций
  - Управление платежными методами

### Неделя 27-28: Альфа-тестирование
- **Внутреннее тестирование**:
  - Функциональное тестирование всех компонентов
  - Проверка интеграции всех систем
  - Тестирование производительности
- **Исправление ошибок**:
  - Фиксация выявленных проблем
  - Приоритизация исправлений
  - Стабилизация платформы

### Неделя 29-30: Подготовка к закрытому бета-тестированию
- **Оптимизация**:
  - Оптимизация производительности системы
  - Оптимизация клиентского приложения
  - Улучшение пользовательского опыта
- **Документация**:
  - Подготовка пользовательской документации
  - Руководства для разработчиков
  - Инструкции по установке и использованию
- **Подготовка инфраструктуры**:
  - Масштабирование для бета-тестирования
  - Настройка системы сбора отзывов
  - Подготовка механизмов мониторинга

## Фаза 4: Бета-тестирование и запуск (1-2 месяца)

### Неделя 31-32: Закрытое бета-тестирование
- **Приглашение первых пользователей**:
  - Отбор участников тестирования
  - Предоставление доступа ограниченному кругу пользователей
  - Сбор первичной обратной связи
- **Мониторинг и анализ**:
  - Отслеживание активности пользователей
  - Анализ возникающих проблем
  - Мониторинг производительности системы
- **Исправления**:
  - Оперативное устранение критических проблем
  - Улучшение на основе обратной связи
  - Подготовка обновлений

### Неделя 33-34: Расширенное бета-тестирование
- **Увеличение числа тестировщиков**:
  - Расширение доступа для большего числа пользователей
  - Привлечение разработчиков для тестирования панели разработчика
  - Тестирование с различными типами контента
- **Функциональность**:
  - Проверка всех пользовательских сценариев
  - Тестирование экстремальных случаев
  - Проверка работы под нагрузкой
- **Оптимизация**:
  - Дальнейшая оптимизация на основе реальных данных
  - Настройка кэширования
  - Оптимизация запросов к базе данных

### Неделя 35-36: Подготовка к публичному запуску
- **Финальные улучшения**:
  - Устранение всех критических и высокоприоритетных проблем
  - Последние улучшения интерфейса
  - Окончательная оптимизация производительности
- **Масштабирование инфраструктуры**:
  - Подготовка к публичному запуску
  - Настройка автоматического масштабирования
  - Проверка отказоустойчивости системы
- **Маркетинговые материалы**:
  - Подготовка пресс-релизов
  - Создание промо-материалов
  - Настройка стартовой страницы платформы

### Неделя 37-38: Публичный запуск MVP
- **Мягкий запуск**:
  - Поэтапное открытие регистрации
  - Контролируемое увеличение нагрузки
  - Мониторинг всех систем в режиме реального времени
- **Активация маркетинга**:
  - Запуск маркетинговой кампании
  - Взаимодействие с прессой
  - Активация социальных медиа
- **Поддержка пользователей**:
  - Оперативная техническая поддержка
  - Сбор и анализ обратной связи
  - Быстрое реагирование на проблемы

### Неделя 39-40: Стабилизация после запуска
- **Мониторинг и оптимизация**:
  - Анализ использования платформы
  - Выявление узких мест и проблем
  - Оптимизация на основе реальных данных
- **Расширение контента**:
  - Привлечение дополнительных разработчиков
  - Увеличение каталога игр
  - Запуск первых промо-акций
- **Планирование развития**:
  - Анализ первых метрик успеха
  - Планирование дальнейшего развития
  - Приоритизация следующих функций для разработки

## Ключевые зависимости и риски

### Критические зависимости
- Интеграция с платежными системами требует согласования и тестирования с партнерами
- Соответствие законодательству о персональных данных требует юридического заключения
- Наличие разработчиков, готовых размещать игры на платформе к моменту запуска

### Ключевые риски
- Задержки в интеграции с внешними системами
- Технические сложности при масштабировании для большого числа пользователей
- Регуляторные риски при запуске финансовых операций
- Недостаточный интерес со стороны разработчиков игр

### Планы смягчения рисков
- Параллельная работа над интеграциями начиная с ранних этапов
- Тестирование производительности на всех этапах разработки
- Консультации с юристами на всех этапах проекта
- Раннее привлечение разработчиков через программу партнерства

## Ресурсное планирование

### Команды разработки
- **Команда бэкенда**: 6-8 разработчиков
- **Команда фронтенда**: 4-6 разработчиков
- **Команда клиентского приложения**: 4-5 разработчиков
- **DevOps команда**: 3-4 инженера
- **QA команда**: 4-6 тестировщиков
- **Дизайн-команда**: 2-3 дизайнера

### Ключевые вехи
1. **Завершение подготовительного этапа** (Неделя 8)
2. **Функционирующий прототип с основными функциями** (Неделя 20)
3. **Начало альфа-тестирования** (Неделя 27)
4. **Начало бета-тестирования** (Неделя 31)
5. **Публичный запуск MVP** (Неделя 37)

### Критерии готовности MVP
- Полноценно функционирующий магазин игр
- Система личных кабинетов для пользователей и разработчиков
- Работающие платежи и корректная фискализация
- Возможность загрузки, установки и запуска игр
- Базовые социальные функции
- Система отзывов и оценок
- Панель администратора с функциями модерации
- Стабильная работа всех систем под нагрузкой

# План миграции разработчиков с других платформ

## 1. Стратегия привлечения разработчиков

### 1.1 Анализ целевой аудитории разработчиков
- **Сегментация разработчиков**:
  - Российские инди-разработчики, потерявшие доступ к глобальным платформам
  - Студии среднего размера из России и стран СНГ
  - Крупные российские издатели и разработчики
  - Зарубежные разработчики, заинтересованные в российском рынке
  - Начинающие разработчики без опыта публикации

- **Ключевые потребности разработчиков**:
  - Надежный канал монетизации
  - Доступ к обширной аудитории
  - Прозрачные условия и стабильные выплаты
  - Инструменты для продвижения игр
  - Техническая поддержка и документация
  - Аналитика и статистика

- **Текущие проблемы разработчиков**:
  - Ограничения в работе с зарубежными платформами
  - Сложности с получением платежей из-за рубежа
  - Трудности с продвижением игр на российском рынке
  - Недостаток локальных инструментов аналитики

### 1.2 Ценностное предложение для разработчиков
- **Финансовые преимущества**:
  - Пониженная комиссия платформы в течение первого года (15% вместо 30%)
  - Гарантированные выплаты в рублях без валютных рисков
  - Интеграция с российскими платежными системами
  - Специальные условия для эксклюзивных игр (дополнительно -5% к комиссии)

- **Маркетинговые преимущества**:
  - Приоритетное размещение для первых разработчиков
  - Бесплатное продвижение в течение первых 3 месяцев
  - Совместные маркетинговые кампании
  - Программа "Игра недели" с усиленным продвижением

- **Технические преимущества**:
  - Простая и быстрая процедура публикации
  - Локализованные инструменты и документация
  - Прямой доступ к команде технической поддержки
  - API для интеграции с собственными системами

- **Стратегические преимущества**:
  - Доступ к аудитории российских игроков
  - Долгосрочное партнерство с национальной платформой
  - Возможность влиять на развитие платформы
  - Безопасность и стабильность в условиях санкционных рисков

### 1.3 Принципы программы миграции
- **Прозрачность и открытость**:
  - Полное раскрытие условий сотрудничества
  - Регулярная коммуникация с разработчиками
  - Открытость к обратной связи и предложениям

- **Поэтапный подход**:
  - Фокус на качестве интеграции, а не на количестве
  - Последовательное расширение функциональности
  - Индивидуальная работа с ключевыми партнерами

- **Взаимовыгодное партнерство**:
  - Создание экосистемы с учетом потребностей разработчиков
  - Совместная разработка новых функций
  - Распределение рисков при запуске новых инициатив

- **Поддержка российских разработчиков**:
  - Приоритет отечественным студиям и разработчикам
  - Программы поддержки для начинающих разработчиков
  - Интеграция с образовательными программами

## 2. Программа миграции разработчиков

### 2.1 Фаза 1: Подготовка инфраструктуры (1-2 месяца)
- **Создание портала для разработчиков**:
  - Разработка панели управления для издателей
  - Подготовка документации и обучающих материалов
  - Создание системы тикетов для поддержки разработчиков

- **Разработка технических инструментов**:
  - Создание SDK для интеграции с платформой
  - Разработка API для управления играми и контентом
  - Инструменты для миграции метаданных с других платформ

- **Подготовка финансовых процессов**:
  - Настройка системы выплат разработчикам
  - Интеграция с налоговыми системами
  - Разработка инструментов финансовой отчетности

- **Формирование команды по работе с разработчиками**:
  - Найм и обучение менеджеров по работе с разработчиками
  - Создание службы технической поддержки для разработчиков
  - Формирование команды модерации контента

### 2.2 Фаза 2: Пилотная программа с ключевыми партнерами (1-2 месяца)
- **Отбор пилотных участников**:
  - Определение критериев выбора первых разработчиков
  - Проведение переговоров с потенциальными партнерами
  - Заключение первых партнерских соглашений

- **Проведение пилотного запуска**:
  - Помощь в миграции игр избранных разработчиков
  - Тестирование всей цепочки процессов в реальных условиях
  - Сбор и анализ обратной связи

- **Доработка процессов и инструментов**:
  - Исправление выявленных проблем
  - Оптимизация процессов публикации
  - Улучшение инструментов на основе обратной связи

- **Подготовка кейсов успеха**:
  - Документирование процесса миграции
  - Сбор отзывов от первых разработчиков
  - Подготовка материалов для маркетинговой кампании

### 2.3 Фаза 3: Программа раннего доступа (2-3 месяца)
- **Расширение круга участников**:
  - Открытие регистрации для ограниченного числа разработчиков
  - Приоритет российским студиям среднего размера
  - Активное привлечение инди-разработчиков

- **Запуск программы поддержки**:
  - Серия вебинаров и мастер-классов по интеграции
  - Персональные консультации для разработчиков
  - Создание сообщества разработчиков платформы

- **Реализация финансовых стимулов**:
  - Запуск программы сниженной комиссии
  - Внедрение бонусов за эксклюзивные релизы
  - Создание фонда поддержки инди-разработчиков

- **Маркетинговая поддержка**:
  - Продвижение первых успешных релизов
  - Публикации историй успеха в профильных медиа
  - Презентация платформы на индустриальных мероприятиях

### 2.4 Фаза 4: Полномасштабный запуск (3-6 месяцев)
- **Открытая регистрация разработчиков**:
  - Снятие ограничений на регистрацию
  - Упрощенный процесс верификации
  - Автоматизация большинства процессов

- **Расширение инструментария**:
  - Запуск полноценной аналитической платформы
  - Инструменты для кросс-промо между играми
  - Система A/B тестирования для страниц игр

- **Программа масштабирования**:
  - Активное привлечение зарубежных разработчиков
  - Локализационная поддержка для иностранных партнеров
  - Расширение географии выплат

- **Развитие сообщества разработчиков**:
  - Запуск форума для обмена опытом
  - Организация оффлайн-мероприятий
  - Программа амбассадоров платформы

## 3. Технический план миграции

### 3.1 Инструменты миграции контента
- **Импорт метаданных**:
  - Утилита для переноса описаний, скриншотов и трейлеров
  - Инструмент для миграции локализаций
  - Система проверки качества перенесенных материалов

- **Перенос файлов игр**:
  - Инструмент массовой загрузки игровых файлов
  - Система верификации целостности файлов
  - Конвертеры форматов для обеспечения совместимости

- **Миграция DLC и дополнительного контента**:
  - Инструменты для структурирования DLC
  - Система для переноса бандлов и комплектов
  - Перенос систем достижений и трофеев

- **Сохранение статистики и отзывов**:
  - Инструменты для импорта аналитических данных
  - Опция для переноса пользовательских отзывов (при согласии пользователей)
  - Система для сохранения истории обновлений

### 3.2 Технические требования к играм
- **Критерии совместимости**:
  - Требования к формату исполняемых файлов
  - Поддерживаемые игровые движки и технологии
  - Правила использования сторонних DRM

- **Интеграция с клиентом платформы**:
  - SDK для взаимодействия с клиентским приложением
  - API для интеграции достижений и статистики
  - Документация по использованию оверлея платформы

- **Требования к обновлениям**:
  - Форматы и структура патчей
  - Процессы тестирования обновлений
  - Правила отката версий при проблемах

- **Стандарты безопасности**:
  - Требования к защите игр от взлома
  - Политика использования античитов
  - Стандарты защиты пользовательских данных

### 3.3 Процесс технической интеграции
- **Этап 1: Оценка и планирование**:
  - Технический аудит игры
  - Определение необходимых модификаций
  - Создание плана миграции для конкретной игры

- **Этап 2: Подготовка контента**:
  - Миграция метаданных и медиа-материалов
  - Адаптация игровых файлов для платформы
  - Тестирование базовой функциональности

- **Этап 3: Интеграция систем**:
  - Внедрение API платформы в игру
  - Настройка платежных интеграций для DLC
  - Интеграция с социальными функциями платформы

- **Этап 4: Тестирование и запуск**:
  - Полное функциональное тестирование на платформе
  - Проверка совместимости с клиентским приложением
  - Финальное утверждение и публикация

### 3.4 Поддержка различных бизнес-моделей
- **Платные игры**:
  - Настройка ценовых моделей и региональных цен
  - Поддержка пробных версий и демо
  - Система предзаказов и раннего доступа

- **Условно-бесплатные игры**:
  - Интеграция с системой внутриигровых покупок
  - Инструменты для управления виртуальной валютой
  - Аналитика и оптимизация монетизации

- **Подписочные модели**:
  - Поддержка рекуррентных платежей
  - Управление периодами подписки
  - Аналитика удержания подписчиков

- **Инновационные модели**:
  - Поддержка совместных покупок
  - Интеграция с системой подарков
  - Механизмы групповых скидок

## 4. Маркетинговая поддержка

### 4.1 Программа продвижения разработчиков
- **Приоритетное размещение**:
  - Гарантированное место на главной странице для мигрировавших разработчиков
  - Выделение в поиске и категориях
  - Специальные баннеры для новых партнеров

- **Медиа-поддержка**:
  - Интервью с разработчиками на ресурсах платформы
  - Помощь в организации пресс-релизов
  - Контакты с ключевыми СМИ и блогерами

- **Социальные медиа**:
  - Продвижение в официальных аккаунтах платформы
  - Совместные акции в социальных сетях
  - Создание виральных кампаний для ключевых релизов

- **Событийный маркетинг**:
  - Участие в игровых выставках и фестивалях
  - Организация презентаций для прессы
  - Встречи с игровым сообществом

### 4.2 Финансовые стимулы
- **Программа сниженной комиссии**:
  - 15% комиссия для первых 100 разработчиков (вместо стандартных 30%)
  - Дополнительное снижение за эксклюзивность
  - Прогрессивная шкала комиссии в зависимости от объема продаж

- **Гранты и инвестиции**:
  - Фонд поддержки отечественных разработчиков
  - Гранты на локализацию зарубежных игр
  - Инвестиции в перспективные проекты

- **Специальные акции**:
  - Бонусы при запуске игр в определенные периоды
  - Финансирование специальных версий игр для платформы
  - Совместные рекламные бюджеты

- **Программа быстрых выплат**:
  - Еженедельные выплаты для приоритетных партнеров
  - Авансовые платежи для эксклюзивных релизов
  - Гарантированный минимум выплат для избранных проектов

### 4.3 Образовательная программа
- **Обучающие материалы**:
  - Подробная документация по всем аспектам платформы
  - Видеоуроки по интеграции и публикации
  - Руководства по оптимизации продаж

- **Вебинары и мастер-классы**:
  - Регулярные онлайн-семинары по работе с платформой
  - Мастер-классы от успешных разработчиков
  - Сессии вопросов и ответов с командой платформы

- **Консультационная поддержка**:
  - Персональные технические консультации
  - Помощь в оптимизации метаданных и продающих материалов
  - Анализ маркетинговой стратегии

- **Сообщество разработчиков**:
  - Закрытый форум для обмена опытом
  - Регулярные встречи разработчиков
  - Программа наставничества для новичков

## 5. Индивидуальные программы для различных категорий разработчиков

### 5.1 Программа для крупных издателей
- **Особые условия**:
  - Индивидуальные финансовые условия
  - Совместная разработка специальных функций
  - Расширенный доступ к аналитике

- **Эксклюзивное партнерство**:
  - Стратегические маркетинговые кампании
  - Доступ к бета-версиям функций платформы
  - Участие в формировании дорожной карты развития

- **Техническая интеграция**:
  - Выделенная техническая команда для миграции
  - Индивидуальная настройка API
  - Приоритетный доступ к инфраструктуре

- **Представительство**:
  - Участие в официальных мероприятиях платформы
  - Совместные пресс-релизы и анонсы
  - Прямая коммуникация с руководством платформы

### 5.2 Программа для инди-разработчиков
- **Облегченная публикация**:
  - Упрощенный процесс верификации
  - Шаблоны для создания страниц игр
  - Автоматизированные инструменты для подготовки материалов

- **Финансовая поддержка**:
  - Специальные условия комиссии для малобюджетных игр
  - Микрогранты на развитие проектов
  - Отсутствие минимального порога для выплат

- **Инди-зона в магазине**:
  - Специальный раздел для независимых разработчиков
  - Регулярные акции и подборки инди-игр
  - Система голосования сообщества

- **Взаимоподдержка**:
  - Программа взаимного продвижения инди-игр
  - Общий фонд маркетинговых ресурсов
  - Совместные стенды на выставках

### 5.3 Программа для образовательных учреждений
- **Академическая программа**:
  - Бесплатный доступ к инструментам разработчика для вузов
  - Специальные условия для студенческих проектов
  - Интеграция с образовательными программами

- **Поддержка учебных проектов**:
  - Возможность публикации учебных работ
  - Специальная категория для образовательных игр
  - Менторская поддержка студенческих команд

- **Карьерный центр**:
  - Стажировки для студентов
  - Платформа для поиска талантов
  - Программа молодых специалистов

- **Исследовательское сотрудничество**:
  - Доступ к анонимизированным данным для исследований
  - Совместные научные проекты
  - Гранты на исследования в области геймдизайна и разработки

### 5.4 Программа для зарубежных разработчиков
- **Культурная адаптация**:
  - Помощь в локализации на русский язык
  - Консультации по особенностям российского рынка
  - Адаптация контента к местным требованиям

- **Финансовые решения**:
  - Варианты выплат в различных валютах
  - Помощь с налоговой документацией
  - Адаптация ценовой политики к российскому рынку

- **Представительство на российском рынке**:
  - Помощь в продвижении на местных мероприятиях
  - Контакты с локальными медиа
  - Представление интересов в регионе

- **Юридическая поддержка**:
  - Консультации по соответствию местному законодательству
  - Помощь в регистрации прав на интеллектуальную собственность
  - Адаптация пользовательских соглашений

## 6. График и этапы реализации

### 6.1 Подготовительный этап (1-2 месяца)
- **Месяц 1**:
  - Формирование команды по привлечению разработчиков
  - Разработка базовых инструментов миграции
  - Подготовка финансовых процессов
  - Создание первичной документации

- **Месяц 2**:
  - Запуск портала для разработчиков (базовая версия)
  - Тестирование инструментов миграции
  - Начало переговоров с ключевыми партнерами
  - Подготовка юридической документации

### 6.2 Пилотная фаза (2-3 месяца)
- **Месяц 3**:
  - Заключение соглашений с первыми 5-10 разработчиками
  - Начало миграции первых игр
  - Тестирование полного цикла публикации
  - Сбор и обработка обратной связи

- **Месяц 4**:
  - Расширение до 20-30 пилотных партнеров
  - Доработка инструментов на основе обратной связи
  - Первые релизы мигрированных игр
  - Подготовка кейсов успеха

- **Месяц 5**:
  - Анализ результатов пилотной фазы
  - Финализация процессов и инструментов
  - Подготовка к расширенному запуску
  - Разработка расширенной маркетинговой программы

### 6.3 Фаза расширения (3-6 месяцев)
- **Месяц 6-7**:
  - Официальный запуск программы миграции
  - Проведение серии вебинаров и презентаций
  - Активное привлечение средних и малых студий
  - Запуск базовой программы финансовых стимулов

- **Месяц 8-9**:
  - Масштабирование технической поддержки
  - Запуск полной версии инструментов аналитики
  - Инициирование программы для инди-разработчиков
  - Организация первой конференции разработчиков

- **Месяц 10-11**:
  - Начало привлечения зарубежных разработчиков
  - Запуск фонда поддержки отечественных студий
  - Расширение функциональности панели разработчика
  - Анализ результатов и корректировка стратегии

### 6.4 Фаза стабилизации (6-12 месяцев)
- **Месяц 12-15**:
  - Полномасштабная открытая регистрация для всех разработчиков
  - Автоматизация большинства процессов миграции
  - Запуск программы академического партнерства
  - Регулярные мероприятия для сообщества разработчиков

- **Месяц 16-18**:
  - Переход от активного привлечения к модели устойчивого роста
  - Углубление интеграций с партнерами
  - Развитие долгосрочных стратегических отношений
  - Формирование экосистемы поддержки разработчиков

## 7. Метрики успеха программы миграции

### 7.1 Количественные показатели
- **Количество мигрировавших разработчиков**:
  - 50+ разработчиков к концу пилотной фазы
  - 200+ разработчиков к концу фазы расширения
  - 500+ разработчиков к концу первого года

- **Объем контента**:
  - 100+ игр к концу пилотной фазы
  - 500+ игр к концу фазы расширения
  - 1000+ игр к концу первого года

- **Финансовые показатели**:
  - Средний доход на разработчика
  - Процент успешных релизов (превышающих порог окупаемости)
  - Темп роста продаж мигрировавших разработчиков

- **Технические показатели**:
  - Среднее время миграции одной игры
  - Процент игр, мигрировавших без технических проблем
  - Время реакции технической поддержки

### 7.2 Качественные показатели
- **Удовлетворенность разработчиков**:
  - Регулярные опросы удовлетворенности
  - Обратная связь на форуме разработчиков
  - Глубинные интервью с ключевыми партнерами

- **Качество контента**:
  - Средние пользовательские оценки мигрировавших игр
  - Разнообразие жанров и категорий
  - Уникальный контент и эксклюзивы

- **Устойчивость сообщества**:
  - Активность разработчиков на форуме
  - Участие в мероприятиях платформы
  - Взаимная поддержка между разработчиками

- **Имидж платформы в индустрии**:
  - Упоминания в профильных СМИ
  - Интерес со стороны потенциальных партнеров
  - Авторитет среди профессионального сообщества

### 7.3 Долгосрочные показатели
- **Лояльность разработчиков**:
  - Процент разработчиков, выпускающих повторные проекты
  - Срок сотрудничества с платформой
  - Готовность рекомендовать платформу другим разработчикам

- **Экосистемные эффекты**:
  - Развитие сопутствующих сервисов
  - Формирование стандартов индустрии
  - Влияние на развитие игровой индустрии России

- **Международный авторитет**:
  - Интерес со стороны международных разработчиков
  - Присутствие на международных мероприятиях
  - Международные партнерства и коллаборации

## 8. Управление рисками программы миграции

### 8.1 Идентификация ключевых рисков
- **Технические риски**:
  - Несовместимость игр с платформой
  - Сложности с миграцией данных
  - Проблемы масштабирования инфраструктуры

- **Бизнес-риски**:
  - Недостаточная заинтересованность ключевых разработчиков
  - Конкуренция со стороны других платформ
  - Финансовые риски при предоставлении льготных условий

- **Регуляторные риски**:
  - Изменения в законодательстве
  - Санкционные ограничения
  - Требования к контенту

- **Репутационные риски**:
  - Негативный опыт первых мигрировавших разработчиков
  - Публичная критика платформы
  - Сравнение с глобальными конкурентами не в пользу платформы

### 8.2 Стратегии митигации рисков
- **Для технических рисков**:
  - Тщательное тестирование на этапе пилотной программы
  - Гибкий подход к требованиям совместимости
  - Резервные технические решения

- **Для бизнес-рисков**:
  - Индивидуальный подход к ключевым разработчикам
  - Разработка уникальных преимуществ платформы
  - Постепенное масштабирование финансовых программ

- **Для регуляторных рисков**:
  - Постоянный мониторинг законодательства
  - Проактивное взаимодействие с регуляторами
  - Гибкие условия контрактов с учетом возможных изменений

- **Для репутационных рисков**:
  - Особое внимание качеству в пилотной фазе
  - Прозрачная коммуникация о текущем статусе платформы
  - Быстрое реагирование на проблемы и критику

### 8.3 План действий в кризисных ситуациях
- **Технические сбои**:
  - Процедуры немедленного реагирования
  - Приоритизация критических проблем
  - Коммуникационный план для информирования разработчиков

- **Репутационные кризисы**:
  - Подготовленные сценарии реагирования
  - Выделенная команда для коммуникации в кризис
  - Стратегия восстановления доверия

- **Финансовые проблемы**:
  - Резервные фонды для выполнения обязательств
  - Планы оптимизации расходов
  - Альтернативные модели монетизации

- **Регуляторные изменения**:
  - Подготовленные альтернативные бизнес-модели
  - Юридическая команда для быстрой адаптации
  - Международная диверсификация (при необходимости)

# Финализация архитектуры системы

## 1. Общая архитектура

### 1.1 Схема развертывания

```
[Пользователи] → [CDN] → [API Gateway] → [Микросервисы] → [Хранилища данных]
```

### 1.2 Типы компонентов

**Клиентские приложения**:
- Десктопное приложение: C++/Qt
- Веб-интерфейс: React/TypeScript
- Мобильный клиент: React Native

**Серверные компоненты**:
- API Gateway: Envoy
- Микросервисы: Go, Kotlin/Spring Boot
- Фоновые обработчики: Python, Kotlin

**Хранилища данных**:
- Основная БД: PostgreSQL 14
- Кэш: Redis 6.2 в кластерной конфигурации
- Хранилище файлов: S3-совместимое хранилище (MinIO)
- Очереди сообщений: Kafka 3.1

## 2. Микросервисная архитектура

### 2.1 Основные микросервисы

| Сервис | Ответственность | Технологии | Зависимости |
|--------|-----------------|------------|-------------|
| Account Service | Управление пользователями | Go 1.19 | PostgreSQL, Redis |
| Auth Service | Аутентификация, токены | Go 1.19 | Redis, PostgreSQL |
| Catalog Service | Каталог игр | Kotlin/Spring Boot | PostgreSQL, Redis, Elasticsearch |
| Library Service | Пользовательская библиотека | Kotlin/Spring Boot | PostgreSQL, Redis |
| Payment Service | Обработка платежей | Go 1.19 | PostgreSQL, Kafka |
| Download Service | Управление загрузками | Go 1.19 | S3, Redis |
| Social Service | Социальные функции | Kotlin/Spring Boot | PostgreSQL, Redis, Kafka |
| Developer Service | Панель разработчика | Kotlin/Spring Boot | PostgreSQL, S3 |
| Admin Service | Административные функции | Kotlin/Spring Boot | PostgreSQL, Elasticsearch |
| Analytics Service | Сбор и анализ данных | Python 3.10 | ClickHouse, Kafka |

### 2.2 Масштабирование сервисов

| Сервис | Начальные экземпляры | Макс. экземпляры | Стратегия масштабирования |
|--------|----------------------|-----------------|---------------------------|
| Account Service | 3 | 10 | CPU >70%, 30 сек |
| Auth Service | 4 | 20 | CPU >60%, 20 сек |
| Catalog Service | 4 | 15 | CPU >70%, 30 сек |
| Library Service | 3 | 8 | CPU >70%, 30 сек |
| Payment Service | 3 | 8 | Очередь >1000 сообщений |
| Download Service | 5 | 30 | Количество запросов >5000/мин |
| Social Service | 2 | 6 | CPU >70%, 30 сек |
| Developer Service | 2 | 4 | CPU >80%, 60 сек |
| Admin Service | 2 | 4 | CPU >80%, 60 сек |
| Analytics Service | 3 | 8 | Очередь >2000 сообщений |

## 3. Хранение данных

### 3.1 Схема шардирования PostgreSQL

**Шардирование по пользователям**:
- 4 начальных шарда
- Рост до 16 шардов в перспективе
- Шардирование по user_id (консистентное хеширование)

**Шардирование по играм**:
- 3 начальных шарда
- Рост до 12 шардов в перспективе
- Шардирование по game_id

### 3.2 Схема репликации

**Базы данных**:
- Primary-Standby репликация (1:2)
- Физическая репликация PostgreSQL
- Асинхронная репликация между ДЦ
- Время переключения на реплику: <1 мин

**Redis**:
- Кластерная конфигурация (3 мастера, 3 реплики)
- Репликация между ДЦ

**Kafka**:
- Кластер из 5 брокеров
- Фактор репликации: 3
- 3 Zookeeper-узла

### 3.3 Хранилище контента

**Структура хранилища**:
- Базовое разделение по типам контента: games, updates, images, videos
- Трехуровневая иерархия для игровых файлов: publisher/game/version
- Механизм дедупликации для частоиспользуемых ресурсов

**Спецификация MinIO**:
- Начальная емкость: 500TB
- 8 серверных узлов с RAID 6
- Географическое распределение по 2 ДЦ

## 4. Системная архитектура

### 4.1 Сетевая инфраструктура

**Сегментация сети**:
- DMZ: API Gateway, CDN, балансировщики
- Application Zone: микросервисы, очереди сообщений
- Data Zone: базы данных, хранилища
- Admin Zone: инструменты управления

**Внешние подключения**:
- 2 независимых канала по 10 Gbps
- BGP с 2 провайдерами
- DDoS-защита на уровне провайдера

**Внутренние соединения**:
- Минимум 40 Gbps внутри ДЦ
- Выделенный 1 Gbps VPN между ДЦ

### 4.2 Безопасность на уровне архитектуры

**Защита периметра**:
- WAF перед API Gateway
- Ограничение скорости запросов (rate limiting)
- Фильтрация входящего трафика (OWASP Top 10)

**Безопасность микросервисов**:
- Взаимная TLS-аутентификация (mTLS)
- Service Mesh с шифрованием всего межсервисного трафика
- Минимальные привилегии (principle of least privilege)

**Защита данных**:
- Шифрование данных в состоянии покоя (AES-256)
- Изоляция хранилищ данных от прямого доступа
- Многоуровневая авторизация для доступа к данным

### 4.3 Управление конфигурацией

**Технологии**:
- Kubernetes для оркестрации
- Consul для сервисного обнаружения
- Vault для хранения секретов
- GitOps-подход (ArgoCD)

**Стратегия конфигурирования**:
- Внешние конфигурационные файлы
- Переменные окружения для секретных данных
- Централизованное управление конфигурацией

## 5. Интеграционная архитектура

### 5.1 Внутренние интеграции

**Синхронные интеграции**:
- REST API между сервисами (OpenAPI 3.0)
- gRPC для критичных к производительности взаимодействий

**Асинхронные интеграции**:
- Kafka для передачи событий
- Dead Letter Queue для обработки ошибок
- События в формате JSON с версионированием схем

### 5.2 Внешние интеграции

**Платежные системы**:
- REST API с TLS 1.3
- Обмен цифровыми сертификатами
- Резервные каналы связи

**Социальные сети**:
- OAuth 2.0 для авторизации
- Вебхуки для обратной связи
- Кэширование токенов с TTL

**Сторонние сервисы**:
- Интеграция через API Gateway
- Ограничение доступа по IP и токенам
- Контроль SLA и мониторинг доступности

## 6. Технические характеристики и ограничения

### 6.1 Производительность

**Целевые показатели**:
- Время отклика API: <200мс для 95% запросов
- Максимальное время ответа: <1с для 99% запросов
- Пропускная способность: >5000 запросов/сек на микросервис
- Скорость загрузки файлов: минимум 50MB/s

**Мониторинг**:
- Prometheus для сбора метрик
- Grafana для визуализации
- Jaeger для распределенной трассировки
- ELK Stack для логов

### 6.2 Надежность

**Цели**:
- Доступность: 99.9% (не более 8.76 часов простоя в год)
- MTBF (среднее время между сбоями): >2000 часов
- MTTR (среднее время восстановления): <30 минут
- RPO (точка восстановления): <5 минут
- RTO (время восстановления): <30 минут

**Стратегии**:
- Активно-активная конфигурация между ДЦ
- Автоматическое переключение при отказе
- Проактивный мониторинг здоровья системы
- Изоляция сбоев через Circuit Breaker

### 6.3 Масштабируемость

**Начальные возможности**:
- Поддержка 100,000 одновременных пользователей
- Обработка до 1,000 транзакций в секунду
- Хранение 10,000+ игр в каталоге

**Потенциал роста**:
- Горизонтальное масштабирование до 1,000,000+ одновременных пользователей
- Масштабирование хранилища до 5PB
- Увеличение транзакционной нагрузки в 10 раз без существенной перестройки

## 7. Обоснования ключевых архитектурных решений

### 7.1 Микросервисная архитектура
- **Обоснование**: Независимое масштабирование и развертывание компонентов
- **Альтернативы**: Монолитная архитектура (отклонена из-за сложности масштабирования)
- **Риски**: Сложность отладки распределенных транзакций, более высокие требования к инфраструктуре
- **Митигация**: Service Mesh, распределенная трассировка, тщательное проектирование границ сервисов

### 7.2 Выбор PostgreSQL
- **Обоснование**: Поддержка сложных транзакций, надежность, российская техподдержка
- **Альтернативы**: MySQL (отклонена из-за менее гибкой репликации), Oracle (отклонена из-за стоимости)
- **Риски**: Сложность горизонтального масштабирования
- **Митигация**: Шардирование, правильное проектирование схемы

### 7.3 Использование Kafka
- **Обоснование**: Высокая пропускная способность, отказоустойчивость, гарантированная доставка
- **Альтернативы**: RabbitMQ (отклонена из-за меньшей производительности при большой нагрузке)
- **Риски**: Сложность управления и настройки
- **Митигация**: Автоматизация управления кластером, мониторинг, стандартизация форматов сообщений

### 7.4 API Gateway
- **Обоснование**: Единая точка входа, управление доступом, мониторинг
- **Альтернативы**: Прямой доступ к микросервисам (отклонен из соображений безопасности)
- **Риски**: Потенциальное узкое место при росте нагрузки
- **Митигация**: Горизонтальное масштабирование, кэширование, оптимизация

## 8. План перехода к целевой архитектуре

### 8.1 Этапы внедрения компонентов

**Фаза 1 (Базовая функциональность)**:
- Запуск базовых микросервисов (Account, Auth, Catalog, Library)
- Развертывание основной инфраструктуры
- Интеграция с ключевыми внешними системами

**Фаза 2 (Расширенные функции)**:
- Добавление социальных компонентов
- Интеграция аналитики
- Расширение панели разработчика

**Фаза 3 (Масштабирование)**:
- Внедрение шардирования баз данных
- Географическое распределение
- Оптимизация производительности

### 8.2 Приоритизация компонентов

**Критические компоненты (день 1)**:
- Авторизация пользователей
- Каталог игр
- Базовые платежи
- Библиотека пользователя

**Высокоприоритетные компоненты (первый месяц)**:
- Расширенные платежные функции
- Система загрузки игр
- Базовая панель разработчика
- Модерация контента

**Среднеприоритетные компоненты (3-6 месяцев)**:
- Социальные функции
- Расширенная аналитика
- Интеграции с внешними сервисами

### 8.3 Требования к командам

**Необходимые технические специалисты**:
- Backend-разработчики: 12 (Go, Kotlin)
- Frontend-разработчики: 8 (React)
- DevOps-инженеры: 5
- Инженеры по базам данных: 3
- Архитекторы: 2
- Специалисты по безопасности: 3
- QA-инженеры: 8

# Детализация API и интерфейсов взаимодействия

## 1. Общие принципы API

### 1.1 Стандарты API

**REST API**:
- Версионирование в URL: `/v1/endpoint`
- Формат данных: JSON
- HTTP-методы: GET, POST, PUT, DELETE, PATCH
- Коды статуса: соответствуют HTTP-стандартам
- Поддержка CORS для веб-клиентов

**gRPC API**:
- Protocol Buffers версия 3
- Потоковая передача для больших объемов данных
- Кодогенерация для всех клиентских языков
- Бинарная сериализация для производительности

### 1.2 Аутентификация и авторизация

**Механизмы аутентификации**:
- Bearer JWT-токены для всех типов клиентов
- mTLS для межсервисного взаимодействия
- OAuth 2.0 для авторизации через третьи стороны

**Структура JWT**:
```json
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "key-id-1"
}
{
  "sub": "user-id",
  "iss": "gameplatform.ru",
  "aud": "api.gameplatform.ru",
  "exp": 1672531199,
  "iat": 1672444799,
  "jti": "unique-token-id",
  "scope": "user:read user:write",
  "roles": ["user"],
  "device_id": "device-fingerprint"
}
```

**Процесс авторизации**:
- Проверка токена в API Gateway
- Валидация подписи и срока действия
- Проверка scope для конкретного эндпоинта
- Передача информации о пользователе в заголовках

### 1.3 Управление ошибками

**Формат ошибок**:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Человекочитаемое сообщение",
    "details": {
      "field": "имя_поля",
      "reason": "причина_ошибки"
    },
    "trace_id": "уникальный_идентификатор_запроса"
  }
}
```

**Стандартные коды ошибок**:
- `INVALID_ARGUMENT`: Неверные входные данные
- `AUTHENTICATION_FAILED`: Ошибка аутентификации
- `PERMISSION_DENIED`: Отказ в доступе
- `NOT_FOUND`: Ресурс не найден
- `ALREADY_EXISTS`: Ресурс уже существует
- `RESOURCE_EXHAUSTED`: Превышены лимиты
- `INTERNAL_ERROR`: Внутренняя ошибка сервера

### 1.4 Пагинация и фильтрация

**Пагинация**:
```
GET /v1/games?limit=20&offset=40
```

**Ответ с пагинацией**:
```json
{
  "total": 150,
  "limit": 20,
  "offset": 40,
  "items": [...]
}
```

**Фильтрация**:
```
GET /v1/games?genre=rpg&price_min=100&price_max=1000&sort_by=release_date&sort_order=desc
```

**Полнотекстовый поиск**:
```
GET /v1/games?search=название+игры
```

## 2. API для пользовательского сегмента

### 2.1 API аутентификации

#### 2.1.1 Регистрация пользователя
- **Метод**: `POST /v1/auth/register`
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "email": "user@example.com",
  "password": "Secure_Password123",
  "username": "Username123",
  "phone_number": "+79001234567"
}
```
- **Успешный ответ** (201 Created):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "Username123",
  "access_token": "eyJhbGciOiJIUzI1...",
  "refresh_token": "eyJhbGciOiJIUzI1...",
  "expires_in": 3600
}
```
- **Ошибки**:
  - 400: Некорректные данные
  - 409: Email/username уже существует

#### 2.1.2 Аутентификация пользователя
- **Метод**: `POST /v1/auth/login`
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "login": "user@example.com",
  "password": "Secure_Password123",
  "device_info": {
    "type": "desktop",
    "os": "windows",
    "app_version": "1.2.3"
  }
}
```
- **Успешный ответ** (200 OK):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "Username123",
  "access_token": "eyJhbGciOiJIUzI1...",
  "refresh_token": "eyJhbGciOiJIUzI1...",
  "expires_in": 3600
}
```
- **Ошибки**:
  - 400: Некорректные данные
  - 401: Неверный логин или пароль
  - 403: Аккаунт заблокирован

#### 2.1.3 Обновление токена
- **Метод**: `POST /v1/auth/refresh`
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "refresh_token": "eyJhbGciOiJIUzI1..."
}
```
- **Успешный ответ** (200 OK):
```json
{
  "access_token": "eyJhbGciOiJIUzI1...",
  "refresh_token": "eyJhbGciOiJIUzI1...",
  "expires_in": 3600
}
```
- **Ошибки**:
  - 400: Некорректный токен
  - 401: Истекший токен

### 2.2 API каталога игр

#### 2.2.1 Получение списка игр
- **Метод**: `GET /v1/games`
- **Параметры запроса**:
  - `limit` (int, опционально): Количество результатов (по умолчанию 20)
  - `offset` (int, опционально): Смещение для пагинации
  - `sort_by` (string, опционально): Поле для сортировки (release_date, price, rating)
  - `sort_order` (string, опционально): Порядок сортировки (asc, desc)
  - `genre` (string, опционально): Фильтр по жанру
  - `price_min` (float, опционально): Минимальная цена
  - `price_max` (float, опционально): Максимальная цена
  - `search` (string, опционально): Поисковый запрос
- **Успешный ответ** (200 OK):
```json
{
  "total": 1500,
  "limit": 20,
  "offset": 0,
  "games": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "developer": "Разработчик",
      "publisher": "Издатель",
      "release_date": "2023-01-01T00:00:00Z",
      "price": 1999.00,
      "discount_price": 1499.00,
      "thumbnail_url": "https://cdn.gameplatform.ru/games/123/thumbnail.jpg",
      "genres": ["Экшен", "Приключения"],
      "tags": ["Одиночная игра", "Открытый мир"],
      "rating": 4.8,
      "total_reviews": 1200,
      "in_library": false,
      "in_wishlist": true
    },
    // ...
  ]
}
```
- **Ошибки**:
  - 400: Некорректные параметры

#### 2.2.2 Получение деталей игры
- **Метод**: `GET /v1/games/{game_id}`
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "developer": {
    "developer_id": "12345678-1234-1234-1234-123456789012",
    "name": "Разработчик"
  },
  "publisher": {
    "publisher_id": "12345678-1234-1234-1234-123456789012",
    "name": "Издатель"
  },
  "description": "Полное описание игры...",
  "short_description": "Краткое описание",
  "release_date": "2023-01-01T00:00:00Z",
  "price": 1999.00,
  "discount_price": 1499.00,
  "discount_end_date": "2023-02-01T00:00:00Z",
  "genres": ["Экшен", "Приключения"],
  "tags": ["Одиночная игра", "Открытый мир"],
  "age_rating": "18+",
  "system_requirements": {
    "minimum": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i5-6600K",
      "memory": "8 GB RAM",
      "graphics": "NVIDIA GeForce GTX 970",
      "storage": "50 GB"
    },
    "recommended": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i7-8700K",
      "memory": "16 GB RAM",
      "graphics": "NVIDIA GeForce RTX 2070",
      "storage": "50 GB SSD"
    }
  },
  "screenshots": [
    {"url": "https://cdn.gameplatform.ru/games/123/screen1.jpg", "caption": "Описание скриншота"}
  ],
  "videos": [
    {"url": "https://cdn.gameplatform.ru/games/123/trailer.mp4", "title": "Трейлер игры"}
  ],
  "rating": 4.8,
  "total_reviews": 1200,
  "positive_reviews_percent": 92,
  "in_library": false,
  "in_wishlist": true,
  "dlc": [
    {
      "dlc_id": "12345678-1234-1234-1234-123456789012",
      "title": "DLC 1",
      "price": 499.00,
      "in_library": false
    }
  ],
  "similar_games": [
    {
      "game_id": "87654321-4321-4321-4321-210987654321",
      "title": "Похожая игра",
      "thumbnail_url": "https://cdn.gameplatform.ru/games/456/thumbnail.jpg"
    }
  ]
}
```
- **Ошибки**:
  - 404: Игра не найдена

### 2.3 API библиотеки пользователя

#### 2.3.1 Получение библиотеки игр
- **Метод**: `GET /v1/library`
- **Авторизация**: Требуется
- **Параметры запроса**:
  - `limit` (int, опционально): Количество результатов
  - `offset` (int, опционально): Смещение
  - `sort_by` (string, опционально): Поле для сортировки
  - `sort_order` (string, опционально): Порядок сортировки
- **Успешный ответ** (200 OK):
```json
{
  "total": 45,
  "limit": 20,
  "offset": 0,
  "games": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "thumbnail_url": "https://cdn.gameplatform.ru/games/123/thumbnail.jpg",
      "purchase_date": "2023-01-01T12:00:00Z",
      "last_played": "2023-02-10T18:30:00Z",
      "total_playtime_minutes": 1250,
      "installed": true,
      "install_size_mb": 50000,
      "latest_version": "1.2.3",
      "installed_version": "1.2.1",
      "update_available": true,
      "is_hidden": false
    },
    // ...
  ]
}
```
- **Ошибки**:
  - 401: Требуется авторизация

#### 2.3.2 Получение деталей игры в библиотеке
- **Метод**: `GET /v1/library/{game_id}`
- **Авторизация**: Требуется
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "thumbnail_url": "https://cdn.gameplatform.ru/games/123/thumbnail.jpg",
  "purchase_date": "2023-01-01T12:00:00Z",
  "last_played": "2023-02-10T18:30:00Z",
  "total_playtime_minutes": 1250,
  "install_location": "D:/Games/GameTitle",
  "installed": true,
  "install_size_mb": 50000,
  "latest_version": "1.2.3",
  "installed_version": "1.2.1",
  "update_available": true,
  "update_size_mb": 500,
  "launch_options": [
    {
      "id": "default",
      "name": "Стандартный запуск",
      "command": ""
    },
    {
      "id": "dx12",
      "name": "DirectX 12",
      "command": "-dx12"
    }
  ],
  "achievements": {
    "total": 50,
    "unlocked": 35,
    "recent": [
      {
        "achievement_id": "ACH_001",
        "title": "Начало пути",
        "description": "Завершите обучение",
        "unlock_date": "2023-01-05T14:30:00Z",
        "icon_url": "https://cdn.gameplatform.ru/games/123/achievements/ach_001.png"
      }
    ]
  },
  "dlc": [
    {
      "dlc_id": "12345678-1234-1234-1234-123456789012",
      "title": "DLC 1",
      "owned": true,
      "installed": true
    },
    {
      "dlc_id": "87654321-4321-4321-4321-210987654321",
      "title": "DLC 2",
      "owned": false,
      "price": 499.00
    }
  ],
  "save_games": [
    {
      "id": "save_001",
      "name": "Сохранение 1",
      "date": "2023-02-08T19:45:00Z",
      "cloud_synced": true
    }
  ]
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Нет доступа к игре
  - 404: Игра не найдена в библиотеке

### 2.4 API загрузки и управления играми

#### 2.4.1 Начало установки игры
- **Метод**: `POST /v1/downloads`
- **Авторизация**: Требуется
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "install_path": "D:/Games/GameTitle",
  "dlc_ids": ["12345678-1234-1234-1234-123456789012"],
  "version": "1.2.3",
  "priority": "normal"
}
```
- **Успешный ответ** (202 Accepted):
```json
{
  "download_id": "87654321-4321-4321-4321-210987654321",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "total_size_mb": 50000,
  "estimated_time_seconds": 3600,
  "status": "queued",
  "download_manifest_url": "https://cdn.gameplatform.ru/downloads/123/manifest.json"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Нет доступа к игре
  - 404: Игра не найдена
  - 507: Недостаточно места на диске

#### 2.4.2 Получение статуса загрузки
- **Метод**: `GET /v1/downloads/{download_id}`
- **Авторизация**: Требуется
- **Успешный ответ** (200 OK):
```json
{
  "download_id": "87654321-4321-4321-4321-210987654321",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "total_size_mb": 50000,
  "downloaded_mb": 25000,
  "download_speed_mbps": 10.5,
  "progress_percent": 50,
  "status": "downloading",
  "eta_seconds": 1800,
  "current_file": "data/textures/pack001.pak",
  "error": null
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 404: Загрузка не найдена

#### 2.4.3 Управление загрузкой
- **Метод**: `PATCH /v1/downloads/{download_id}`
- **Авторизация**: Требуется
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "action": "pause", // pause, resume, cancel
  "priority": "high" // low, normal, high
}
```
- **Успешный ответ** (200 OK):
```json
{
  "download_id": "87654321-4321-4321-4321-210987654321",
  "status": "paused",
  "priority": "high"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 404: Загрузка не найдена
  - 400: Некорректное действие

### 2.5 API платежей

#### 2.5.1 Создание заказа
- **Метод**: `POST /v1/orders`
- **Авторизация**: Требуется
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "items": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "is_gift": false
    },
    {
      "game_id": "87654321-4321-4321-4321-210987654321",
      "is_gift": true,
      "gift_recipient_id": "00000000-0000-0000-0000-000000000001",
      "gift_message": "Поздравляю с днем рождения!"
    }
  ],
  "payment_method": "card", // card, sbp, wallet
  "currency": "RUB",
  "promocode": "SUMMER2023"
}
```
- **Успешный ответ** (201 Created):
```json
{
  "order_id": "12345678-1234-1234-1234-123456789012",
  "total_amount": 2498.00,
  "currency": "RUB",
  "status": "pending",
  "payment_url": "https://payment.gameplatform.ru/12345678",
  "expires_at": "2023-01-01T12:30:00Z",
  "items": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "price": 1999.00,
      "discount_amount": 0.00,
      "is_gift": false
    },
    {
      "game_id": "87654321-4321-4321-4321-210987654321",
      "title": "Название игры 2",
      "price": 499.00,
      "discount_amount": 0.00,
      "is_gift": true,
      "gift_recipient": {
        "user_id": "00000000-0000-0000-0000-000000000001",
        "username": "username"
      },
      "gift_message": "Поздравляю с днем рождения!"
    }
  ]
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 400: Некорректные данные
  - 403: Ограничения на покупку игры
  - 404: Игра не найдена
  - 409: Игра уже в библиотеке

#### 2.5.2 Получение статуса заказа
- **Метод**: `GET /v1/orders/{order_id}`
- **Авторизация**: Требуется
- **Успешный ответ** (200 OK):
```json
{
  "order_id": "12345678-1234-1234-1234-123456789012",
  "created_at": "2023-01-01T12:00:00Z",
  "status": "completed", // pending, completed, canceled, failed
  "total_amount": 2498.00,
  "currency": "RUB",
  "payment_method": "card",
  "payment_details": {
    "card_mask": "4242 **** **** 4242",
    "card_type": "visa"
  },
  "items": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "price": 1999.00,
      "discount_amount": 0.00,
      "is_gift": false
    },
    {
      "game_id": "87654321-4321-4321-4321-210987654321",
      "title": "Название игры 2",
      "price": 499.00,
      "discount_amount": 0.00,
      "is_gift": true,
      "gift_recipient": {
        "user_id": "00000000-0000-0000-0000-000000000001",
        "username": "username"
      },
      "gift_message": "Поздравляю с днем рождения!"
    }
  ],
  "receipt_url": "https://payment.gameplatform.ru/receipts/12345678.pdf"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Нет доступа к заказу
  - 404: Заказ не найден

### 2.6 API отзывов и оценок

#### 2.6.1 Создание отзыва
- **Метод**: `POST /v1/games/{game_id}/reviews`
- **Авторизация**: Требуется
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "is_recommended": true,
  "content": "Отличная игра с захватывающим сюжетом...",
  "screenshot_ids": ["12345678-1234-1234-1234-123456789012"]
}
```
- **Успешный ответ** (201 Created):
```json
{
  "review_id": "12345678-1234-1234-1234-123456789012",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "user": {
    "user_id": "00000000-0000-0000-0000-000000000001",
    "username": "username",
    "display_name": "User Display Name"
  },
  "is_recommended": true,
  "content": "Отличная игра с захватывающим сюжетом...",
  "created_at": "2023-01-10T12:00:00Z",
  "updated_at": "2023-01-10T12:00:00Z",
  "playtime_at_review": 120,
  "helpful_votes": 0,
  "screenshots": [
    {
      "id": "12345678-1234-1234-1234-123456789012",
      "url": "https://cdn.gameplatform.ru/reviews/screenshots/12345678.jpg"
    }
  ],
  "moderation_status": "pending"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Нет доступа (игра не в библиотеке)
  - 404: Игра не найдена
  - 409: Отзыв уже существует

## 3. API для издательского сегмента

### 3.1 API управления играми

#### 3.1.1 Создание игры
- **Метод**: `POST /v1/developer/games`
- **Авторизация**: Требуется (роль разработчика)
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "title": "Название игры",
  "short_description": "Краткое описание",
  "description": "Полное описание...",
  "genres": ["Экшен", "Приключения"],
  "tags": ["Одиночная игра", "Открытый мир"],
  "age_rating": "18+",
  "base_price": 1999.00,
  "system_requirements": {
    "minimum": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i5-6600K",
      "memory": "8 GB RAM",
      "graphics": "NVIDIA GeForce GTX 970",
      "storage": "50 GB"
    },
    "recommended": {
      "os": "Windows 10 64-bit",
      "processor": "Intel Core i7-8700K",
      "memory": "16 GB RAM",
      "graphics": "NVIDIA GeForce RTX 2070",
      "storage": "50 GB SSD"
    }
  }
}
```
- **Успешный ответ** (201 Created):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "status": "draft",
  "created_at": "2023-01-01T12:00:00Z"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав
  - 400: Некорректные данные

#### 3.1.2 Загрузка медиа-файлов
- **Метод**: `POST /v1/developer/games/{game_id}/media`
- **Авторизация**: Требуется (роль разработчика)
- **Content-Type**: `multipart/form-data`
- **Поля формы**:
  - `type`: тип медиа (screenshot, trailer, thumbnail, banner)
  - `file`: файл
  - `caption`: подпись (опционально)
  - `order`: порядок отображения (опционально)
- **Успешный ответ** (201 Created):
```json
{
  "media_id": "12345678-1234-1234-1234-123456789012",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "type": "screenshot",
  "url": "https://cdn.gameplatform.ru/games/123/screenshots/001.jpg",
  "caption": "Скриншот игрового процесса",
  "order": 1,
  "created_at": "2023-01-01T12:05:00Z"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав
  - 400: Некорректные данные
  - 404: Игра не найдена
  - 413: Файл слишком большой

#### 3.1.3 Создание новой версии
- **Метод**: `POST /v1/developer/games/{game_id}/versions`
- **Авторизация**: Требуется (роль разработчика)
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "version_number": "1.2.3",
  "release_notes": "Обновление включает...",
  "is_public": false
}
```
- **Успешный ответ** (201 Created):
```json
{
  "version_id": "12345678-1234-1234-1234-123456789012",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "version_number": "1.2.3",
  "status": "draft",
  "created_at": "2023-01-01T12:00:00Z",
  "upload_url": "https://upload.gameplatform.ru/games/123/versions/123/"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав
  - 404: Игра не найдена
  - 409: Версия уже существует

#### 3.1.4 Получение статистики продаж
- **Метод**: `GET /v1/developer/games/{game_id}/sales`
- **Авторизация**: Требуется (роль разработчика)
- **Параметры запроса**:
  - `period` (string, опционально): Период (day, week, month, year, all)
  - `start_date` (string, опционально): Начальная дата в формате ISO
  - `end_date` (string, опционально): Конечная дата в формате ISO
  - `group_by` (string, опционально): Группировка (day, week, month, country)
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "title": "Название игры",
  "period": {
    "start_date": "2023-01-01T00:00:00Z",
    "end_date": "2023-01-31T23:59:59Z"
  },
  "total_sales": 1250,
  "total_revenue": 2498750.00,
  "currency": "RUB",
  "developer_revenue": 1749125.00,
  "platform_fee": 749625.00,
  "data": [
    {
      "date": "2023-01-01",
      "sales": 125,
      "revenue": 249875.00,
      "developer_revenue": 174912.50
    },
    // ...
  ],
  "by_country": [
    {
      "country": "RU",
      "sales": 1000,
      "revenue": 1999000.00
    },
    {
      "country": "KZ",
      "sales": 150,
      "revenue": 299850.00
    },
    // ...
  ]
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав
  - 404: Игра не найдена

## 4. API для административного сегмента

### 4.1 API модерации

#### 4.1.1 Получение игр на модерацию
- **Метод**: `GET /v1/admin/moderation/games`
- **Авторизация**: Требуется (роль модератора)
- **Параметры запроса**:
  - `status` (string, опционально): Статус (pending_review, all)
  - `limit` (int, опционально): Количество результатов
  - `offset` (int, опционально): Смещение
- **Успешный ответ** (200 OK):
```json
{
  "total": 15,
  "limit": 20,
  "offset": 0,
  "games": [
    {
      "game_id": "12345678-1234-1234-1234-123456789012",
      "title": "Название игры",
      "developer": {
        "developer_id": "12345678-1234-1234-1234-123456789012",
        "name": "Разработчик"
      },
      "submitted_at": "2023-01-01T12:00:00Z",
      "status": "pending_review",
      "type": "new_game", // new_game, update, dlc
      "assigned_to": null
    },
    // ...
  ]
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав

#### 4.1.2 Модерация игры
- **Метод**: `PATCH /v1/admin/moderation/games/{game_id}`
- **Авторизация**: Требуется (роль модератора)
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "action": "approve", // approve, reject, request_changes
  "comment": "Игра одобрена к публикации.",
  "reasons": [], // Причины отклонения или запроса изменений
  "visibility": "public" // public, restricted (18+), internal
}
```
- **Успешный ответ** (200 OK):
```json
{
  "game_id": "12345678-1234-1234-1234-123456789012",
  "status": "approved",
  "moderated_by": "00000000-0000-0000-0000-000000000001",
  "moderated_at": "2023-01-02T10:15:00Z",
  "comment": "Игра одобрена к публикации.",
  "visibility": "public"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав
  - 404: Игра не найдена
  - 409: Некорректный статус для действия

### 4.2 API управления пользователями

#### 4.2.1 Поиск пользователей
- **Метод**: `GET /v1/admin/users`
- **Авторизация**: Требуется (роль администратора)
- **Параметры запроса**:
  - `query` (string, опционально): Поиск по имени/email
  - `status` (string, опционально): Статус (active, suspended, banned)
  - `limit` (int, опционально): Количество результатов
  - `offset` (int, опционально): Смещение
- **Успешный ответ** (200 OK):
```json
{
  "total": 1255,
  "limit": 20,
  "offset": 0,
  "users": [
    {
      "user_id": "12345678-1234-1234-1234-123456789012",
      "username": "username",
      "email": "user@example.com",
      "display_name": "User Display Name",
      "registration_date": "2023-01-01T12:00:00Z",
      "last_login_date": "2023-01-10T15:30:00Z",
      "account_status": "active",
      "roles": ["user"],
      "country": "RU"
    },
    // ...
  ]
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав

#### 4.2.2 Управление пользователем
- **Метод**: `PATCH /v1/admin/users/{user_id}`
- **Авторизация**: Требуется (роль администратора)
- **Content-Type**: `application/json`
- **Тело запроса**:
```json
{
  "account_status": "suspended", // active, suspended, banned
  "suspension_reason": "Нарушение правил платформы",
  "suspension_end_date": "2023-02-01T00:00:00Z", // null для permanent
  "roles": ["user", "developer"], // добавление/удаление ролей
  "notes": "Внутренние заметки администратора"
}
```
- **Успешный ответ** (200 OK):
```json
{
  "user_id": "12345678-1234-1234-1234-123456789012",
  "username": "username",
  "account_status": "suspended",
  "suspension_reason": "Нарушение правил платформы",
  "suspension_end_date": "2023-02-01T00:00:00Z",
  "roles": ["user", "developer"],
  "updated_by": "00000000-0000-0000-0000-000000000001",
  "updated_at": "2023-01-15T14:20:00Z"
}
```
- **Ошибки**:
  - 401: Требуется авторизация
  - 403: Недостаточно прав
  - 404: Пользователь не найден

## 5. Внутренние API для микросервисов

### 5.1 gRPC Services

#### 5.1.1 UserService
```protobuf
syntax = "proto3";

package gameplatform.services.user;

service UserService {
  rpc GetUser(GetUserRequest) returns (UserResponse);
  rpc GetUsers(GetUsersRequest) returns (UsersResponse);
  rpc CreateUser(CreateUserRequest) returns (UserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  rpc ValidateCredentials(CredentialsRequest) returns (ValidateCredentialsResponse);
}

message GetUserRequest {
  oneof identifier {
    string user_id = 1;
    string username = 2;
    string email = 3;
  }
  bool include_profile = 4;
}

message GetUsersRequest {
  repeated string user_ids = 1;
  int32 limit = 2;
  int32 offset = 3;
  bool include_profile = 4;
}

message UserResponse {
  string user_id = 1;
  string username = 2;
  string email = 3;
  string display_name = 4;
  string phone_number = 5;
  string registration_date = 6;
  string last_login_date = 7;
  string account_status = 8;
  bool two_factor_enabled = 9;
  string profile_picture_url = 10;
  repeated string roles = 11;
  UserProfile profile = 12;
}

message UserProfile {
  string real_name = 1;
  string country = 2;
  string city = 3;
  string birth_date = 4;
  string biography = 5;
  bool public_profile = 6;
}

message UsersResponse {
  repeated UserResponse users = 1;
  int32 total = 2;
}

message CreateUserRequest {
  string username = 1;
  string email = 2;
  string password = 3;
  string phone_number = 4;
  string display_name = 5;
}

message UpdateUserRequest {
  string user_id = 1;
  optional string username = 2;
  optional string email = 3;
  optional string phone_number = 4;
  optional string display_name = 5;
  optional string password = 6;
  optional string account_status = 7;
  optional bool two_factor_enabled = 8;
  optional string profile_picture_url = 9;
  optional UserProfile profile = 10;
}

message DeleteUserRequest {
  string user_id = 1;
}

message DeleteUserResponse {
  bool success = 1;
}

message CredentialsRequest {
  oneof identifier {
    string username = 1;
    string email = 2;
  }
  string password = 3;
}

message ValidateCredentialsResponse {
  bool valid = 1;
  string user_id = 2;
  repeated string roles = 3;
}
```

#### 5.1.2 CatalogService
```protobuf
syntax = "proto3";

package gameplatform.services.catalog;

service CatalogService {
  rpc GetGame(GetGameRequest) returns (GameResponse);
  rpc GetGames(GetGamesRequest) returns (GamesResponse);
  rpc SearchGames(SearchGamesRequest) returns (GamesResponse);
  rpc UpdateGame(UpdateGameRequest) returns (GameResponse);
  rpc GetGameVersions(GetGameVersionsRequest) returns (GameVersionsResponse);
  rpc GetGameVersion(GetGameVersionRequest) returns (GameVersionResponse);
}

message GetGameRequest {
  string game_id = 1;
  bool include_details = 2;
  bool include_assets = 3;
  bool include_versions = 4;
  string user_id = 5; // для проверки наличия в библиотеке/wishlist
}

message GetGamesRequest {
  repeated string game_ids = 1;
  int32 limit = 2;
  int32 offset = 3;
  bool include_details = 4;
  bool include_assets = 5;
  string user_id = 6;
}

message SearchGamesRequest {
  optional string query = 1;
  optional string genre = 2;
  optional double price_min = 3;
  optional double price_max = 4;
  string sort_by = 5;
  string sort_order = 6;
  int32 limit = 7;
  int32 offset = 8;
  string user_id = 9;
}

message GameResponse {
  string game_id = 1;
  string title = 2;
  string developer_id = 3;
  string developer_name = 4;
  string publisher_id = 5;
  string publisher_name = 6;
  string release_date = 7;
  double base_price = 8;
  optional double discount_price = 9;
  optional string discount_start_date = 10;
  optional string discount_end_date = 11;
  string short_description = 12;
  string description = 13;
  map<string, string> system_requirements = 14;
  repeated string tags = 15;
  repeated string genres = 16;
  string age_rating = 17;
  string status = 18;
  string created_at = 19;
  string updated_at = 20;
  int32 total_reviews = 21;
  double positive_reviews_percent = 22;
  repeated GameAsset assets = 23;
  repeated GameVersion versions = 24;
  bool in_library = 25;
  bool in_wishlist = 26;
}

message GameAsset {
  string asset_id = 1;
  string asset_type = 2;
  string url = 3;
  int32 order = 4;
  string caption = 5;
}

message GameVersion {
  string version_id = 1;
  string version_number = 2;
  string release_notes = 3;
  string release_date = 4;
  int64 size_mb = 5;
  string status = 6;
}

message GamesResponse {
  repeated GameResponse games = 1;
  int32 total = 2;
}

message UpdateGameRequest {
  string game_id = 1;
  optional string title = 2;
  optional string short_description = 3;
  optional string description = 4;
  optional double base_price = 5;
  optional double discount_price = 6;
  optional string discount_start_date = 7;
  optional string discount_end_date = 8;
  optional map<string, string> system_requirements = 9;
  repeated string tags = 10;
  repeated string genres = 11;
  optional string age_rating = 12;
  optional string status = 13;
}

message GetGameVersionsRequest {
  string game_id = 1;
  int32 limit = 2;
  int32 offset = 3;
}

message GameVersionsResponse {
  repeated GameVersionResponse versions = 1;
  int32 total = 2;
}

message GetGameVersionRequest {
  string version_id = 1;
  string game_id = 2;
  string version_number = 3;
}

message GameVersionResponse {
  string version_id = 1;
  string game_id = 2;
  string version_number = 3;
  string build_id = 4;
  string release_notes = 5;
  string release_date = 6;
  int64 size_mb = 7;
  string status = 8;
  string created_by = 9;
  string created_at = 10;
}
```

### 5.2 Kafka Event Schema

#### 5.2.1 Событие создания пользователя
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["event_id", "event_type", "timestamp", "version", "data"],
  "properties": {
    "event_id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор события"
    },
    "event_type": {
      "type": "string",
      "enum": ["user.created"],
      "description": "Тип события"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Время создания события"
    },
    "version": {
      "type": "string",
      "description": "Версия схемы события"
    },
    "data": {
      "type": "object",
      "required": ["user_id", "username", "email", "registration_date"],
      "properties": {
        "user_id": {
          "type": "string",
          "format": "uuid",
          "description": "Идентификатор пользователя"
        },
        "username": {
          "type": "string",
          "description": "Имя пользователя"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "Email пользователя"
        },
        "display_name": {
          "type": "string",
          "description": "Отображаемое имя"
        },
        "registration_date": {
          "type": "string",
          "format": "date-time",
          "description": "Дата регистрации"
        },
        "roles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Роли пользователя"
        }
      }
    }
  }
}
```

#### 5.2.2 Событие покупки игры
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["event_id", "event_type", "timestamp", "version", "data"],
  "properties": {
    "event_id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор события"
    },
    "event_type": {
      "type": "string",
      "enum": ["purchase.completed"],
      "description": "Тип события"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Время создания события"
    },
    "version": {
      "type": "string",
      "description": "Версия схемы события"
    },
    "data": {
      "type": "object",
      "required": ["order_id", "user_id", "items", "total_amount"],
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Идентификатор заказа"
        },
        "user_id": {
          "type": "string",
          "format": "uuid",
          "description": "Идентификатор пользователя"
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["game_id", "price", "is_gift"],
            "properties": {
              "game_id": {
                "type": "string",
                "format": "uuid",
                "description": "Идентификатор игры"
              },
              "price": {
                "type": "number",
                "description": "Цена покупки"
              },
              "discount_amount": {
                "type": "number",
                "description": "Сумма скидки"
              },
              "is_gift": {
                "type": "boolean",
                "description": "Является ли подарком"
              },
              "gift_recipient_id": {
                "type": "string",
                "format": "uuid",
                "description": "Идентификатор получателя подарка"
              }
            }
          }
        },
        "total_amount": {
          "type": "number",
          "description": "Общая сумма заказа"
        },
        "currency": {
          "type": "string",
          "description": "Валюта заказа"
        },
        "payment_method": {
          "type": "string",
          "description": "Метод оплаты"
        }
      }
    }
  }
}
```

## 6. Интерфейсы программных компонентов

### 6.1 Интерфейс клиентского приложения

#### 6.1.1 Протокол взаимодействия с клиентом
- **WebSocket URL**: `wss://api.gameplatform.ru/v1/client/ws`
- **Аутентификация**: Bearer JWT в заголовке
- **Формат сообщений**: JSON
- **Структура сообщения**:
```json
{
  "message_id": "12345678-1234-1234-1234-123456789012",
  "type": "command/event/response",
  "timestamp": "2023-01-01T12:00:00Z",
  "payload": {
    // Содержимое сообщения, зависит от типа
  }
}
```

#### 6.1.2 Команды клиентского приложения
- **Команда запуска игры**:
```json
{
  "type": "command",
  "command": "launch_game",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "launch_options": {
    "option_id": "dx12",
    "arguments": ["-windowed"]
  }
}
```
- **Команда паузы загрузки**:
```json
{
  "type": "command",
  "command": "pause_download",
  "download_id": "12345678-1234-1234-1234-123456789012"
}
```
- **Команда обновления статуса игры**:
```json
{
  "type": "command",
  "command": "update_game_status",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "is_running": true,
  "playtime_incremental_minutes": 15
}
```

#### 6.1.3 События клиентского приложения
- **Событие обновления статуса загрузки**:
```json
{
  "type": "event",
  "event": "download_progress",
  "download_id": "12345678-1234-1234-1234-123456789012",
  "progress_percent": 35,
  "download_speed_mbps": 10.5,
  "eta_seconds": 1800,
  "status": "downloading"
}
```
- **Событие доступного обновления**:
```json
{
  "type": "event",
  "event": "update_available",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "current_version": "1.2.1",
  "available_version": "1.2.3",
  "update_size_mb": 500,
  "update_notes": "Исправлены ошибки..."
}
```
- **Событие уведомления**:
```json
{
  "type": "event",
  "event": "notification",
  "notification_id": "12345678-1234-1234-1234-123456789012",
  "category": "friend_request",
  "title": "Новый запрос в друзья",
  "message": "Пользователь username хочет добавить вас в друзья",
  "action_url": "/friends/requests"
}
```

### 6.2 Интерфейс загрузки контента

#### 6.2.1 Структура манифеста загрузки
```json
{
  "manifest_id": "12345678-1234-1234-1234-123456789012",
  "game_id": "12345678-1234-1234-1234-123456789012",
  "version": "1.2.3",
  "total_size_bytes": 52428800000,
  "chunk_size_bytes": 10485760,
  "chunks": [
    {
      "chunk_id": "00000000-0000-0000-0000-000000000001",
      "offset": 0,
      "size": 10485760,
      "hash": "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "url": "https://cdn.gameplatform.ru/downloads/123/chunks/00001.bin"
    },
    // ...
  ],
  "files": [
    {
      "path": "game.exe",
      "size": 157286400,
      "executable": true,
      "hash": "1a79a4d60de6718e8e5b326e338ae533",
      "chunks": [
        "00000000-0000-0000-0000-000000000010",
        "00000000-0000-0000-0000-000000000011",
        // ...
      ]
    },
    // ...
  ],
  "launch_options": [
    {
      "id": "default",
      "name": "Стандартный запуск",
      "executable": "game.exe",
      "arguments": ""
    },
    {
      "id": "dx12",
      "name": "DirectX 12",
      "executable": "game.exe",
      "arguments": "-dx12"
    }
  ],
  "registry_entries": [
    {
      "path": "HKEY_CURRENT_USER\\Software\\GameCompany\\GameTitle",
      "key": "InstallPath",
      "value": "%INSTALL_PATH%",
      "type": "string"
    }
  ],
  "dependencies": [
    {
      "name": "DirectX Runtime",
      "version": "9.0c",
      "download_url": "https://cdn.gameplatform.ru/dependencies/directx9c.exe",
      "silent_args": "/silent"
    }
  ]
}
```

#### 6.2.2 Протокол загрузки контента
- **Загрузка манифеста**:
  - GET https://cdn.gameplatform.ru/downloads/123/manifest.json
  - Авторизация: Bearer JWT

- **Загрузка чанка**:
  - GET https://cdn.gameplatform.ru/downloads/123/chunks/00001.bin
  - Headers:
    - Authorization: Bearer JWT
    - Range: bytes=0-10485759 (опционально)

- **Проверка хеша**:
  - Клиент считает SHA-1 хеш каждого загруженного чанка
  - Сравнивает с хешем из манифеста
  - При несовпадении повторяет загрузку

- **Подтверждение установки**:
  - POST /v1/downloads/{download_id}/complete
  - Тело:
  ```json
  {
    "installation_path": "D:/Games/GameTitle",
    "installed_files_count": 1500,
    "total_size_bytes": 52428800000,
    "verify_result": {
      "status": "success",
      "verified_files": 1500,
      "corrupted_files": 0
    }
  }
  ```

### 6.3 Интерфейс для разработчиков игр

#### 6.3.1 API загрузки файлов игры
- **Инициализация загрузки**:
  - POST /v1/developer/games/{game_id}/versions/{version_id}/upload
  - Ответ:
  ```json
  {
    "upload_id": "12345678-1234-1234-1234-123456789012",
    "urls": {
      "manifest": "https://upload.gameplatform.ru/123/456/manifest.json",
      "chunks": "https://upload.gameplatform.ru/123/456/chunks/{chunk_id}"
    },
    "max_chunk_size": 104857600,
    "expires_at": "2023-01-01T14:00:00Z"
  }
  ```

- **Создание манифеста**:
  - PUT https://upload.gameplatform.ru/123/456/manifest.json
  - Content-Type: application/json
  - Тело: структура манифеста с информацией о файлах

- **Загрузка чанка**:
  - PUT https://upload.gameplatform.ru/123/456/chunks/{chunk_id}
  - Content-Type: application/octet-stream
  - Body: бинарные данные чанка

- **Завершение загрузки**:
  - POST /v1/developer/games/{game_id}/versions/{version_id}/upload/{upload_id}/complete
  - Ответ:
  ```json
  {
    "status": "processing",
    "files_count": 1500,
    "total_size_bytes": 52428800000,
    "estimated_processing_time": 300
  }
  ```

#### 6.3.2 SDK для интеграции с платформой
- **Спецификация модуля достижений**:
```typescript
interface Achievement {
  id: string;
  displayName: string;
  description: string;
  hiddenUntilUnlocked?: boolean;
  iconLockedUrl?: string;
  iconUnlockedUrl?: string;
}

interface AchievementProgress {
  id: string;
  progress: number; // 0-100
  unlockTime?: Date;
}

interface AchievementClient {
  // Инициализация клиента
  initialize(gameId: string, apiKey: string): Promise<void>;
  
  // Регистрация достижений в системе
  registerAchievements(achievements: Achievement[]): Promise<void>;
  
  // Получение прогресса достижений игрока
  getPlayerAchievements(): Promise<AchievementProgress[]>;
  
  // Разблокировка достижения
  unlockAchievement(achievementId: string): Promise<void>;
  
  // Обновление прогресса достижения
  updateAchievementProgress(achievementId: string, progress: number): Promise<void>;
  
  // Событие получения достижения
  onAchievementUnlocked(callback: (achievementId: string) => void): void;
}
```

- **Спецификация модуля облачных сохранений**:
```typescript
interface CloudSave {
  id: string;
  name: string;
  description?: string;
  createdAt: Date;
  modifiedAt: Date;
  sizeBytes: number;
  metadata?: Record<string, any>;
}

interface CloudSaveClient {
  // Инициализация клиента
  initialize(gameId: string, apiKey: string): Promise<void>;
  
  // Получение списка сохранений
  listSaves(): Promise<CloudSave[]>;
  
  // Загрузка сохранения на сервер
  uploadSave(id: string, data: Blob, metadata?: Record<string, any>): Promise<CloudSave>;
  
  // Скачивание сохранения с сервера
  downloadSave(id: string): Promise<Blob>;
  
  // Удаление сохранения с сервера
  deleteSave(id: string): Promise<void>;
  
  // Событие обновления сохранения (с другого устройства)
  onSaveUpdated(callback: (saveId: string) => void): void;
}
```

# Создание базовой структуры проекта

## 1. Структура репозитория

### 1.1 Корневая структура

```
gameplatform/
├── services/             # Микросервисы
├── web/                  # Web-интерфейс
├── client/               # Десктопный клиент
├── admin/                # Административная панель
├── sdk/                  # SDK для разработчиков
├── infrastructure/       # Код инфраструктуры (Terraform, K8s)
├── docs/                 # Документация
├── deploy/               # Скрипты деплоя
├── tools/                # Вспомогательные инструменты
└── .github/              # Настройки CI/CD
```

### 1.2 Структура сервисов

```
services/
├── account-service/      # Управление пользователями
├── auth-service/         # Аутентификация и авторизация
├── catalog-service/      # Каталог игр
├── payment-service/      # Платежи
├── library-service/      # Библиотека пользователей
├── download-service/     # Управление загрузками
├── social-service/       # Социальные функции
├── developer-service/    # Сервис для разработчиков
├── admin-service/        # Административный сервис
├── analytics-service/    # Аналитика
└── api-gateway/          # API Gateway
```

### 1.3 Структура одного микросервиса (на примере account-service)

```
account-service/
├── cmd/                  # Точки входа в приложение
│   └── server/           # Запуск сервера
├── internal/             # Внутренний код сервиса
│   ├── config/           # Конфигурация
│   ├── domain/           # Бизнес-модели и логика
│   ├── repository/       # Работа с БД
│   ├── service/          # Бизнес-сервисы
│   ├── api/              # API-контроллеры
│   │   ├── rest/         # REST API
│   │   └── grpc/         # gRPC API
│   ├── client/           # Клиенты для других сервисов  
│   └── util/             # Утилиты
├── migrations/           # Файлы миграций БД
├── test/                 # Тесты
├── api/                  # API спецификации (OpenAPI, Protobuf)
├── Dockerfile            # Сборка контейнера
├── Makefile              # Команды сборки
├── go.mod                # Зависимости (для Go)
└── README.md             # Документация
```

### 1.4 Структура web-интерфейса

```
web/
├── src/
│   ├── api/              # API клиенты
│   ├── assets/           # Статические ресурсы
│   ├── components/       # React компоненты
│   │   ├── common/       # Общие компоненты
│   │   ├── layout/       # Компоненты раскладки
│   │   ├── auth/         # Компоненты аутентификации
│   │   ├── catalog/      # Компоненты каталога
│   │   └── profile/      # Компоненты профиля
│   ├── pages/            # Страницы приложения
│   ├── context/          # React контексты
│   ├── hooks/            # Пользовательские хуки
│   ├── redux/            # Redux хранилище
│   │   ├── slices/       # Redux слайсы
│   │   ├── store.ts      # Настройка хранилища
│   │   └── middleware.ts # Промежуточное ПО
│   ├── utils/            # Утилиты
│   ├── styles/           # Глобальные стили
│   ├── routes/           # Маршрутизация
│   ├── config/           # Конфигурация
│   ├── types/            # TypeScript типы
│   ├── constants.ts      # Константы
│   ├── App.tsx           # Корневой компонент
│   └── index.tsx         # Точка входа
├── public/               # Публичные ресурсы
├── package.json          # Зависимости
├── tsconfig.json         # Настройки TypeScript
├── .eslintrc.js          # Настройки ESLint
├── .prettierrc           # Настройки Prettier
├── vite.config.ts        # Настройки сборки
└── Dockerfile            # Сборка контейнера
```

### 1.5 Структура клиентского приложения

```
client/
├── src/
│   ├── core/             # Ядро приложения
│   │   ├── auth/         # Модуль аутентификации
│   │   ├── api/          # API клиенты
│   │   ├── config/       # Конфигурация
│   │   ├── download/     # Управление загрузками
│   │   ├── update/       # Система обновлений
│   │   ├── telemetry/    # Сбор телеметрии
│   │   └── ipc/          # Межпроцессное взаимодействие
│   ├── ui/               # Пользовательский интерфейс
│   │   ├── components/   # UI компоненты
│   │   ├── pages/        # Страницы
│   │   ├── styles/       # Стили
│   │   └── utils/        # UI утилиты
│   ├── store/            # Хранилище данных
│   ├── utils/            # Общие утилиты
│   └── main.cpp          # Точка входа
├── include/              # Заголовочные файлы
├── resources/            # Ресурсы приложения
├── tests/                # Тесты
├── third_party/          # Сторонние библиотеки
├── CMakeLists.txt        # Настройки сборки
└── README.md             # Документация
```

## 2. Реализация базовой структуры

### 2.1 Настройка монорепозитория

**Файл: .gitignore**
```
# Общие
.DS_Store
*.log
*.swp
.env
.env.*
!.env.example
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
dist/
build/

# Go
bin/
vendor/
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out

# C++ / Qt
*.o
*.obj
*.ilk
*.pdb
moc_*.cpp
ui_*.h
qrc_*.cpp
*.qm
*.moc
*.pro.user
*.pro.user.*
*build-*

# Python
__pycache__/
*.py[cod]
*$py.class
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg-info/
.installed.cfg
*.egg

# Terraform
.terraform/
*.tfstate
*.tfstate.backup
*.tfvars

# Kubernetes
kubeconfig
```

**Файл: .editorconfig**
```
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.{go,mod,sum}]
indent_style = tab
indent_size = 4

[*.{py}]
indent_size = 4

[Makefile]
indent_style = tab
indent_size = 4

[*.md]
trim_trailing_whitespace = false
```

### 2.2 Базовый Docker Compose для локальной разработки

**Файл: docker-compose.yml**
```yaml
version: '3.8'

services:
  # Базы данных
  postgres:
    image: postgres:14
    environment:
      POSTGRES_USER: gameplatform
      POSTGRES_PASSWORD: gameplatform
      POSTGRES_DB: gameplatform
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U gameplatform"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:6.2
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Хранилище объектов
  minio:
    image: minio/minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: gameplatform
      MINIO_ROOT_PASSWORD: gameplatform
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # Очередь сообщений
  kafka:
    image: confluentinc/cp-kafka:7.0.0
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    healthcheck:
      test: ["CMD", "kafka-topics", "--bootstrap-server", "localhost:9092", "--list"]
      interval: 30s
      timeout: 10s
      retries: 3

  zookeeper:
    image: confluentinc/cp-zookeeper:7.0.0
    ports:
      - "2181:2181"
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    healthcheck:
      test: ["CMD", "zkServer.sh", "status"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Сервисы для разработки
  jaeger:
    image: jaegertracing/all-in-one:1.30
    ports:
      - "5775:5775/udp"
      - "6831:6831/udp"
      - "6832:6832/udp"
      - "5778:5778"
      - "16686:16686"
      - "14268:14268"
      - "14250:14250"
      - "9411:9411"
    environment:
      COLLECTOR_ZIPKIN_HOST_PORT: 9411

  prometheus:
    image: prom/prometheus:v2.33.1
    ports:
      - "9090:9090"
    volumes:
      - ./infrastructure/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus

  grafana:
    image: grafana/grafana:8.4.3
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  postgres_data:
  redis_data:
  minio_data:
  prometheus_data:
  grafana_data:
```

### 2.3 Базовая структура для API Gateway

**Файл: services/api-gateway/config/gateway.yml**
```yaml
server:
  port: 8080
  read_timeout: 5s
  write_timeout: 10s
  idle_timeout: 120s

security:
  jwt:
    public_key_path: "./keys/public.pem"
    issuer: "gameplatform.ru"
    audience: "api.gameplatform.ru"

cors:
  allowed_origins:
    - "https://gameplatform.ru"
    - "https://www.gameplatform.ru"
    - "http://localhost:3000"
  allowed_methods:
    - "GET"
    - "POST"
    - "PUT"
    - "DELETE"
    - "PATCH"
    - "OPTIONS"
  allowed_headers:
    - "Authorization"
    - "Content-Type"
  allow_credentials: true
  max_age: 300

rate_limit:
  requests_per_minute: 100
  burst: 50
  client_id_header: "X-Client-ID"
  enable_ip_throttling: true

services:
  account:
    host: "account-service"
    port: 8081
    timeout: 5s
    circuit_breaker:
      max_requests: 100
      interval: 60s
      timeout: 10s
      error_threshold: 50
  
  auth:
    host: "auth-service"
    port: 8082
    timeout: 3s
    circuit_breaker:
      max_requests: 200
      interval: 60s
      timeout: 5s
      error_threshold: 50

  catalog:
    host: "catalog-service"
    port: 8083
    timeout: 5s
    circuit_breaker:
      max_requests: 150
      interval: 60s
      timeout: 10s
      error_threshold: 50

  # Остальные сервисы...

routes:
  - path: "/v1/auth/*"
    service: "auth"
    strip_prefix: true
    methods:
      - "POST"
      - "OPTIONS"
    auth_required: false

  - path: "/v1/users/*"
    service: "account"
    strip_prefix: false
    methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
      - "PATCH"
      - "OPTIONS"
    auth_required: true
    roles:
      - "user"
      - "admin"

  - path: "/v1/games"
    service: "catalog"
    strip_prefix: false
    methods:
      - "GET"
      - "OPTIONS"
    auth_required: false
    
  # Остальные маршруты...

observability:
  metrics:
    enabled: true
    path: "/metrics"
  tracing:
    enabled: true
    jaeger_endpoint: "http://jaeger:14268/api/traces"
    service_name: "api-gateway"
    sample_rate: 0.1
  health:
    enabled: true
    path: "/health"
```

## 3. Настройка CI/CD

### 3.1 GitHub Actions для сборки и тестирования

**Файл: .github/workflows/ci.yml**
```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        if: contains(github.event.pull_request.labels.*.name, 'service')
        uses: actions/setup-go@v3
        with:
          go-version: '1.19'

      - name: Set up Node.js
        if: contains(github.event.pull_request.labels.*.name, 'frontend')
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Lint Go
        if: contains(github.event.pull_request.labels.*.name, 'service')
        run: |
          cd services
          go mod download
          go install golang.org/x/lint/golint@latest
          golint -set_exit_status ./...

      - name: Lint TypeScript
        if: contains(github.event.pull_request.labels.*.name, 'frontend')
        run: |
          cd web
          npm install
          npm run lint

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        if: contains(github.event.pull_request.labels.*.name, 'service')
        uses: actions/setup-go@v3
        with:
          go-version: '1.19'

      - name: Set up Node.js
        if: contains(github.event.pull_request.labels.*.name, 'frontend')
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Test Go
        if: contains(github.event.pull_request.labels.*.name, 'service')
        run: |
          cd services
          go mod download
          go test ./... -v -race -coverprofile=coverage.out
          go tool cover -func=coverage.out

      - name: Test TypeScript
        if: contains(github.event.pull_request.labels.*.name, 'frontend')
        run: |
          cd web
          npm install
          npm test

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Registry
        uses: docker/login-action@v2
        with:
          registry: registry.gameplatform.ru
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push service
        if: contains(github.event.pull_request.labels.*.name, 'service')
        uses: docker/build-push-action@v3
        with:
          context: ./services/${{ github.event.pull_request.title }}
          push: true
          tags: registry.gameplatform.ru/${{ github.event.pull_request.title }}:${{ github.sha }}

      - name: Build and push web
        if: contains(github.event.pull_request.labels.*.name, 'frontend')
        uses: docker/build-push-action@v3
        with:
          context: ./web
          push: true
          tags: registry.gameplatform.ru/web:${{ github.sha }}
```

### 3.2 Makefile для локальной разработки

**Файл: Makefile**
```makefile
.PHONY: all build test clean docker-up docker-down migrate-up migrate-down

# Переменные
DOCKER_COMPOSE = docker-compose
GO = go
MIGRATIONS_DIR = ./migrations

# Основные команды
all: build

build:
	@echo "Сборка всех сервисов..."
	@cd services && $(GO) build ./...
	@cd web && npm run build
	@cd client && cmake --build build

test:
	@echo "Запуск тестов..."
	@cd services && $(GO) test ./...
	@cd web && npm test
	@cd client && cmake --build build --target test

clean:
	@echo "Очистка артефактов сборки..."
	@cd services && find . -name "bin" -type d -exec rm -rf {} +
	@cd web && rm -rf dist node_modules
	@cd client && rm -rf build

# Docker команды
docker-up:
	@echo "Запуск локальной инфраструктуры..."
	@$(DOCKER_COMPOSE) up -d

docker-down:
	@echo "Остановка локальной инфраструктуры..."
	@$(DOCKER_COMPOSE) down

# Миграции
migrate-up:
	@echo "Применение миграций..."
	@cd services/account-service && $(GO) run ./cmd/migrate/main.go up
	@cd services/catalog-service && $(GO) run ./cmd/migrate/main.go up
	@cd services/payment-service && $(GO) run ./cmd/migrate/main.go up
	# Остальные сервисы

migrate-down:
	@echo "Откат миграций..."
	@cd services/account-service && $(GO) run ./cmd/migrate/main.go down
	@cd services/catalog-service && $(GO) run ./cmd/migrate/main.go down
	@cd services/payment-service && $(GO) run ./cmd/migrate/main.go down
	# Остальные сервисы

# Шаблоны для создания новых сервисов
new-service:
	@echo "Создание нового сервиса: $(name)"
	@mkdir -p services/$(name)/cmd/server
	@mkdir -p services/$(name)/internal/config
	@mkdir -p services/$(name)/internal/domain
	@mkdir -p services/$(name)/internal/repository
	@mkdir -p services/$(name)/internal/service
	@mkdir -p services/$(name)/internal/api/rest
	@mkdir -p services/$(name)/internal/api/grpc
	@mkdir -p services/$(name)/migrations
	@mkdir -p services/$(name)/test
	@touch services/$(name)/Dockerfile
	@touch services/$(name)/go.mod
	@touch services/$(name)/README.md
	@echo "Сервис $(name) создан"
```

## 4. Конфигурационные файлы

### 4.1 Базовый конфигурационный файл для микросервисов

**Файл: services/account-service/internal/config/config.go**
```go
package config

import (
	"fmt"
	"os"
	"time"

	"github.com/spf13/viper"
)

// Config содержит все настройки сервиса
type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	Redis    RedisConfig
	Kafka    KafkaConfig
	Logging  LoggingConfig
	Metrics  MetricsConfig
	Tracing  TracingConfig
	Security SecurityConfig
}

// ServerConfig содержит настройки HTTP сервера
type ServerConfig struct {
	Port         int
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
	IdleTimeout  time.Duration
}

// DatabaseConfig содержит настройки базы данных
type DatabaseConfig struct {
	Host     string
	Port     int
	User     string
	Password string
	DBName   string
	SSLMode  string
	MaxConns int
	MaxIdle  int
}

// RedisConfig содержит настройки Redis
type RedisConfig struct {
	Host     string
	Port     int
	Password string
	DB       int
}

// KafkaConfig содержит настройки Kafka
type KafkaConfig struct {
	Brokers  []string
	GroupID  string
	Topics   map[string]string
	Consumer KafkaConsumerConfig
	Producer KafkaProducerConfig
}

// KafkaConsumerConfig содержит настройки потребителя Kafka
type KafkaConsumerConfig struct {
	FetchMinBytes int
	FetchMaxWait  time.Duration
}

// KafkaProducerConfig содержит настройки производителя Kafka
type KafkaProducerConfig struct {
	MaxMessageBytes int
	Timeout         time.Duration
}

// LoggingConfig содержит настройки логирования
type LoggingConfig struct {
	Level      string
	Format     string
	Output     string
	TimeFormat string
}

// MetricsConfig содержит настройки метрик
type MetricsConfig struct {
	Enabled bool
	Path    string
}

// TracingConfig содержит настройки трассировки
type TracingConfig struct {
	Enabled        bool
	JaegerEndpoint string
	ServiceName    string
	SampleRate     float64
}

// SecurityConfig содержит настройки безопасности
type SecurityConfig struct {
	JWTPublicKey string
	JWTIssuer    string
	JWTAudience  string
}

// Load загружает конфигурацию из файла и переменных окружения
func Load(path string) (*Config, error) {
	v := viper.New()

	// Настройки по умолчанию
	v.SetDefault("server.port", 8080)
	v.SetDefault("server.readTimeout", "5s")
	v.SetDefault("server.writeTimeout", "10s")
	v.SetDefault("server.idleTimeout", "120s")

	v.SetDefault("database.host", "postgres")
	v.SetDefault("database.port", 5432)
	v.SetDefault("database.user", "gameplatform")
	v.SetDefault("database.password", "gameplatform")
	v.SetDefault("database.dbname", "gameplatform")
	v.SetDefault("database.sslmode", "disable")
	v.SetDefault("database.maxConns", 20)
	v.SetDefault("database.maxIdle", 5)

	v.SetDefault("redis.host", "redis")
	v.SetDefault("redis.port", 6379)
	v.SetDefault("redis.password", "")
	v.SetDefault("redis.db", 0)

	v.SetDefault("kafka.brokers", []string{"kafka:29092"})
	v.SetDefault("kafka.groupID", "account-service")
	v.SetDefault("kafka.topics.userCreated", "user.created")
	v.SetDefault("kafka.consumer.fetchMinBytes", 1)
	v.SetDefault("kafka.consumer.fetchMaxWait", "250ms")
	v.SetDefault("kafka.producer.maxMessageBytes", 1000000)
	v.SetDefault("kafka.producer.timeout", "10s")

	v.SetDefault("logging.level", "info")
	v.SetDefault("logging.format", "json")
	v.SetDefault("logging.output", "stdout")
	v.SetDefault("logging.timeFormat", "2006-01-02T15:04:05Z07:00")

	v.SetDefault("metrics.enabled", true)
	v.SetDefault("metrics.path", "/metrics")

	v.SetDefault("tracing.enabled", true)
	v.SetDefault("tracing.jaegerEndpoint", "http://jaeger:14268/api/traces")
	v.SetDefault("tracing.serviceName", "account-service")
	v.SetDefault("tracing.sampleRate", 0.1)

	v.SetDefault("security.jwtPublicKey", "./keys/public.pem")
	v.SetDefault("security.jwtIssuer", "gameplatform.ru")
	v.SetDefault("security.jwtAudience", "api.gameplatform.ru")

	// Загрузка из файла
	if path != "" {
		v.SetConfigFile(path)
		if err := v.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("ошибка чтения конфигурационного файла: %w", err)
		}
	}

	// Загрузка из переменных окружения
	v.SetEnvPrefix("APP")
	v.AutomaticEnv()

	var cfg Config
	if err := v.Unmarshal(&cfg); err != nil {
		return nil, fmt.Errorf("ошибка демаршалинга конфигурации: %w", err)
	}

	return &cfg, nil
}
```

# Настройка базы данных и миграций

## 1. Выбор инструментария для миграций

### 1.1 Инструмент миграций

Для миграций базы данных будем использовать [golang-migrate](https://github.com/golang-migrate/migrate) из-за его простоты, поддержки различных СУБД и возможности использования как через CLI, так и программно.

**Установка golang-migrate CLI**
```bash
# Linux
curl -L https://github.com/golang-migrate/migrate/releases/download/v4.15.2/migrate.linux-amd64.tar.gz | tar xvz
sudo mv migrate /usr/local/bin/migrate

# macOS через Homebrew
brew install golang-migrate

# Windows через scoop
scoop install migrate
```

**Добавление зависимости в Go-модуль**
```bash
go get -u github.com/golang-migrate/migrate/v4
go get -u github.com/golang-migrate/migrate/v4/database/postgres
go get -u github.com/golang-migrate/migrate/v4/source/file
```

### 1.2 Настройка клиента базы данных

Для работы с PostgreSQL будем использовать [pgx](https://github.com/jackc/pgx) - производительную библиотеку для работы с PostgreSQL из Go.

**Добавление зависимости**
```bash
go get -u github.com/jackc/pgx/v4
go get -u github.com/jackc/pgx/v4/pgxpool
```

## 2. Структура миграций

### 2.1 Организация файлов миграций

Миграции будут организованы в каждом сервисе отдельно в директории `migrations`. Имя файла должно соответствовать формату: `{версия}_{описание}.{up|down}.sql`.

**Пример структуры файлов**
```
migrations/
├── 000001_create_users_table.up.sql
├── 000001_create_users_table.down.sql
├── 000002_add_email_verification.up.sql
├── 000002_add_email_verification.down.sql
├── 000003_create_profiles_table.up.sql
├── 000003_create_profiles_table.down.sql
```

### 2.2 Утилита для выполнения миграций

**Файл: services/account-service/cmd/migrate/main.go**
```go
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() {
	var migrationsPath = flag.String("path", "migrations", "Путь к директории с миграциями")
	var dbURL = flag.String("db", "", "URL базы данных (postgres://username:password@host:port/dbname?sslmode=disable)")
	flag.Parse()

	// Если URL базы данных не указан, пытаемся получить из переменной окружения
	if *dbURL == "" {
		*dbURL = os.Getenv("DATABASE_URL")
		if *dbURL == "" {
			log.Fatal("Не указан URL базы данных. Используйте флаг -db или установите переменную окружения DATABASE_URL")
		}
	}

	// Определение команды (up или down)
	args := flag.Args()
	if len(args) == 0 {
		log.Fatal("Не указана команда. Используйте 'up' или 'down'")
	}
	command := args[0]

	// Создание экземпляра migrate
	m, err := migrate.New(
		fmt.Sprintf("file://%s", *migrationsPath),
		*dbURL,
	)
	if err != nil {
		log.Fatalf("Ошибка создания экземпляра migrate: %v", err)
	}

	// Включение логирования
	m.Log = &MigrateLogger{}

	// Выполнение команды
	switch command {
	case "up":
		err = m.Up()
		if err != nil && err != migrate.ErrNoChange {
			log.Fatalf("Ошибка выполнения миграций up: %v", err)
		}
		log.Println("Миграции up успешно выполнены")

	case "down":
		err = m.Down()
		if err != nil && err != migrate.ErrNoChange {
			log.Fatalf("Ошибка выполнения миграций down: %v", err)
		}
		log.Println("Миграции down успешно выполнены")

	case "version":
		version, dirty, err := m.Version()
		if err != nil {
			log.Fatalf("Ошибка получения версии миграций: %v", err)
		}
		log.Printf("Текущая версия: %d, dirty: %v", version, dirty)

	default:
		log.Fatalf("Неизвестная команда: %s", command)
	}
}

// MigrateLogger - простой логгер для migrate
type MigrateLogger struct{}

// Printf - метод для логирования сообщений migrate
func (l *MigrateLogger) Printf(format string, v ...interface{}) {
	log.Printf(format, v...)
}

// Verbose - обязательный метод интерфейса Logger
func (l *MigrateLogger) Verbose() bool {
	return true
}
```

## 3. Примеры файлов миграций

### 3.1 Пример миграций для сервиса пользователей

**Файл: services/account-service/migrations/000001_create_users_table.up.sql**
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) NOT NULL UNIQUE,
    phone_number VARCHAR(20) UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    salt VARCHAR(32) NOT NULL,
    username VARCHAR(50) NOT NULL UNIQUE,
    display_name VARCHAR(100),
    registration_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_login_date TIMESTAMP WITH TIME ZONE,
    account_status VARCHAR(20) NOT NULL DEFAULT 'active',
    two_factor_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    profile_picture_url VARCHAR(255),
    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    verification_token VARCHAR(64),
    password_reset_token VARCHAR(64),
    password_reset_expiry TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_account_status ON users(account_status);

-- Таблица для хранения сессий пользователей
CREATE TABLE user_sessions (
    session_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    refresh_token VARCHAR(255) NOT NULL,
    user_agent VARCHAR(255),
    ip_address VARCHAR(45),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT uk_refresh_token UNIQUE (refresh_token)
);

CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_expires_at ON user_sessions(expires_at);

-- Триггер для обновления updated_at при изменении записи
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_timestamp
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();
```

**Файл: services/account-service/migrations/000001_create_users_table.down.sql**
```sql
DROP TRIGGER IF EXISTS update_users_timestamp ON users;
DROP FUNCTION IF EXISTS update_timestamp();
DROP TABLE IF EXISTS user_sessions;
DROP TABLE IF EXISTS users;
```

**Файл: services/account-service/migrations/000002_create_user_profiles.up.sql**
```sql
CREATE TABLE user_profiles (
    profile_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    real_name VARCHAR(100),
    country VARCHAR(2),
    city VARCHAR(100),
    birth_date DATE,
    biography TEXT,
    public_profile BOOLEAN NOT NULL DEFAULT TRUE,
    social_links JSONB,
    preferences JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT uk_user_profile UNIQUE (user_id)
);

CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
CREATE INDEX idx_user_profiles_country ON user_profiles(country);

-- Триггер для обновления updated_at при изменении записи
CREATE TRIGGER update_user_profiles_timestamp
BEFORE UPDATE ON user_profiles
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();
```

**Файл: services/account-service/migrations/000002_create_user_profiles.down.sql**
```sql
DROP TRIGGER IF EXISTS update_user_profiles_timestamp ON user_profiles;
DROP TABLE IF EXISTS user_profiles;
```

### 3.2 Пример миграций для сервиса каталога игр

**Файл: services/catalog-service/migrations/000001_create_games_table.up.sql**
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE games (
    game_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(255) NOT NULL,
    developer_id UUID NOT NULL,
    publisher_id UUID NOT NULL,
    release_date TIMESTAMP WITH TIME ZONE,
    base_price DECIMAL(10, 2) NOT NULL,
    discount_price DECIMAL(10, 2),
    discount_start_date TIMESTAMP WITH TIME ZONE,
    discount_end_date TIMESTAMP WITH TIME ZONE,
    description TEXT,
    short_description VARCHAR(500),
    system_requirements JSONB,
    tags TEXT[],
    genres TEXT[],
    age_rating VARCHAR(10),
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    total_reviews INTEGER NOT NULL DEFAULT 0,
    positive_reviews_percent DECIMAL(5, 2) NOT NULL DEFAULT 0.00
);

CREATE INDEX idx_games_title ON games(title);
CREATE INDEX idx_games_developer_id ON games(developer_id);
CREATE INDEX idx_games_publisher_id ON games(publisher_id);
CREATE INDEX idx_games_status ON games(status);
CREATE INDEX idx_games_release_date ON games(release_date);
CREATE INDEX idx_games_tags ON games USING GIN(tags);
CREATE INDEX idx_games_genres ON games USING GIN(genres);

-- Создание таблицы для версий игр
CREATE TABLE game_versions (
    version_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    game_id UUID NOT NULL REFERENCES games(game_id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    build_id VARCHAR(50) NOT NULL,
    release_notes TEXT,
    release_date TIMESTAMP WITH TIME ZONE,
    size_mb INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    created_by UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT uk_game_version UNIQUE (game_id, version_number)
);

CREATE INDEX idx_game_versions_game_id ON game_versions(game_id);
CREATE INDEX idx_game_versions_status ON game_versions(status);

-- Создание таблицы для медиафайлов игр
CREATE TABLE game_assets (
    asset_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    game_id UUID NOT NULL REFERENCES games(game_id) ON DELETE CASCADE,
    asset_type VARCHAR(20) NOT NULL,
    url VARCHAR(255) NOT NULL,
    caption VARCHAR(255),
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_game_assets_game_id ON game_assets(game_id);
CREATE INDEX idx_game_assets_asset_type ON game_assets(asset_type);

-- Триггер для обновления updated_at при изменении записи
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_games_timestamp
BEFORE UPDATE ON games
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();

CREATE TRIGGER update_game_versions_timestamp
BEFORE UPDATE ON game_versions
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();

CREATE TRIGGER update_game_assets_timestamp
BEFORE UPDATE ON game_assets
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();
```

**Файл: services/catalog-service/migrations/000001_create_games_table.down.sql**
```sql
DROP TRIGGER IF EXISTS update_games_timestamp ON games;
DROP TRIGGER IF EXISTS update_game_versions_timestamp ON game_versions;
DROP TRIGGER IF EXISTS update_game_assets_timestamp ON game_assets;
DROP FUNCTION IF EXISTS update_timestamp();
DROP TABLE IF EXISTS game_assets;
DROP TABLE IF EXISTS game_versions;
DROP TABLE IF EXISTS games;
```

## 4. Настройка подключения к базе данных

### 4.1 Структура репозитория для подключения к базе данных

**Файл: services/account-service/internal/repository/postgres/connection.go**
```go
package postgres

import (
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/sirupsen/logrus"
)

// Config содержит настройки подключения к базе данных PostgreSQL
type Config struct {
	Host     string
	Port     int
	User     string
	Password string
	DBName   string
	SSLMode  string
	MaxConns int
	MaxIdle  int
}

// NewConnection создает новый пул соединений с базой данных
func NewConnection(cfg Config, logger *logrus.Logger) (*pgxpool.Pool, error) {
	// Формирование строки подключения
	dsn := fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=%s&pool_max_conns=%d",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.DBName, cfg.SSLMode, cfg.MaxConns,
	)

	// Настройка конфигурации пула
	poolConfig, err := pgxpool.ParseConfig(dsn)
	if err != nil {
		return nil, fmt.Errorf("ошибка парсинга конфигурации пула: %w", err)
	}

	// Установка дополнительных настроек пула
	poolConfig.MaxConns = int32(cfg.MaxConns)
	poolConfig.MinConns = int32(cfg.MaxIdle)
	poolConfig.MaxConnLifetime = 30 * time.Minute
	poolConfig.MaxConnIdleTime = 5 * time.Minute
	poolConfig.HealthCheckPeriod = 1 * time.Minute

	// Создание пула соединений
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	pool, err := pgxpool.ConnectConfig(ctx, poolConfig)
	if err != nil {
		return nil, fmt.Errorf("ошибка подключения к базе данных: %w", err)
	}

	// Проверка соединения
	if err := pool.Ping(ctx); err != nil {
		return nil, fmt.Errorf("ошибка проверки соединения с базой данных: %w", err)
	}

	logger.Info("Успешное подключение к базе данных PostgreSQL")
	return pool, nil
}

// CloseConnection закрывает соединение с базой данных
func CloseConnection(pool *pgxpool.Pool, logger *logrus.Logger) {
	if pool != nil {
		pool.Close()
		logger.Info("Соединение с базой данных закрыто")
	}
}
```

### 4.2 Базовый интерфейс репозитория

**Файл: services/account-service/internal/repository/repository.go**
```go
package repository

import (
	"context"

	"github.com/gameplatform/account-service/internal/domain"
)

// UserRepository определяет интерфейс для работы с пользователями в хранилище данных
type UserRepository interface {
	// Create создает нового пользователя
	Create(ctx context.Context, user domain.User) (domain.User, error)
	
	// GetByID возвращает пользователя по ID
	GetByID(ctx context.Context, userID string) (domain.User, error)
	
	// GetByEmail возвращает пользователя по email
	GetByEmail(ctx context.Context, email string) (domain.User, error)
	
	// GetByUsername возвращает пользователя по имени пользователя
	GetByUsername(ctx context.Context, username string) (domain.User, error)
	
	// Update обновляет данные пользователя
	Update(ctx context.Context, user domain.User) error
	
	// Delete удаляет пользователя по ID
	Delete(ctx context.Context, userID string) error
	
	// List возвращает список пользователей с пагинацией
	List(ctx context.Context, limit, offset int) ([]domain.User, int, error)
	
	// UpdatePassword обновляет пароль пользователя
	UpdatePassword(ctx context.Context, userID, passwordHash, salt string) error
	
	// UpdateStatus обновляет статус пользователя
	UpdateStatus(ctx context.Context, userID, status string) error
	
	// VerifyEmail подтверждает email пользователя
	VerifyEmail(ctx context.Context, userID string) error
	
	// GetByVerificationToken возвращает пользователя по токену верификации
	GetByVerificationToken(ctx context.Context, token string) (domain.User, error)
	
	// GetByPasswordResetToken возвращает пользователя по токену сброса пароля
	GetByPasswordResetToken(ctx context.Context, token string) (domain.User, error)
}

// ProfileRepository определяет интерфейс для работы с профилями пользователей
type ProfileRepository interface {
	// Create создает новый профиль пользователя
	Create(ctx context.Context, profile domain.Profile) (domain.Profile, error)
	
	// GetByUserID возвращает профиль по ID пользователя
	GetByUserID(ctx context.Context, userID string) (domain.Profile, error)
	
	// Update обновляет профиль пользователя
	Update(ctx context.Context, profile domain.Profile) error
	
	// Delete удаляет профиль пользователя
	Delete(ctx context.Context, profileID string) error
}

// SessionRepository определяет интерфейс для работы с сессиями пользователей
type SessionRepository interface {
	// Create создает новую сессию пользователя
	Create(ctx context.Context, session domain.Session) (domain.Session, error)
	
	// GetByID возвращает сессию по ID
	GetByID(ctx context.Context, sessionID string) (domain.Session, error)
	
	// GetByRefreshToken возвращает сессию по refresh токену
	GetByRefreshToken(ctx context.Context, refreshToken string) (domain.Session, error)
	
	// Delete удаляет сессию по ID
	Delete(ctx context.Context, sessionID string) error
	
	// DeleteByUserID удаляет все сессии пользователя
	DeleteByUserID(ctx context.Context, userID string) error
	
	// DeleteExpired удаляет все истекшие сессии
	DeleteExpired(ctx context.Context) (int, error)
}

// Repository объединяет все репозитории
type Repository struct {
	User    UserRepository
	Profile ProfileRepository
	Session SessionRepository
}
```

### 4.3 Реализация пользовательского репозитория

**Файл: services/account-service/internal/repository/postgres/user_repository.go**
```go
package postgres

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/sirupsen/logrus"

	"github.com/gameplatform/account-service/internal/domain"
)

// Возможные ошибки
var (
	ErrUserNotFound     = errors.New("пользователь не найден")
	ErrEmailExists      = errors.New("email уже существует")
	ErrUsernameExists   = errors.New("имя пользователя уже существует")
	ErrPhoneExists      = errors.New("номер телефона уже существует")
	ErrInvalidUserID    = errors.New("некорректный ID пользователя")
	ErrInvalidEmail     = errors.New("некорректный email")
	ErrInvalidUsername  = errors.New("некорректное имя пользователя")
	ErrTokenNotFound    = errors.New("токен не найден")
	ErrTokenExpired     = errors.New("токен истек")
)

// UserRepo реализует интерфейс UserRepository для PostgreSQL
type UserRepo struct {
	db     *pgxpool.Pool
	logger *logrus.Logger
}

// NewUserRepository создает новый экземпляр UserRepo
func NewUserRepository(db *pgxpool.Pool, logger *logrus.Logger) *UserRepo {
	return &UserRepo{
		db:     db,
		logger: logger,
	}
}

// Create создает нового пользователя
func (r *UserRepo) Create(ctx context.Context, user domain.User) (domain.User, error) {
	query := `
		INSERT INTO users (
			email, phone_number, password_hash, salt, username, display_name,
			account_status, verification_token
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
		) RETURNING user_id, registration_date, created_at, updated_at
	`

	// Выполнение запроса
	err := r.db.QueryRow(
		ctx,
		query,
		user.Email,
		user.PhoneNumber,
		user.PasswordHash,
		user.Salt,
		user.Username,
		user.DisplayName,
		user.AccountStatus,
		user.VerificationToken,
	).Scan(
		&user.UserID,
		&user.RegistrationDate,
		&user.CreatedAt,
		&user.UpdatedAt,
	)

	if err != nil {
		// Проверка на нарушение уникальности
		if pgErr, ok := err.(*pgx.PgError); ok {
			switch pgErr.ConstraintName {
			case "users_email_key":
				return domain.User{}, ErrEmailExists
			case "users_username_key":
				return domain.User{}, ErrUsernameExists
			case "users_phone_number_key":
				return domain.User{}, ErrPhoneExists
			}
		}
		return domain.User{}, fmt.Errorf("ошибка создания пользователя: %w", err)
	}

	return user, nil
}

// GetByID возвращает пользователя по ID
func (r *UserRepo) GetByID(ctx context.Context, userID string) (domain.User, error) {
	query := `
		SELECT user_id, email, phone_number, password_hash, salt, username, display_name,
		       registration_date, last_login_date, account_status, two_factor_enabled,
		       profile_picture_url, is_verified, verification_token, password_reset_token,
		       password_reset_expiry, created_at, updated_at
		FROM users
		WHERE user_id = $1
	`

	var user domain.User
	err := r.db.QueryRow(ctx, query, userID).Scan(
		&user.UserID,
		&user.Email,
		&user.PhoneNumber,
		&user.PasswordHash,
		&user.Salt,
		&user.Username,
		&user.DisplayName,
		&user.RegistrationDate,
		&user.LastLoginDate,
		&user.AccountStatus,
		&user.TwoFactorEnabled,
		&user.ProfilePictureURL,
		&user.IsVerified,
		&user.VerificationToken,
		&user.PasswordResetToken,
		&user.PasswordResetExpiry,
		&user.CreatedAt,
		&user.UpdatedAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return domain.User{}, ErrUserNotFound
		}
		return domain.User{}, fmt.Errorf("ошибка получения пользователя по ID: %w", err)
	}

	return user, nil
}

// GetByEmail возвращает пользователя по email
func (r *UserRepo) GetByEmail(ctx context.Context, email string) (domain.User, error) {
	query := `
		SELECT user_id, email, phone_number, password_hash, salt, username, display_name,
		       registration_date, last_login_date, account_status, two_factor_enabled,
		       profile_picture_url, is_verified, verification_token, password_reset_token,
		       password_reset_expiry, created_at, updated_at
		FROM users
		WHERE email = $1
	`

	var user domain.User
	err := r.db.QueryRow(ctx, query, email).Scan(
		&user.UserID,
		&user.Email,
		&user.PhoneNumber,
		&user.PasswordHash,
		&user.Salt,
		&user.Username,
		&user.DisplayName,
		&user.RegistrationDate,
		&user.LastLoginDate,
		&user.AccountStatus,
		&user.TwoFactorEnabled,
		&user.ProfilePictureURL,
		&user.IsVerified,
		&user.VerificationToken,
		&user.PasswordResetToken,
		&user.PasswordResetExpiry,
		&user.CreatedAt,
		&user.UpdatedAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return domain.User{}, ErrUserNotFound
		}
		return domain.User{}, fmt.Errorf("ошибка получения пользователя по email: %w", err)
	}

	return user, nil
}

// Update обновляет данные пользователя
func (r *UserRepo) Update(ctx context.Context, user domain.User) error {
	query := `
		UPDATE users
		SET phone_number = $1,
		    display_name = $2,
		    account_status = $3,
		    two_factor_enabled = $4,
		    profile_picture_url = $5,
		    last_login_date = $6
		WHERE user_id = $7
	`

	result, err := r.db.Exec(
		ctx,
		query,
		user.PhoneNumber,
		user.DisplayName,
		user.AccountStatus,
		user.TwoFactorEnabled,
		user.ProfilePictureURL,
		user.LastLoginDate,
		user.UserID,
	)

	if err != nil {
		return fmt.Errorf("ошибка обновления пользователя: %w", err)
	}

	if result.RowsAffected() == 0 {
		return ErrUserNotFound
	}

	return nil
}

// UpdatePassword обновляет пароль пользователя
func (r *UserRepo) UpdatePassword(ctx context.Context, userID, passwordHash, salt string) error {
	query := `
		UPDATE users
		SET password_hash = $1,
		    salt = $2,
		    password_reset_token = NULL,
		    password_reset_expiry = NULL
		WHERE user_id = $3
	`

	result, err := r.db.Exec(ctx, query, passwordHash, salt, userID)
	if err != nil {
		return fmt.Errorf("ошибка обновления пароля: %w", err)
	}

	if result.RowsAffected() == 0 {
		return ErrUserNotFound
	}

	return nil
}

// VerifyEmail подтверждает email пользователя
func (r *UserRepo) VerifyEmail(ctx context.Context, userID string) error {
	query := `
		UPDATE users
		SET is_verified = TRUE,
		    verification_token = NULL
		WHERE user_id = $1
	`

	result, err := r.db.Exec(ctx, query, userID)
	if err != nil {
		return fmt.Errorf("ошибка подтверждения email: %w", err)
	}

	if result.RowsAffected() == 0 {
		return ErrUserNotFound
	}

	return nil
}

// GetByVerificationToken возвращает пользователя по токену верификации
func (r *UserRepo) GetByVerificationToken(ctx context.Context, token string) (domain.User, error) {
	query := `
		SELECT user_id, email, phone_number, password_hash, salt, username, display_name,
		       registration_date, last_login_date, account_status, two_factor_enabled,
		       profile_picture_url, is_verified, verification_token, password_reset_token,
		       password_reset_expiry, created_at, updated_at
		FROM users
		WHERE verification_token = $1
	`

	var user domain.User
	err := r.db.QueryRow(ctx, query, token).Scan(
		&user.UserID,
		&user.Email,
		&user.PhoneNumber,
		&user.PasswordHash,
		&user.Salt,
		&user.Username,
		&user.DisplayName,
		&user.RegistrationDate,
		&user.LastLoginDate,
		&user.AccountStatus,
		&user.TwoFactorEnabled,
		&user.ProfilePictureURL,
		&user.IsVerified,
		&user.VerificationToken,
		&user.PasswordResetToken,
		&user.PasswordResetExpiry,
		&user.CreatedAt,
		&user.UpdatedAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return domain.User{}, ErrTokenNotFound
		}
		return domain.User{}, fmt.Errorf("ошибка получения пользователя по токену верификации: %w", err)
	}

	return user, nil
}

// Остальные методы интерфейса UserRepository...
```

## 5. Транзакции и обработка ошибок

### 5.1 Управление транзакциями

**Файл: services/account-service/internal/repository/postgres/transaction.go**
```go
package postgres

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/sirupsen/logrus"
)

// Транзакционный контекст
type txKey struct{}

// WithTransaction добавляет транзакцию в контекст
func WithTransaction(ctx context.Context, tx pgx.Tx) context.Context {
	return context.WithValue(ctx, txKey{}, tx)
}

// GetTransaction получает транзакцию из контекста
func GetTransaction(ctx context.Context) (pgx.Tx, bool) {
	tx, ok := ctx.Value(txKey{}).(pgx.Tx)
	return tx, ok
}

// TxManager управляет транзакциями
type TxManager struct {
	db     *pgxpool.Pool
	logger *logrus.Logger
}

// NewTxManager создает новый экземпляр TxManager
func NewTxManager(db *pgxpool.Pool, logger *logrus.Logger) *TxManager {
	return &TxManager{
		db:     db,
		logger: logger,
	}
}

// Begin начинает новую транзакцию
func (tm *TxManager) Begin(ctx context.Context) (context.Context, pgx.Tx, error) {
	// Проверяем, есть ли уже транзакция в контексте
	if tx, ok := GetTransaction(ctx); ok {
		return ctx, tx, nil
	}

	// Создаем новую транзакцию
	tx, err := tm.db.Begin(ctx)
	if err != nil {
		return ctx, nil, fmt.Errorf("ошибка начала транзакции: %w", err)
	}

	// Добавляем транзакцию в контекст
	return WithTransaction(ctx, tx), tx, nil
}

// RunInTransaction выполняет функцию внутри транзакции
func (tm *TxManager) RunInTransaction(ctx context.Context, fn func(context.Context) error) error {
	// Проверяем, есть ли уже транзакция в контексте
	if tx, ok := GetTransaction(ctx); ok {
		return fn(ctx)
	}

	// Начинаем новую транзакцию
	tx, err := tm.db.Begin(ctx)
	if err != nil {
		return fmt.Errorf("ошибка начала транзакции: %w", err)
	}

	// Создаем новый контекст с транзакцией
	txCtx := WithTransaction(ctx, tx)

	// Отложенный откат транзакции в случае ошибки
	defer func() {
		if p := recover(); p != nil {
			// Откатываем транзакцию при панике
			_ = tx.Rollback(ctx)
			panic(p) // Продолжаем панику
		} else if err != nil {
			// Откатываем транзакцию при ошибке
			_ = tx.Rollback(ctx)
		}
	}()

	// Выполняем функцию внутри транзакции
	err = fn(txCtx)
	if err != nil {
		// Откатываем транзакцию при ошибке
		if rbErr := tx.Rollback(ctx); rbErr != nil {
			tm.logger.WithError(rbErr).Error("Ошибка отката транзакции")
		}
		return err
	}

	// Фиксируем транзакцию при успешном выполнении
	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("ошибка фиксации транзакции: %w", err)
	}

	return nil
}

// GetDB возвращает подходящее соединение с базой данных (транзакционное или обычное)
func (tm *TxManager) GetDB(ctx context.Context) DBTX {
	if tx, ok := GetTransaction(ctx); ok {
		return tx
	}
	return tm.db
}

// DBTX интерфейс для работы с базой данных (общий для транзакций и пула)
type DBTX interface {
	Exec(ctx context.Context, sql string, arguments ...interface{}) (pgx.CommandTag, error)
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
}
```

### 5.2 Примеры использования транзакций в сервисах

**Файл: services/account-service/internal/service/user_service.go (фрагмент)**
```go
// CreateUserWithProfile создает пользователя вместе с профилем в одной транзакции
func (s *UserService) CreateUserWithProfile(ctx context.Context, user domain.User, profile domain.Profile) (domain.User, domain.Profile, error) {
	var newUser domain.User
	var newProfile domain.Profile

	// Выполняем в транзакции
	err := s.txManager.RunInTransaction(ctx, func(txCtx context.Context) error {
		// Создаем пользователя
		var err error
		newUser, err = s.userRepo.Create(txCtx, user)
		if err != nil {
			return fmt.Errorf("ошибка создания пользователя: %w", err)
		}

		// Устанавливаем ID пользователя в профиле
		profile.UserID = newUser.UserID

		// Создаем профиль
		newProfile, err = s.profileRepo.Create(txCtx, profile)
		if err != nil {
			return fmt.Errorf("ошибка создания профиля: %w", err)
		}

		// Создаем запись в таблице ролей для пользователя
		err = s.roleRepo.AssignRole(txCtx, newUser.UserID, "user")
		if err != nil {
			return fmt.Errorf("ошибка назначения роли: %w", err)
		}

		return nil
	})

	if err != nil {
		return domain.User{}, domain.Profile{}, err
	}

	return newUser, newProfile, nil
}
```

## 6. Пул подключений и управление соединениями

### 6.1 Управление пулом подключений к базе данных

**Файл: services/account-service/internal/app/app.go (фрагмент)**
```go
// App представляет собой экземпляр приложения
type App struct {
	config     *config.Config
	logger     *logrus.Logger
	db         *pgxpool.Pool
	httpServer *http.Server
	repository *repository.Repository
	services   *service.Services
	handlers   *api.Handlers
	txManager  *postgres.TxManager

	// Каналы для сигналов и отмены
	done   chan struct{}
	cancel context.CancelFunc
}

// NewApp создает новый экземпляр приложения
func NewApp(cfg *config.Config) *App {
	logger := logrus.New()
	logger.SetFormatter(&logrus.JSONFormatter{})
	level, err := logrus.ParseLevel(cfg.Logging.Level)
	if err != nil {
		level = logrus.InfoLevel
	}
	logger.SetLevel(level)

	app := &App{
		config: cfg,
		logger: logger,
		done:   make(chan struct{}),
	}

	return app
}

// Run запускает приложение
func (a *App) Run() error {
	ctx, cancel := context.WithCancel(context.Background())
	a.cancel = cancel

	// Инициализация соединения с базой данных
	dbConfig := postgres.Config{
		Host:     a.config.Database.Host,
		Port:     a.config.Database.Port,
		User:     a.config.Database.User,
		Password: a.config.Database.Password,
		DBName:   a.config.Database.DBName,
		SSLMode:  a.config.Database.SSLMode,
		MaxConns: a.config.Database.MaxConns,
		MaxIdle:  a.config.Database.MaxIdle,
	}

	var err error
	a.db, err = postgres.NewConnection(dbConfig, a.logger)
	if err != nil {
		return fmt.Errorf("ошибка подключения к базе данных: %w", err)
	}
	defer postgres.CloseConnection(a.db, a.logger)

	// Инициализация транзакционного менеджера
	a.txManager = postgres.NewTxManager(a.db, a.logger)

	// Инициализация репозиториев
	userRepo := postgres.NewUserRepository(a.db, a.logger)
	profileRepo := postgres.NewProfileRepository(a.db, a.logger)
	sessionRepo := postgres.NewSessionRepository(a.db, a.logger)

	a.repository = &repository.Repository{
		User:    userRepo,
		Profile: profileRepo,
		Session: sessionRepo,
	}

	// Инициализация сервисов
	// ...

	// Запуск HTTP сервера
	// ...

	// Ожидание сигнала завершения
	<-a.done

	// Попытка корректного завершения работы
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer shutdownCancel()

	if a.httpServer != nil {
		if err := a.httpServer.Shutdown(shutdownCtx); err != nil {
			a.logger.WithError(err).Error("Ошибка при остановке HTTP сервера")
		}
	}

	return nil
}

// Stop останавливает приложение
func (a *App) Stop() {
	a.cancel()
	close(a.done)
}
```

### 6.2 Обработка пиковых нагрузок на базу данных

**Файл: services/account-service/internal/app/middleware/db_limiter.go**
```go
package middleware

import (
	"context"
	"net/http"
	"sync/atomic"
	"time"

	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/sirupsen/logrus"
)

// DBConnectionLimiter создает middleware для ограничения нагрузки на БД при высокой загрузке
func DBConnectionLimiter(db *pgxpool.Pool, logger *logrus.Logger, maxConcurrentRequests int32) func(http.Handler) http.Handler {
	var concurrentRequests int32

	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Получаем состояние пула подключений
			stats := db.Stat()
			
			// Проверяем, не превышено ли максимальное количество одновременных запросов
			if atomic.LoadInt32(&concurrentRequests) >= maxConcurrentRequests {
				logger.Warn("Превышен лимит одновременных запросов к базе данных")
				http.Error(w, "Сервис временно перегружен, попробуйте позже", http.StatusServiceUnavailable)
				return
			}

			// Проверяем, не превышен ли порог использования соединений
			if stats.AcquiredConns() > int32(stats.MaxConns()*80/100) {
				logger.Warn("Высокая нагрузка на пул подключений к базе данных")
				
				// Для некритичных запросов можем вернуть ошибку
				if !isHighPriorityRequest(r) {
					http.Error(w, "Сервис временно перегружен, попробуйте позже", http.StatusServiceUnavailable)
					return
				}
			}

			// Увеличиваем счетчик запросов
			atomic.AddInt32(&concurrentRequests, 1)
			defer atomic.AddInt32(&concurrentRequests, -1)

			// Устанавливаем таймаут для запросов к БД
			ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
			defer cancel()

			// Продолжаем обработку запроса
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// isHighPriorityRequest определяет, является ли запрос высокоприоритетным
func isHighPriorityRequest(r *http.Request) bool {
	// Например, аутентификация и авторизация - высокоприоритетные запросы
	if r.URL.Path == "/v1/auth/login" || r.URL.Path == "/v1/auth/refresh" {
		return true
	}
	
	// GET-запросы могут иметь более низкий приоритет
	if r.Method == http.MethodGet {
		return false
	}
	
	return true
}
```

# Настройка аутентификации и базовой безопасности

## 1. Генерация ключей для JWT

### 1.1 Генерация ключевой пары RSA

Для безопасной реализации JWT используем асимметричное шифрование RSA. Это позволит разделить процессы выдачи (подписи) и проверки токенов между разными сервисами.

**Скрипт для генерации ключей:**

**Файл: scripts/generate_keys.sh**
```bash
#!/bin/bash

# Создание директории для ключей
mkdir -p ./keys

# Генерация приватного ключа RSA
openssl genpkey -algorithm RSA -out ./keys/private.pem -pkeyopt rsa_keygen_bits:2048

# Извлечение публичного ключа из приватного
openssl rsa -pubout -in ./keys/private.pem -out ./keys/public.pem

# Установка правильных прав доступа
chmod 600 ./keys/private.pem
chmod 644 ./keys/public.pem

echo "Ключи RSA успешно сгенерированы:"
echo "Приватный ключ: ./keys/private.pem"
echo "Публичный ключ: ./keys/public.pem"
```

### 1.2 Настройка Kubernetes Secrets для хранения ключей

**Файл: infrastructure/kubernetes/auth-secrets.yaml**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: jwt-keys
  namespace: gameplatform
type: Opaque
data:
  private.pem: {{ privateKeyBase64 }}
  public.pem: {{ publicKeyBase64 }}
---
apiVersion: v1
kind: Secret
metadata:
  name: auth-service-secrets
  namespace: gameplatform
type: Opaque
data:
  JWT_PRIVATE_KEY: {{ privateKeyBase64 }}
  JWT_PUBLIC_KEY: {{ publicKeyBase64 }}
  JWT_ISSUER: Z2FtZXBsYXRmb3JtLnJ1  # gameplatform.ru в base64
  JWT_AUDIENCE: YXBpLmdhbWVwbGF0Zm9ybS5ydQ==  # api.gameplatform.ru в base64
  JWT_ACCESS_TTL: MzYwMA==  # 3600 в base64 (1 час)
  JWT_REFRESH_TTL: MjU5MjAwMA==  # 2592000 в base64 (30 дней)
```

## 2. Реализация аутентификации

### 2.1 Хеширование паролей с использованием Argon2id

**Файл: services/auth-service/internal/domain/password/hasher.go**
```go
package password

import (
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"

	"golang.org/x/crypto/argon2"
)

// Параметры хеширования Argon2id
const (
	time      = 1
	memory    = 64 * 1024
	threads   = 4
	keyLength = 32
	saltLength = 16
)

var (
	ErrInvalidHash     = errors.New("неверный формат хеша пароля")
	ErrInvalidPassword = errors.New("некорректный пароль")
)

// Hasher реализует хеширование паролей
type Hasher struct{}

// NewHasher создает новый экземпляр Hasher
func NewHasher() *Hasher {
	return &Hasher{}
}

// GenerateSalt генерирует случайную соль заданной длины
func (h *Hasher) GenerateSalt() (string, error) {
	salt := make([]byte, saltLength)
	_, err := rand.Read(salt)
	if err != nil {
		return "", fmt.Errorf("ошибка генерации соли: %w", err)
	}
	return base64.StdEncoding.EncodeToString(salt), nil
}

// Hash хеширует пароль с заданной солью
func (h *Hasher) Hash(password, saltStr string) (string, error) {
	// Декодируем соль из base64
	salt, err := base64.StdEncoding.DecodeString(saltStr)
	if err != nil {
		return "", fmt.Errorf("ошибка декодирования соли: %w", err)
	}

	// Хешируем пароль с помощью Argon2id
	hash := argon2.IDKey([]byte(password), salt, time, memory, threads, keyLength)

	// Кодируем хеш в base64
	hashStr := base64.StdEncoding.EncodeToString(hash)

	// Возвращаем хеш в формате "алгоритм$параметры$соль$хеш"
	encodedHash := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
		argon2.Version, memory, time, threads,
		saltStr, hashStr)

	return encodedHash, nil
}

// Verify проверяет пароль на соответствие хешу
func (h *Hasher) Verify(password, encodedHash string) (bool, error) {
	// Разбираем хеш на составляющие
	parts := strings.Split(encodedHash, "$")
	if len(parts) != 6 {
		return false, ErrInvalidHash
	}

	// Проверяем, что алгоритм - Argon2id
	if parts[1] != "argon2id" {
		return false, ErrInvalidHash
	}

	// Извлекаем параметры хеширования
	var version int
	var mem, t, p int
	_, err := fmt.Sscanf(parts[2], "v=%d", &version)
	if err != nil {
		return false, ErrInvalidHash
	}
	_, err = fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &mem, &t, &p)
	if err != nil {
		return false, ErrInvalidHash
	}

	// Извлекаем соль и хеш
	salt := parts[4]
	hash := parts[5]

	// Пересчитываем хеш с переданным паролем
	computedHash, err := h.Hash(password, salt)
	if err != nil {
		return false, err
	}

	// Безопасное сравнение хешей
	return subtle.ConstantTimeCompare([]byte(encodedHash), []byte(computedHash)) == 1, nil
}

// GenerateHash генерирует полный хеш для нового пароля
func (h *Hasher) GenerateHash(password string) (string, string, error) {
	// Генерируем соль
	salt, err := h.GenerateSalt()
	if err != nil {
		return "", "", err
	}

	// Хешируем пароль с солью
	hash, err := h.Hash(password, salt)
	if err != nil {
		return "", "", err
	}

	return hash, salt, nil
}
```

### 2.2 Генерация и проверка JWT-токенов

**Файл: services/auth-service/internal/domain/jwt/token.go**
```go
package jwt

import (
	"crypto/rsa"
	"errors"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v4"
)

// Типы токенов
const (
	AccessToken  = "access"
	RefreshToken = "refresh"
)

// Ошибки связанные с токенами
var (
	ErrInvalidToken    = errors.New("некорректный токен")
	ErrExpiredToken    = errors.New("истекший токен")
	ErrInvalidClaims   = errors.New("некорректные утверждения в токене")
	ErrInvalidSignature = errors.New("некорректная подпись токена")
)

// Claims представляет собой утверждения в JWT токене
type Claims struct {
	jwt.RegisteredClaims
	UserID string   `json:"user_id"`
	Role   []string `json:"roles"`
	Type   string   `json:"type"`
}

// TokenManager управляет генерацией и проверкой токенов
type TokenManager struct {
	privateKey *rsa.PrivateKey
	publicKey  *rsa.PublicKey
	issuer     string
	audience   string
	accessTTL  time.Duration
	refreshTTL time.Duration
}

// NewTokenManager создает новый менеджер токенов
func NewTokenManager(
	privateKey *rsa.PrivateKey,
	publicKey *rsa.PublicKey,
	issuer string,
	audience string,
	accessTTL time.Duration,
	refreshTTL time.Duration,
) *TokenManager {
	return &TokenManager{
		privateKey: privateKey,
		publicKey:  publicKey,
		issuer:     issuer,
		audience:   audience,
		accessTTL:  accessTTL,
		refreshTTL: refreshTTL,
	}
}

// GenerateAccessToken генерирует новый access токен
func (tm *TokenManager) GenerateAccessToken(userID string, roles []string) (string, error) {
	return tm.generateToken(userID, roles, AccessToken, tm.accessTTL)
}

// GenerateRefreshToken генерирует новый refresh токен
func (tm *TokenManager) GenerateRefreshToken(userID string, roles []string) (string, error) {
	return tm.generateToken(userID, roles, RefreshToken, tm.refreshTTL)
}

// generateToken генерирует токен заданного типа
func (tm *TokenManager) generateToken(userID string, roles []string, tokenType string, ttl time.Duration) (string, error) {
	// Генерируем уникальный ID токена
	tokenID := newUUID()

	// Устанавливаем время действия токена
	now := time.Now()
	expiresAt := now.Add(ttl)

	// Формируем утверждения токена
	claims := Claims{
		RegisteredClaims: jwt.RegisteredClaims{
			Issuer:    tm.issuer,
			Subject:   userID,
			Audience:  jwt.ClaimStrings{tm.audience},
			ExpiresAt: jwt.NewNumericDate(expiresAt),
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			ID:        tokenID,
		},
		UserID: userID,
		Role:   roles,
		Type:   tokenType,
	}

	// Создаем токен с RS256 алгоритмом подписи
	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)

	// Подписываем токен приватным ключом
	return token.SignedString(tm.privateKey)
}

// ParseToken разбирает и проверяет токен
func (tm *TokenManager) ParseToken(tokenString string) (*Claims, error) {
	// Устанавливаем функцию проверки токена
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		// Проверяем, что алгоритм соответствует ожидаемому
		if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, fmt.Errorf("неожиданный метод подписи: %v", token.Header["alg"])
		}
		return tm.publicKey, nil
	})

	if err != nil {
		// Обрабатываем ошибки времени действия
		if errors.Is(err, jwt.ErrTokenExpired) {
			return nil, ErrExpiredToken
		}
		// Обрабатываем другие ошибки валидации
		return nil, fmt.Errorf("ошибка разбора токена: %w", err)
	}

	// Проверяем, что токен валиден
	if !token.Valid {
		return nil, ErrInvalidToken
	}

	// Извлекаем утверждения из токена
	claims, ok := token.Claims.(*Claims)
	if !ok {
		return nil, ErrInvalidClaims
	}

	return claims, nil
}

// Генерация UUID для токенов
func newUUID() string {
	// В реальном коде используйте библиотеку для UUID
	// Например, github.com/google/uuid
	return "token-id-123456789"
}
```

### 2.3 Обработчики аутентификации

**Файл: services/auth-service/internal/api/rest/auth_handlers.go**
```go
package rest

import (
	"encoding/json"
	"errors"
	"net/http"
	"strings"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/gameplatform/auth-service/internal/domain"
	"github.com/gameplatform/auth-service/internal/domain/jwt"
	"github.com/gameplatform/auth-service/internal/domain/password"
	"github.com/gameplatform/auth-service/internal/service"
)

// Ошибки аутентификации
var (
	ErrInvalidCredentials = errors.New("неверные учетные данные")
	ErrUserNotActive      = errors.New("пользователь не активен")
	ErrUserNotVerified    = errors.New("email не подтвержден")
	ErrRefreshTokenInvalid = errors.New("недействительный refresh токен")
)

// AuthHandler обрабатывает запросы аутентификации
type AuthHandler struct {
	authService   service.AuthService
	userService   service.UserService
	tokenManager  *jwt.TokenManager
	passwordHasher *password.Hasher
	logger        *logrus.Logger
}

// NewAuthHandler создает новый обработчик аутентификации
func NewAuthHandler(
	authService service.AuthService,
	userService service.UserService,
	tokenManager *jwt.TokenManager,
	passwordHasher *password.Hasher,
	logger *logrus.Logger,
) *AuthHandler {
	return &AuthHandler{
		authService:    authService,
		userService:    userService,
		tokenManager:   tokenManager,
		passwordHasher: passwordHasher,
		logger:         logger,
	}
}

// RegisterRoutes регистрирует маршруты аутентификации
func (h *AuthHandler) RegisterRoutes(router *http.ServeMux) {
	router.HandleFunc("/v1/auth/register", h.Register)
	router.HandleFunc("/v1/auth/login", h.Login)
	router.HandleFunc("/v1/auth/refresh", h.Refresh)
	router.HandleFunc("/v1/auth/logout", h.Logout)
	router.HandleFunc("/v1/auth/verify-email", h.VerifyEmail)
	router.HandleFunc("/v1/auth/reset-password", h.ResetPassword)
}

// Структуры запросов/ответов для аутентификации

// RegisterRequest представляет запрос на регистрацию
type RegisterRequest struct {
	Email       string `json:"email"`
	Password    string `json:"password"`
	Username    string `json:"username"`
	PhoneNumber string `json:"phone_number,omitempty"`
}

// LoginRequest представляет запрос на вход
type LoginRequest struct {
	Login       string `json:"login"` // Email или username
	Password    string `json:"password"`
	DeviceInfo  DeviceInfo `json:"device_info"`
}

// DeviceInfo представляет информацию об устройстве
type DeviceInfo struct {
	Type        string `json:"type"`
	OS          string `json:"os"`
	AppVersion  string `json:"app_version"`
}

// RefreshRequest представляет запрос на обновление токена
type RefreshRequest struct {
	RefreshToken string `json:"refresh_token"`
}

// TokenResponse представляет ответ с токенами
type TokenResponse struct {
	UserID       string `json:"user_id"`
	Username     string `json:"username"`
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
	ExpiresIn    int    `json:"expires_in"`
}

// ErrorResponse представляет ответ с ошибкой
type ErrorResponse struct {
	Error       string `json:"error"`
	Message     string `json:"message"`
	Code        string `json:"code,omitempty"`
}

// Register обрабатывает запрос на регистрацию
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) {
	// Проверяем метод запроса
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Декодируем запрос
	var req RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.respondError(w, "Invalid request", err, http.StatusBadRequest)
		return
	}

	// Валидация данных
	if err := validateRegisterRequest(req); err != nil {
		h.respondError(w, "Validation error", err, http.StatusBadRequest)
		return
	}

	// Хешируем пароль
	hash, salt, err := h.passwordHasher.GenerateHash(req.Password)
	if err != nil {
		h.respondError(w, "Password hashing error", err, http.StatusInternalServerError)
		return
	}

	// Генерируем токен верификации email
	verificationToken := generateVerificationToken()

	// Создаем пользователя
	user := domain.User{
		Email:            req.Email,
		PhoneNumber:      req.PhoneNumber,
		Username:         req.Username,
		PasswordHash:     hash,
		Salt:             salt,
		AccountStatus:    "active",
		VerificationToken: verificationToken,
	}

	// Регистрируем пользователя
	createdUser, err := h.userService.Create(r.Context(), user)
	if err != nil {
		h.respondError(w, "User creation error", err, http.StatusInternalServerError)
		return
	}

	// Отправляем письмо для верификации email
	go h.authService.SendVerificationEmail(r.Context(), createdUser)

	// Генерируем токены
	accessToken, err := h.tokenManager.GenerateAccessToken(createdUser.UserID, []string{"user"})
	if err != nil {
		h.respondError(w, "Token generation error", err, http.StatusInternalServerError)
		return
	}

	refreshToken, err := h.tokenManager.GenerateRefreshToken(createdUser.UserID, []string{"user"})
	if err != nil {
		h.respondError(w, "Token generation error", err, http.StatusInternalServerError)
		return
	}

	// Сохраняем сессию
	deviceInfo := domain.DeviceInfo{
		UserAgent: r.UserAgent(),
		IP:        getClientIP(r),
	}
	_, err = h.authService.CreateSession(r.Context(), createdUser.UserID, refreshToken, deviceInfo)
	if err != nil {
		h.respondError(w, "Session creation error", err, http.StatusInternalServerError)
		return
	}

	// Формируем ответ
	resp := TokenResponse{
		UserID:       createdUser.UserID,
		Username:     createdUser.Username,
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		ExpiresIn:    3600, // 1 час
	}

	// Отправляем ответ
	h.respondJSON(w, resp, http.StatusCreated)
}

// Login обрабатывает запрос на вход
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	// Проверяем метод запроса
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Декодируем запрос
	var req LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.respondError(w, "Invalid request", err, http.StatusBadRequest)
		return
	}

	// Находим пользователя по email или username
	var user domain.User
	var err error
	if strings.Contains(req.Login, "@") {
		user, err = h.userService.GetByEmail(r.Context(), req.Login)
	} else {
		user, err = h.userService.GetByUsername(r.Context(), req.Login)
	}

	if err != nil {
		h.respondError(w, "Invalid credentials", ErrInvalidCredentials, http.StatusUnauthorized)
		return
	}

	// Проверяем статус пользователя
	if user.AccountStatus != "active" {
		h.respondError(w, "User not active", ErrUserNotActive, http.StatusForbidden)
		return
	}

	// Проверяем пароль
	valid, err := h.passwordHasher.Verify(req.Password, user.PasswordHash)
	if err != nil || !valid {
		h.respondError(w, "Invalid credentials", ErrInvalidCredentials, http.StatusUnauthorized)
		return
	}

	// Получаем роли пользователя
	roles, err := h.userService.GetUserRoles(r.Context(), user.UserID)
	if err != nil {
		h.respondError(w, "Error getting user roles", err, http.StatusInternalServerError)
		return
	}

	// Генерируем токены
	accessToken, err := h.tokenManager.GenerateAccessToken(user.UserID, roles)
	if err != nil {
		h.respondError(w, "Token generation error", err, http.StatusInternalServerError)
		return
	}

	refreshToken, err := h.tokenManager.GenerateRefreshToken(user.UserID, roles)
	if err != nil {
		h.respondError(w, "Token generation error", err, http.StatusInternalServerError)
		return
	}

	// Сохраняем сессию
	deviceInfo := domain.DeviceInfo{
		UserAgent: r.UserAgent(),
		IP:        getClientIP(r),
		Type:      req.DeviceInfo.Type,
		OS:        req.DeviceInfo.OS,
		AppVersion: req.DeviceInfo.AppVersion,
	}
	_, err = h.authService.CreateSession(r.Context(), user.UserID, refreshToken, deviceInfo)
	if err != nil {
		h.respondError(w, "Session creation error", err, http.StatusInternalServerError)
		return
	}

	// Обновляем время последнего входа
	user.LastLoginDate = time.Now()
	err = h.userService.Update(r.Context(), user)
	if err != nil {
		h.logger.WithError(err).Error("Failed to update last login date")
		// Не возвращаем ошибку пользователю, это некритично
	}

	// Формируем ответ
	resp := TokenResponse{
		UserID:       user.UserID,
		Username:     user.Username,
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		ExpiresIn:    3600, // 1 час
	}

	// Отправляем ответ
	h.respondJSON(w, resp, http.StatusOK)
}

// Refresh обрабатывает запрос на обновление токенов
func (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {
	// Проверяем метод запроса
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Декодируем запрос
	var req RefreshRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.respondError(w, "Invalid request", err, http.StatusBadRequest)
		return
	}

	// Проверяем refresh токен
	claims, err := h.tokenManager.ParseToken(req.RefreshToken)
	if err != nil {
		h.respondError(w, "Invalid refresh token", err, http.StatusUnauthorized)
		return
	}

	// Проверяем тип токена
	if claims.Type != jwt.RefreshToken {
		h.respondError(w, "Invalid token type", ErrRefreshTokenInvalid, http.StatusUnauthorized)
		return
	}

	// Проверяем сессию в БД
	session, err := h.authService.GetSessionByRefreshToken(r.Context(), req.RefreshToken)
	if err != nil {
		h.respondError(w, "Invalid session", err, http.StatusUnauthorized)
		return
	}

	// Проверяем, что токен принадлежит пользователю
	if session.UserID != claims.UserID {
		h.respondError(w, "Token mismatch", ErrRefreshTokenInvalid, http.StatusUnauthorized)
		return
	}

	// Получаем пользователя
	user, err := h.userService.GetByID(r.Context(), claims.UserID)
	if err != nil {
		h.respondError(w, "User not found", err, http.StatusUnauthorized)
		return
	}

	// Проверяем статус пользователя
	if user.AccountStatus != "active" {
		h.respondError(w, "User not active", ErrUserNotActive, http.StatusForbidden)
		return
	}

	// Получаем роли пользователя
	roles, err := h.userService.GetUserRoles(r.Context(), user.UserID)
	if err != nil {
		h.respondError(w, "Error getting user roles", err, http.StatusInternalServerError)
		return
	}

	// Генерируем новые токены
	accessToken, err := h.tokenManager.GenerateAccessToken(user.UserID, roles)
	if err != nil {
		h.respondError(w, "Token generation error", err, http.StatusInternalServerError)
		return
	}

	newRefreshToken, err := h.tokenManager.GenerateRefreshToken(user.UserID, roles)
	if err != nil {
		h.respondError(w, "Token generation error", err, http.StatusInternalServerError)
		return
	}

	// Обновляем сессию
	deviceInfo := domain.DeviceInfo{
		UserAgent: r.UserAgent(),
		IP:        getClientIP(r),
	}
	_, err = h.authService.RefreshSession(r.Context(), session.SessionID, newRefreshToken, deviceInfo)
	if err != nil {
		h.respondError(w, "Session update error", err, http.StatusInternalServerError)
		return
	}

	// Формируем ответ
	resp := TokenResponse{
		UserID:       user.UserID,
		Username:     user.Username,
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
		ExpiresIn:    3600, // 1 час
	}

	// Отправляем ответ
	h.respondJSON(w, resp, http.StatusOK)
}

// Logout обрабатывает запрос на выход
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	// Проверяем метод запроса
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Извлекаем токен из заголовка Authorization
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		h.respondError(w, "Missing authorization header", nil, http.StatusUnauthorized)
		return
	}

	// Проверяем формат заголовка
	parts := strings.Split(authHeader, " ")
	if len(parts) != 2 || parts[0] != "Bearer" {
		h.respondError(w, "Invalid authorization header", nil, http.StatusUnauthorized)
		return
	}

	// Извлекаем токен
	token := parts[1]

	// Проверяем токен
	claims, err := h.tokenManager.ParseToken(token)
	if err != nil {
		// Игнорируем ошибку проверки, всё равно выходим
		w.WriteHeader(http.StatusNoContent)
		return
	}

	// Удаляем сессию
	err = h.authService.DeleteSession(r.Context(), claims.UserID, token)
	if err != nil {
		h.logger.WithError(err).Error("Failed to delete session")
		// Игнорируем ошибку, всё равно выходим
	}

	// Отправляем ответ 204 No Content
	w.WriteHeader(http.StatusNoContent)
}

// Вспомогательные функции

// respondJSON отправляет JSON ответ
func (h *AuthHandler) respondJSON(w http.ResponseWriter, data interface{}, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	if err := json.NewEncoder(w).Encode(data); err != nil {
		h.logger.WithError(err).Error("Failed to encode response")
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

// respondError отправляет ответ с ошибкой
func (h *AuthHandler) respondError(w http.ResponseWriter, message string, err error, statusCode int) {
	h.logger.WithError(err).Error(message)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	// Формируем ответ с ошибкой
	resp := ErrorResponse{
		Error:   message,
		Message: err.Error(),
	}

	// Добавляем код ошибки для известных ошибок
	switch {
	case errors.Is(err, ErrInvalidCredentials):
		resp.Code = "invalid_credentials"
	case errors.Is(err, ErrUserNotActive):
		resp.Code = "user_not_active"
	case errors.Is(err, ErrUserNotVerified):
		resp.Code = "user_not_verified"
	case errors.Is(err, jwt.ErrExpiredToken):
		resp.Code = "token_expired"
	case errors.Is(err, jwt.ErrInvalidToken):
		resp.Code = "invalid_token"
	}

	if err := json.NewEncoder(w).Encode(resp); err != nil {
		h.logger.WithError(err).Error("Failed to encode error response")
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

// validateRegisterRequest проверяет запрос на регистрацию
func validateRegisterRequest(req RegisterRequest) error {
	// Валидация email, пароля, имени пользователя и т.д.
	// В реальном коде здесь будет более сложная логика
	if req.Email == "" || req.Password == "" || req.Username == "" {
		return errors.New("email, password and username are required")
	}
	return nil
}

// generateVerificationToken генерирует токен для верификации email
func generateVerificationToken() string {
	// В реальном коде используйте криптостойкий генератор
	return "verification-token-123456789"
}

// getClientIP получает IP-адрес клиента
func getClientIP(r *http.Request) string {
	// Проверяем заголовки для прокси
	if ip := r.Header.Get("X-Forwarded-For"); ip != "" {
		// Берем первый IP из списка
		if i := strings.Index(ip, ","); i > 0 {
			return strings.TrimSpace(ip[:i])
		}
		return strings.TrimSpace(ip)
	}
	if ip := r.Header.Get("X-Real-IP"); ip != "" {
		return ip
	}
	// Получаем IP из RemoteAddr
	ip, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil {
		return r.RemoteAddr
	}
	return ip
}
```

## 3. Middleware для авторизации

### 3.1 Middleware для проверки JWT

**Файл: services/api-gateway/internal/middleware/auth.go**
```go
package middleware

import (
	"context"
	"errors"
	"net/http"
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/gameplatform/api-gateway/internal/domain/jwt"
)

// Ключи контекста
type contextKey string

const (
	UserIDKey = contextKey("user_id")
	RolesKey  = contextKey("roles")
)

// Ошибки авторизации
var (
	ErrMissingAuthHeader = errors.New("отсутствует заголовок авторизации")
	ErrInvalidAuthHeader = errors.New("неверный формат заголовка авторизации")
	ErrInvalidToken      = errors.New("недействительный токен")
	ErrInsufficientPerms = errors.New("недостаточно прав")
)

// AuthMiddleware проверяет JWT токен и добавляет информацию о пользователе в контекст
func AuthMiddleware(tokenManager *jwt.TokenManager, logger *logrus.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Извлекаем токен из заголовка
			authHeader := r.Header.Get("Authorization")
			if authHeader == "" {
				logger.Warn("Missing authorization header")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Проверяем формат заголовка
			parts := strings.Split(authHeader, " ")
			if len(parts) != 2 || parts[0] != "Bearer" {
				logger.Warn("Invalid authorization header format")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Извлекаем токен
			tokenString := parts[1]

			// Проверяем токен
			claims, err := tokenManager.ParseToken(tokenString)
			if err != nil {
				logger.WithError(err).Warn("Invalid token")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Проверяем тип токена
			if claims.Type != jwt.AccessToken {
				logger.Warn("Invalid token type")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Добавляем информацию о пользователе в контекст
			ctx := context.WithValue(r.Context(), UserIDKey, claims.UserID)
			ctx = context.WithValue(ctx, RolesKey, claims.Role)

			// Продолжаем обработку запроса
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// RoleGuard проверяет, имеет ли пользователь требуемую роль
func RoleGuard(requiredRoles ...string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Получаем роли из контекста
			rolesValue := r.Context().Value(RolesKey)
			if rolesValue == nil {
				http.Error(w, "Forbidden", http.StatusForbidden)
				return
			}

			// Приводим к типу []string
			roles, ok := rolesValue.([]string)
			if !ok {
				http.Error(w, "Forbidden", http.StatusForbidden)
				return
			}

			// Проверяем наличие хотя бы одной требуемой роли
			hasRequiredRole := false
			for _, requiredRole := range requiredRoles {
				for _, role := range roles {
					if role == requiredRole {
						hasRequiredRole = true
						break
					}
				}
				if hasRequiredRole {
					break
				}
			}

			if !hasRequiredRole {
				http.Error(w, "Forbidden", http.StatusForbidden)
				return
			}

			// Если роль подходит, продолжаем обработку запроса
			next.ServeHTTP(w, r)
		})
	}
}
```

### 3.2 Middleware для защиты от распространенных веб-уязвимостей

**Файл: services/api-gateway/internal/middleware/security.go**
```go
package middleware

import (
	"net/http"
	"time"

	"github.com/sirupsen/logrus"
)

// SecurityHeaders добавляет заголовки безопасности в ответы
func SecurityHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Защита от XSS
		w.Header().Set("X-XSS-Protection", "1; mode=block")
		// Запрет встраивания в iframe
		w.Header().Set("X-Frame-Options", "DENY")
		// Запрет MIME-сниффинга
		w.Header().Set("X-Content-Type-Options", "nosniff")
		// Content Security Policy
		w.Header().Set("Content-Security-Policy", "default-src 'self'; img-src 'self' https://cdn.gameplatform.ru; script-src 'self'; style-src 'self'; font-src 'self'; connect-src 'self' https://api.gameplatform.ru;")
		// Referrer Policy
		w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
		// Strict Transport Security
		w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
		// Permissions Policy
		w.Header().Set("Permissions-Policy", "geolocation=(), camera=(), microphone=()")

		next.ServeHTTP(w, r)
	})
}

// CORS настраивает заголовки Cross-Origin Resource Sharing
func CORS(allowedOrigins []string, allowedMethods []string, allowedHeaders []string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			origin := r.Header.Get("Origin")

			// Проверяем, разрешен ли данный источник
			allowed := false
			for _, allowedOrigin := range allowedOrigins {
				if origin == allowedOrigin || allowedOrigin == "*" {
					allowed = true
					break
				}
			}

			// Если источник разрешен, добавляем заголовки CORS
			if allowed {
				w.Header().Set("Access-Control-Allow-Origin", origin)
				w.Header().Set("Access-Control-Allow-Credentials", "true")

				// Объединяем разрешенные методы в строку
				if len(allowedMethods) > 0 {
					w.Header().Set("Access-Control-Allow-Methods", strings.Join(allowedMethods, ", "))
				} else {
					w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
				}

				// Объединяем разрешенные заголовки в строку
				if len(allowedHeaders) > 0 {
					w.Header().Set("Access-Control-Allow-Headers", strings.Join(allowedHeaders, ", "))
				} else {
					w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
				}

				// Устанавливаем время кэширования предварительных запросов
				w.Header().Set("Access-Control-Max-Age", "300")
			}

			// Если это предварительный запрос OPTIONS, сразу возвращаем 200 OK
			if r.Method == http.MethodOptions {
				w.WriteHeader(http.StatusOK)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// RateLimiter ограничивает количество запросов от одного IP-адреса
func RateLimiter(requestsPerMinute int, burst int) func(http.Handler) http.Handler {
	// Создаем карту для хранения счетчиков запросов для каждого IP
	rateLimits := make(map[string]*tokenBucket)
	var mutex sync.Mutex

	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Получаем IP адрес клиента
			ip := getClientIP(r)

			// Блокируем доступ к карте для обеспечения потокобезопасности
			mutex.Lock()

			// Получаем или создаем токенное ведро для данного IP
			bucket, exists := rateLimits[ip]
			if !exists {
				bucket = newTokenBucket(requestsPerMinute, burst)
				rateLimits[ip] = bucket
			}

			// Проверяем, можно ли обработать запрос
			allow := bucket.allow()
			mutex.Unlock()

			if !allow {
				// Если превышен лимит, возвращаем 429 Too Many Requests
				w.Header().Set("Retry-After", "60")
				http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
				return
			}

			// Продолжаем обработку запроса
			next.ServeHTTP(w, r)
		})
	}
}

// tokenBucket реализует алгоритм Token Bucket для ограничения скорости
type tokenBucket struct {
	rate       float64     // Скорость пополнения токенов (токенов в секунду)
	capacity   float64     // Максимальное количество токенов
	tokens     float64     // Текущее количество токенов
	lastRefill time.Time   // Время последнего пополнения
	mutex      sync.Mutex  // Мьютекс для обеспечения потокобезопасности
}

// newTokenBucket создает новое токенное ведро с заданными параметрами
func newTokenBucket(requestsPerMinute, burst int) *tokenBucket {
	return &tokenBucket{
		rate:       float64(requestsPerMinute) / 60.0, // Переводим в токены в секунду
		capacity:   float64(burst),
		tokens:     float64(burst),                    // Начинаем с полного ведра
		lastRefill: time.Now(),
	}
}

// allow проверяет, можно ли обработать запрос, и уменьшает количество токенов
func (tb *tokenBucket) allow() bool {
	tb.mutex.Lock()
	defer tb.mutex.Unlock()

	// Вычисляем время, прошедшее с последнего пополнения
	now := time.Now()
	elapsed := now.Sub(tb.lastRefill).Seconds()
	tb.lastRefill = now

	// Пополняем токены в соответствии с прошедшим временем
	tb.tokens += elapsed * tb.rate
	if tb.tokens > tb.capacity {
		tb.tokens = tb.capacity
	}

	// Проверяем, есть ли токен для запроса
	if tb.tokens < 1 {
		return false
	}

	// Уменьшаем количество токенов
	tb.tokens--
	return true
}
```

## 4. Защита от основных веб-уязвимостей

### 4.1 Настройка Content Security Policy

**Файл: services/api-gateway/internal/config/csp.go**
```go
package config

// CSPConfig содержит настройки Content Security Policy
type CSPConfig struct {
	DefaultSrc []string `mapstructure:"default_src"`
	ScriptSrc  []string `mapstructure:"script_src"`
	StyleSrc   []string `mapstructure:"style_src"`
	ImgSrc     []string `mapstructure:"img_src"`
	ConnectSrc []string `mapstructure:"connect_src"`
	FontSrc    []string `mapstructure:"font_src"`
	ObjectSrc  []string `mapstructure:"object_src"`
	MediaSrc   []string `mapstructure:"media_src"`
	FrameSrc   []string `mapstructure:"frame_src"`
	ReportURI  string   `mapstructure:"report_uri"`
	ReportOnly bool     `mapstructure:"report_only"`
}

// BuildCSPHeader формирует заголовок Content-Security-Policy
func (c CSPConfig) BuildCSPHeader() string {
	// Начинаем с пустой строки
	csp := ""

	// Добавляем default-src
	if len(c.DefaultSrc) > 0 {
		csp += "default-src " + joinSources(c.DefaultSrc) + "; "
	} else {
		csp += "default-src 'self'; "
	}

	// Добавляем script-src
	if len(c.ScriptSrc) > 0 {
		csp += "script-src " + joinSources(c.ScriptSrc) + "; "
	}

	// Добавляем style-src
	if len(c.StyleSrc) > 0 {
		csp += "style-src " + joinSources(c.StyleSrc) + "; "
	}

	// Добавляем img-src
	if len(c.ImgSrc) > 0 {
		csp += "img-src " + joinSources(c.ImgSrc) + "; "
	}

	// Добавляем connect-src
	if len(c.ConnectSrc) > 0 {
		csp += "connect-src " + joinSources(c.ConnectSrc) + "; "
	}

	// Добавляем font-src
	if len(c.FontSrc) > 0 {
		csp += "font-src " + joinSources(c.FontSrc) + "; "
	}

	// Добавляем object-src
	if len(c.ObjectSrc) > 0 {
		csp += "object-src " + joinSources(c.ObjectSrc) + "; "
	} else {
		csp += "object-src 'none'; "
	}

	// Добавляем media-src
	if len(c.MediaSrc) > 0 {
		csp += "media-src " + joinSources(c.MediaSrc) + "; "
	}

	// Добавляем frame-src
	if len(c.FrameSrc) > 0 {
		csp += "frame-src " + joinSources(c.FrameSrc) + "; "
	}

	// Добавляем report-uri
	if c.ReportURI != "" {
		csp += "report-uri " + c.ReportURI + "; "
	}

	return csp
}

// GetCSPHeaderName возвращает имя заголовка CSP
func (c CSPConfig) GetCSPHeaderName() string {
	if c.ReportOnly {
		return "Content-Security-Policy-Report-Only"
	}
	return "Content-Security-Policy"
}

// joinSources объединяет источники в строку, разделенную пробелами
func joinSources(sources []string) string {
	var result string
	for i, source := range sources {
		result += source
		if i < len(sources)-1 {
			result += " "
		}
	}
	return result
}
```

### 4.2 Защита от SQL-инъекций с использованием параметризованных запросов

**Файл: services/account-service/internal/repository/postgres/user_repository.go (пример безопасного запроса)**
```go
// GetUsersByFilter ищет пользователей по фильтру
func (r *UserRepo) GetUsersByFilter(ctx context.Context, filter UserFilter, limit, offset int) ([]domain.User, int, error) {
	// Подготавливаем параметры запроса
	params := []interface{}{}
	paramIndex := 1

	// Базовый запрос
	query := `
		SELECT user_id, email, phone_number, username, display_name,
		       registration_date, last_login_date, account_status, 
               two_factor_enabled, profile_picture_url, is_verified
		FROM users
		WHERE 1=1
	`

	// Добавляем условия фильтрации с использованием параметров
	if filter.Email != "" {
		query += fmt.Sprintf(" AND email LIKE $%d", paramIndex)
		params = append(params, "%"+filter.Email+"%")
		paramIndex++
	}

	if filter.Username != "" {
		query += fmt.Sprintf(" AND username LIKE $%d", paramIndex)
		params = append(params, "%"+filter.Username+"%")
		paramIndex++
	}

	if filter.Status != "" {
		query += fmt.Sprintf(" AND account_status = $%d", paramIndex)
		params = append(params, filter.Status)
		paramIndex++
	}

	if !filter.RegisteredAfter.IsZero() {
		query += fmt.Sprintf(" AND registration_date >= $%d", paramIndex)
		params = append(params, filter.RegisteredAfter)
		paramIndex++
	}

	if !filter.RegisteredBefore.IsZero() {
		query += fmt.Sprintf(" AND registration_date <= $%d", paramIndex)
		params = append(params, filter.RegisteredBefore)
		paramIndex++
	}

	// Запрос для подсчета общего количества записей
	countQuery := "SELECT COUNT(*) FROM (" + query + ") AS count_query"
	
	// Добавляем сортировку и пагинацию
	query += fmt.Sprintf(" ORDER BY %s %s LIMIT $%d OFFSET $%d", 
		getSortField(filter.SortBy), getSortOrder(filter.SortOrder),
		paramIndex, paramIndex+1)
	
	params = append(params, limit, offset)

	// Выполняем запрос на подсчет
	var total int
	err := r.db.QueryRow(ctx, countQuery, params[:paramIndex-1]...).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("ошибка подсчета пользователей: %w", err)
	}

	// Выполняем основной запрос
	rows, err := r.db.Query(ctx, query, params...)
	if err != nil {
		return nil, 0, fmt.Errorf("ошибка выполнения запроса: %w", err)
	}
	defer rows.Close()

	// Обрабатываем результаты
	var users []domain.User
	for rows.Next() {
		var user domain.User
		err := rows.Scan(
			&user.UserID,
			&user.Email,
			&user.PhoneNumber,
			&user.Username,
			&user.DisplayName,
			&user.RegistrationDate,
			&user.LastLoginDate,
			&user.AccountStatus,
			&user.TwoFactorEnabled,
			&user.ProfilePictureURL,
			&user.IsVerified,
		)
		if err != nil {
			return nil, 0, fmt.Errorf("ошибка сканирования строки: %w", err)
		}
		users = append(users, user)
	}

	if err := rows.Err(); err != nil {
		return nil, 0, fmt.Errorf("ошибка итерации по результатам: %w", err)
	}

	return users, total, nil
}

// getSortField возвращает корректное поле для сортировки
func getSortField(field string) string {
	// Проверяем, что поле для сортировки допустимо (защита от SQL-инъекций)
	allowedFields := map[string]string{
		"email":            "email",
		"username":         "username",
		"registration_date": "registration_date",
		"last_login_date":  "last_login_date",
		"account_status":   "account_status",
	}

	if sortField, ok := allowedFields[field]; ok {
		return sortField
	}
	
	// По умолчанию сортируем по дате регистрации
	return "registration_date"
}

// getSortOrder возвращает корректный порядок сортировки
func getSortOrder(order string) string {
	if order == "asc" {
		return "ASC"
	}
	return "DESC"
}
```

### 4.3 Защита от Cross-Site Request Forgery (CSRF)

**Файл: services/api-gateway/internal/middleware/csrf.go**
```go
package middleware

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"net/http"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
)

var (
	ErrInvalidCSRFToken = errors.New("неверный CSRF-токен")
	ErrExpiredCSRFToken = errors.New("истекший CSRF-токен")
)

// CSRFConfig содержит настройки CSRF-защиты
type CSRFConfig struct {
	CookieName     string
	HeaderName     string
	CookieMaxAge   int
	CookieSecure   bool
	CookieHTTPOnly bool
	CookiePath     string
	CookieDomain   string
	TokenLength    int
	TokenTTL       time.Duration
}

// DefaultCSRFConfig возвращает конфигурацию CSRF по умолчанию
func DefaultCSRFConfig() CSRFConfig {
	return CSRFConfig{
		CookieName:     "csrf_token",
		HeaderName:     "X-CSRF-Token",
		CookieMaxAge:   3600,
		CookieSecure:   true,
		CookieHTTPOnly: true,
		CookiePath:     "/",
		CookieDomain:   "",
		TokenLength:    32,
		TokenTTL:       time.Hour,
	}
}

// CSRFStore хранит CSRF-токены
type CSRFStore struct {
	tokens map[string]time.Time
	mutex  sync.RWMutex
}

// NewCSRFStore создает новое хранилище CSRF-токенов
func NewCSRFStore() *CSRFStore {
	store := &CSRFStore{
		tokens: make(map[string]time.Time),
	}

	// Запускаем горутину для очистки устаревших токенов
	go store.cleanupExpiredTokens()

	return store
}

// cleanupExpiredTokens удаляет устаревшие токены каждый час
func (s *CSRFStore) cleanupExpiredTokens() {
	ticker := time.NewTicker(time.Hour)
	defer ticker.Stop()

	for range ticker.C {
		s.mutex.Lock()
		now := time.Now()
		for token, expiry := range s.tokens {
			if now.After(expiry) {
				delete(s.tokens, token)
			}
		}
		s.mutex.Unlock()
	}
}

// AddToken добавляет токен в хранилище
func (s *CSRFStore) AddToken(token string, ttl time.Duration) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	s.tokens[token] = time.Now().Add(ttl)
}

// ValidateToken проверяет валидность токена
func (s *CSRFStore) ValidateToken(token string) error {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	expiry, exists := s.tokens[token]
	if !exists {
		return ErrInvalidCSRFToken
	}

	if time.Now().After(expiry) {
		return ErrExpiredCSRFToken
	}

	return nil
}

// RemoveToken удаляет токен из хранилища
func (s *CSRFStore) RemoveToken(token string) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	delete(s.tokens, token)
}

// GenerateToken генерирует новый CSRF-токен
func GenerateToken(length int) (string, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(bytes), nil
}

// CSRFMiddleware добавляет CSRF-защиту
func CSRFMiddleware(config CSRFConfig, store *CSRFStore, logger *logrus.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Для безопасных методов (GET, HEAD, OPTIONS, TRACE) просто пропускаем
			if isSafeMethod(r.Method) {
				// Для GET-запросов генерируем и устанавливаем токен
				if r.Method == http.MethodGet {
					token, err := GenerateToken(config.TokenLength)
					if err != nil {
						logger.WithError(err).Error("Failed to generate CSRF token")
						http.Error(w, "Internal Server Error", http.StatusInternalServerError)
						return
					}

					// Добавляем токен в хранилище
					store.AddToken(token, config.TokenTTL)

					// Устанавливаем cookie с токеном
					http.SetCookie(w, &http.Cookie{
						Name:     config.CookieName,
						Value:    token,
						MaxAge:   config.CookieMaxAge,
						Path:     config.CookiePath,
						Domain:   config.CookieDomain,
						Secure:   config.CookieSecure,
						HttpOnly: config.CookieHTTPOnly,
						SameSite: http.SameSiteStrictMode,
					})
				}
				next.ServeHTTP(w, r)
				return
			}

			// Для небезопасных методов проверяем наличие CSRF-токена
			// Сначала извлекаем токен из заголовка
			token := r.Header.Get(config.HeaderName)
			if token == "" {
				// Если в заголовке нет, проверяем в форме
				token = r.FormValue("csrf_token")
				if token == "" {
					logger.Warn("Missing CSRF token")
					http.Error(w, "Forbidden - CSRF token missing", http.StatusForbidden)
					return
				}
			}

			// Проверяем токен
			if err := store.ValidateToken(token); err != nil {
				logger.WithError(err).Warn("Invalid CSRF token")
				http.Error(w, "Forbidden - Invalid CSRF token", http.StatusForbidden)
				return
			}

			// Токен валиден, удаляем его из хранилища (одноразовый токен)
			store.RemoveToken(token)

			// Генерируем новый токен
			newToken, err := GenerateToken(config.TokenLength)
			if err != nil {
				logger.WithError(err).Error("Failed to generate new CSRF token")
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				return
			}

			// Добавляем новый токен в хранилище
			store.AddToken(newToken, config.TokenTTL)

			// Устанавливаем новый cookie с токеном
			http.SetCookie(w, &http.Cookie{
				Name:     config.CookieName,
				Value:    newToken,
				MaxAge:   config.CookieMaxAge,
				Path:     config.CookiePath,
				Domain:   config.CookieDomain,
				Secure:   config.CookieSecure,
				HttpOnly: config.CookieHTTPOnly,
				SameSite: http.SameSiteStrictMode,
			})

			// Продолжаем обработку запроса
			next.ServeHTTP(w, r)
		})
	}
}

// isSafeMethod проверяет, является ли метод HTTP безопасным
func isSafeMethod(method string) bool {
	return method == http.MethodGet ||
		method == http.MethodHead ||
		method == http.MethodOptions ||
		method == http.MethodTrace
}
```

## 5. Защита от DDoS и брутфорс-атак

### 5.1 Реализация защиты от брутфорс-атак для аутентификации

**Файл: services/auth-service/internal/service/login_attempt.go**
```go
package service

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/sirupsen/logrus"
)

var (
	ErrLoginAttemptsExceeded = errors.New("превышено количество попыток входа")
)

// LoginAttemptConfig содержит настройки защиты от брутфорс-атак
type LoginAttemptConfig struct {
	MaxAttempts      int           // Максимальное количество неудачных попыток
	BlockDuration    time.Duration // Продолжительность блокировки
	AttemptTTL       time.Duration // Время жизни счетчика попыток
	KeyPrefix        string        // Префикс для ключей в Redis
	IncludeIPAddress bool          // Учитывать IP-адрес при блокировке
}

// DefaultLoginAttemptConfig возвращает конфигурацию по умолчанию
func DefaultLoginAttemptConfig() LoginAttemptConfig {
	return LoginAttemptConfig{
		MaxAttempts:      5,
		BlockDuration:    15 * time.Minute,
		AttemptTTL:       24 * time.Hour,
		KeyPrefix:        "login_attempts:",
		IncludeIPAddress: true,
	}
}

// LoginAttemptService реализует защиту от брутфорс-атак
type LoginAttemptService struct {
	config LoginAttemptConfig
	redis  *redis.Client
	logger *logrus.Logger
	// Для режима без Redis (in-memory)
	attempts map[string]int
	blocks   map[string]time.Time
	mutex    sync.RWMutex
}

// NewLoginAttemptService создает новый сервис защиты от брутфорс-атак
func NewLoginAttemptService(config LoginAttemptConfig, redisClient *redis.Client, logger *logrus.Logger) *LoginAttemptService {
	service := &LoginAttemptService{
		config:   config,
		redis:    redisClient,
		logger:   logger,
		attempts: make(map[string]int),
		blocks:   make(map[string]time.Time),
	}

	// Если Redis не доступен, запускаем очистку устаревших записей
	if redisClient == nil {
		go service.cleanupExpired()
	}

	return service
}

// cleanupExpired периодически удаляет устаревшие записи в режиме in-memory
func (s *LoginAttemptService) cleanupExpired() {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		s.mutex.Lock()
		now := time.Now()
		for key, blockTime := range s.blocks {
			if now.After(blockTime) {
				delete(s.blocks, key)
				delete(s.attempts, key)
			}
		}
		s.mutex.Unlock()
	}
}

// getKey формирует ключ для хранения попыток входа
func (s *LoginAttemptService) getKey(identifier, ipAddress string) string {
	key := s.config.KeyPrefix + identifier
	if s.config.IncludeIPAddress && ipAddress != "" {
		key += ":" + ipAddress
	}
	return key
}

// CheckLoginAttempt проверяет, не заблокирован ли доступ для данного идентификатора
func (s *LoginAttemptService) CheckLoginAttempt(ctx context.Context, identifier, ipAddress string) error {
	key := s.getKey(identifier, ipAddress)

	if s.redis != nil {
		// Проверяем, не заблокирован ли доступ в Redis
		blocked, err := s.redis.Exists(ctx, "block:"+key).Result()
		if err != nil {
			s.logger.WithError(err).Warn("Failed to check block status in Redis")
			// В случае ошибки Redis переходим к in-memory проверке
		} else if blocked > 0 {
			return ErrLoginAttemptsExceeded
		}

		// Проверяем количество попыток
		attempts, err := s.redis.Get(ctx, key).Int()
		if err != nil && err != redis.Nil {
			s.logger.WithError(err).Warn("Failed to get login attempts from Redis")
			// В случае ошибки Redis переходим к in-memory проверке
		} else if attempts >= s.config.MaxAttempts {
			// Блокируем доступ
			err := s.redis.Set(ctx, "block:"+key, "1", s.config.BlockDuration).Err()
			if err != nil {
				s.logger.WithError(err).Warn("Failed to set block in Redis")
			}
			return ErrLoginAttemptsExceeded
		}
	} else {
		// In-memory проверка
		s.mutex.RLock()
		blockTime, blocked := s.blocks[key]
		attempts := s.attempts[key]
		s.mutex.RUnlock()

		if blocked && time.Now().Before(blockTime) {
			return ErrLoginAttemptsExceeded
		}

		if attempts >= s.config.MaxAttempts {
			s.mutex.Lock()
			s.blocks[key] = time.Now().Add(s.config.BlockDuration)
			s.mutex.Unlock()
			return ErrLoginAttemptsExceeded
		}
	}

	return nil
}

// RecordFailedAttempt регистрирует неудачную попытку входа
func (s *LoginAttemptService) RecordFailedAttempt(ctx context.Context, identifier, ipAddress string) error {
	key := s.getKey(identifier, ipAddress)

	if s.redis != nil {
		// Инкрементируем счетчик в Redis
		attempts, err := s.redis.Incr(ctx, key).Result()
		if err != nil {
			s.logger.WithError(err).Warn("Failed to increment login attempts in Redis")
			// В случае ошибки Redis переходим к in-memory обновлению
		} else {
			// Устанавливаем TTL для ключа, если его еще нет
			s.redis.Expire(ctx, key, s.config.AttemptTTL)

			// Если превышен лимит, блокируем
			if attempts >= s.config.MaxAttempts {
				err := s.redis.Set(ctx, "block:"+key, "1", s.config.BlockDuration).Err()
				if err != nil {
					s.logger.WithError(err).Warn("Failed to set block in Redis")
				}
			}
			return nil
		}
	}

	// In-memory обновление
	s.mutex.Lock()
	s.attempts[key]++
	attempts := s.attempts[key]
	s.mutex.Unlock()

	if attempts >= s.config.MaxAttempts {
		s.mutex.Lock()
		s.blocks[key] = time.Now().Add(s.config.BlockDuration)
		s.mutex.Unlock()
	}

	return nil
}

// ResetAttempts сбрасывает счетчик неудачных попыток
func (s *LoginAttemptService) ResetAttempts(ctx context.Context, identifier, ipAddress string) error {
	key := s.getKey(identifier, ipAddress)

	if s.redis != nil {
		// Удаляем ключи в Redis
		pipe := s.redis.Pipeline()
		pipe.Del(ctx, key)
		pipe.Del(ctx, "block:"+key)
		_, err := pipe.Exec(ctx)
		if err != nil {
			s.logger.WithError(err).Warn("Failed to reset login attempts in Redis")
			// В случае ошибки Redis переходим к in-memory сбросу
		} else {
			return nil
		}
	}

	// In-memory сброс
	s.mutex.Lock()
	delete(s.attempts, key)
	delete(s.blocks, key)
	s.mutex.Unlock()

	return nil
}
```

### 5.2 Интеграция защиты от брутфорс-атак в сервис аутентификации

**Файл: services/auth-service/internal/service/auth_service.go (фрагмент)**
```go
// Login проверяет учетные данные пользователя и выполняет вход
func (s *AuthService) Login(ctx context.Context, login, password, ipAddress string) (domain.User, string, string, error) {
	// Проверяем, не заблокирован ли доступ для данного логина
	err := s.loginAttemptService.CheckLoginAttempt(ctx, login, ipAddress)
	if err != nil {
		return domain.User{}, "", "", err
	}

	// Получаем пользователя по email или username
	var user domain.User
	var fetchErr error
	if strings.Contains(login, "@") {
		user, fetchErr = s.userRepo.GetByEmail(ctx, login)
	} else {
		user, fetchErr = s.userRepo.GetByUsername(ctx, login)
	}

	if fetchErr != nil {
		// Регистрируем неудачную попытку
		_ = s.loginAttemptService.RecordFailedAttempt(ctx, login, ipAddress)
		return domain.User{}, "", "", ErrInvalidCredentials
	}

	// Проверяем статус пользователя
	if user.AccountStatus != "active" {
		return domain.User{}, "", "", ErrUserNotActive
	}

	// Проверяем пароль
	valid, err := s.passwordHasher.Verify(password, user.PasswordHash)
	if err != nil || !valid {
		// Регистрируем неудачную попытку
		_ = s.loginAttemptService.RecordFailedAttempt(ctx, login, ipAddress)
		return domain.User{}, "", "", ErrInvalidCredentials
	}

	// Получаем роли пользователя
	roles, err := s.userRepo.GetUserRoles(ctx, user.UserID)
	if err != nil {
		return domain.User{}, "", "", fmt.Errorf("ошибка получения ролей пользователя: %w", err)
	}

	// Генерируем токены
	accessToken, err := s.tokenManager.GenerateAccessToken(user.UserID, roles)
	if err != nil {
		return domain.User{}, "", "", fmt.Errorf("ошибка генерации access токена: %w", err)
	}

	refreshToken, err := s.tokenManager.GenerateRefreshToken(user.UserID, roles)
	if err != nil {
		return domain.User{}, "", "", fmt.Errorf("ошибка генерации refresh токена: %w", err)
	}

	// Успешный вход, сбрасываем счетчик неудачных попыток
	_ = s.loginAttemptService.ResetAttempts(ctx, login, ipAddress)

	// Обновляем время последнего входа
	user.LastLoginDate = time.Now()
	err = s.userRepo.Update(ctx, user)
	if err != nil {
		s.logger.WithError(err).Error("Failed to update last login date")
		// Не возвращаем ошибку пользователю, это некритично
	}

	return user, accessToken, refreshToken, nil
}
```

## 6. Проверка безопасности и сканирование уязвимостей

### 6.1 Скрипт для сканирования зависимостей на уязвимости

**Файл: scripts/check_dependencies.sh**
```bash
#!/bin/bash

# Проверка наличия необходимых утилит
command -v go >/dev/null 2>&1 || { echo "go не установлен"; exit 1; }
command -v npm >/dev/null 2>&1 || { echo "npm не установлен"; exit 1; }

# Установка gosec для Go
go install github.com/securego/gosec/v2/cmd/gosec@latest

# Установка Nancy для проверки зависимостей Go
go install github.com/sonatype-nexus-community/nancy@latest

# Проверка Go-зависимостей в каждом сервисе
echo "Проверка Go-зависимостей на уязвимости..."
for service in $(find ./services -maxdepth 1 -mindepth 1 -type d); do
    echo "Проверка сервиса: $service"
    cd $service
    
    # Проверка прямых зависимостей с Nancy
    go list -json -deps | nancy sleuth
    
    # Анализ кода на уязвимости с gosec
    gosec -quiet ./...
    
    cd - > /dev/null
done

# Проверка npm-зависимостей в веб-приложении
echo "Проверка npm-зависимостей на уязвимости..."
cd ./web
npm audit --production
cd - > /dev/null

echo "Проверка зависимостей завершена."
```

### 6.2 Интеграция проверки безопасности в CI/CD

**Файл: .github/workflows/security.yml**
```yaml
name: Security Checks

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    - cron: '0 0 * * 1'  # Запуск каждый понедельник в 00:00

jobs:
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.19'

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install security tools
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          go install github.com/sonatype-nexus-community/nancy@latest
          npm install -g snyk

      - name: Run Gosec
        run: |
          cd services
          gosec -fmt=json -out=gosec-results.json ./...
          cd ..

      - name: Run Nancy
        run: |
          cd services
          go list -json -deps ./... | nancy sleuth -o json > nancy-results.json
          cd ..

      - name: Run npm audit
        run: |
          cd web
          npm audit --production --json > npm-audit-results.json
          cd ..

      - name: Run Snyk
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          cd services
          snyk test --json > snyk-results.json
          cd ..
          cd web
          snyk test --json > snyk-web-results.json
          cd ..

      - name: Upload security results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: gosec-results.json
          category: gosec

      - name: Check for vulnerabilities
        run: |
          if grep -q '"level":"high\|critical"' gosec-results.json; then
            echo "High or critical vulnerabilities found in Go code"
            exit 1
          fi
          if grep -q '"vulnerabilities":true' nancy-results.json; then
            echo "Vulnerabilities found in Go dependencies"
            exit 1
          fi
          if grep -q '"critical":' npm-audit-results.json; then
            echo "Critical vulnerabilities found in npm dependencies"
            exit 1
          fi
```

### 6.3 Настройка правил безопасности для статического анализа кода

**Файл: .golangci.yml**
```yaml
linters:
  enable:
    - govet
    - errcheck
    - staticcheck
    - gosec
    - gosimple
    - ineffassign
    - rowserrcheck
    - typecheck
    - unused
    - nilerr
    - bodyclose
    - gocritic
    - gofmt
    - goimports
    - misspell
    - prealloc
    - stylecheck
    - unconvert
    - unparam
    - whitespace

linters-settings:
  gosec:
    # G114: Use of net/http serve function that has no support for setting timeouts
    # G204: Subprocess launched with variable
    # G307: Deferring a method which returns an error
    # G401: Detect the usage of weak cryptographic primitives
    # G404: Insecure random number source (rand)
    # G501: Import blocklist: crypto/md5
    # G505: Import blocklist: crypto/sha1
    includes:
      - G104  # Unhandled errors
      - G114  # Use a service without timeouts
      - G204  # Subprocess launched with variable
      - G304  # File path provided as variable
      - G307  # Deferring method with error return
      - G401  # Use of weak cryptographic primitives
      - G404  # Insecure random number source
      - G501  # Import of deprecated hash function md5
      - G505  # Import of deprecated hash function sha1

  gocritic:
    enabled-tags:
      - diagnostic
      - style
      - performance
      - experimental
      - opinionated

issues:
  exclude-rules:
    # Exclude some linters from running on tests files.
    - path: _test\.go
      linters:
        - gosec
        - errcheck
```

## 7. Настройки безопасности для инфраструктуры

### 7.1 Конфигурация для HTTPS в Kubernetes

**Файл: infrastructure/kubernetes/ingress.yaml**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: gameplatform-ingress
  namespace: gameplatform
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,X-Client-Id,X-CSRF-Token"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers "X-Frame-Options: DENY";
      more_set_headers "X-Content-Type-Options: nosniff";
      more_set_headers "X-XSS-Protection: 1; mode=block";
      more_set_headers "Referrer-Policy: strict-origin-when-cross-origin";
      more_set_headers "Content-Security-Policy: default-src 'self'; img-src 'self' https://cdn.gameplatform.ru; script-src 'self'; style-src 'self'; font-src 'self'; connect-src 'self' https://api.gameplatform.ru;";
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.gameplatform.ru
    - www.gameplatform.ru
    - gameplatform.ru
    secretName: gameplatform-tls
  rules:
  - host: api.gameplatform.ru
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway
            port:
              number: 8080
  - host: gameplatform.ru
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-frontend
            port:
              number: 80
  - host: www.gameplatform.ru
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-frontend
            port:
              number: 80
```

### 7.2 Конфигурация NetworkPolicy для изоляции сервисов

**Файл: infrastructure/kubernetes/network-policies.yaml**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: gameplatform
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-gateway-policy
  namespace: gameplatform
spec:
  podSelector:
    matchLabels:
      app: api-gateway
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 0.0.0.0/0
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: auth-service
    ports:
    - protocol: TCP
      port: 8082
  - to:
    - podSelector:
        matchLabels:
          app: account-service
    ports:
    - protocol: TCP
      port: 8081
  - to:
    - podSelector:
        matchLabels:
          app: catalog-service
    ports:
    - protocol: TCP
      port: 8083
  # Допустим DNS-запросы
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: auth-service-policy
  namespace: gameplatform
spec:
  podSelector:
    matchLabels:
      app: auth-service
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway
    ports:
    - protocol: TCP
      port: 8082
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  - to:
    - podSelector:
        matchLabels:
          app: kafka
    ports:
    - protocol: TCP
      port: 9092
  # Допустим DNS-запросы
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53
  # Допустим SMTP для отправки email
  - to:
    - podSelector:
        matchLabels:
          app: smtp-service
    ports:
    - protocol: TCP
      port: 587
```

### 7.3 Конфигурация для защиты данных в хранилище

**Файл: infrastructure/kubernetes/storage-encryption.yaml**
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
metadata:
  name: gameplatform-encryption-config
spec:
  resources:
    - resources:
        - secrets
      providers:
        - aescbc:
            keys:
              - name: key1
                secret: <base64-encoded-key>
        - identity: {}
---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-encryption-key
  namespace: gameplatform
type: Opaque
data:
  key: <base64-encoded-key>
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: gameplatform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  serviceName: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:14
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: database
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        - name: ENCRYPTION_KEY
          valueFrom:
            secretKeyRef:
              name: postgres-encryption-key
              key: key
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        - name: postgres-config
          mountPath: /etc/postgresql/conf.d
  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 100Gi
      storageClassName: encrypted-storage
```

# Методология разработки

## 1. Общий подход

### 1.1 Используемая методология
- SAFe (Scaled Agile Framework) с элементами DevOps
- Команды работают по Scrum, координация на уровне программы
- Интеграция принципов CI/CD для непрерывной поставки

### 1.2 Структура методологии
- **Уровень команды**: Scrum (2-недельные спринты)
- **Уровень программы**: синхронизированные инкременты (PI) по 8-10 недель
- **Уровень портфеля**: квартальное планирование и ежемесячная корректировка

## 2. Структура команд

### 2.1 Основные команды
| Команда | Зона ответственности | Состав | Ключевые роли |
|---------|----------------------|--------|---------------|
| Core Services | Базовые микросервисы (аутентификация, пользователи, платежи) | 6-8 чел. | Tech Lead, BE-разработчики, QA |
| Game Services | Каталог, библиотека, управление играми | 6-8 чел. | Tech Lead, BE-разработчики, QA |
| Web Frontend | Веб-интерфейс, административная панель | 6-8 чел. | Tech Lead, FE-разработчики, UX-специалист, QA |
| Client App | Десктопное приложение | 6-8 чел. | Tech Lead, C++/Qt разработчики, QA |
| Infrastructure | DevOps, мониторинг, безопасность | 4-6 чел. | DevOps Engineers, SRE, Security Engineer |
| QA | Автоматизация тестирования, тестовая инфраструктура | 4-6 чел. | Test Automation Engineer, QA Lead, SDET |

### 2.2 Роли программного уровня
- **Руководитель разработки**: общая координация
- **Архитектор**: техническое руководство, архитектурные решения
- **Product Owner**: общее управление бэклогом и приоритетами
- **Scrum Master**: процессы, удаление препятствий, фасилитация
- **Release Train Engineer (RTE)**: координация между командами и управление инкрементами

## 3. Процесс планирования

### 3.1 Уровни планирования
- **Стратегический (квартал)**: определение крупных инициатив и эпиков
- **Программный (6-8 недель)**: планирование PI, декомпозиция эпиков на фичи
- **Командный (2 недели)**: планирование спринта, определение пользовательских историй

### 3.2 PI Planning (Program Increment)
- **Периодичность**: каждые 8-10 недель
- **Участники**: все команды разработки, бизнес-заинтересованные лица
- **Длительность**: 2 дня
- **Результаты**: цели PI, план команд, оценка рисков, матрица зависимостей
- **Артефакты**: дорожная карта PI, командные бэклоги, матрица зависимостей

### 3.3 Sprint Planning
- **Периодичность**: каждые 2 недели
- **Участники**: команда, Product Owner, Scrum Master
- **Длительность**: 2-4 часа
- **Результаты**: спринт-бэклог, цели спринта
- **Критерии готовности задач к взятию в спринт**:
  - Определены критерии приемки
  - Проведена оценка сложности
  - Проработаны технические детали
  - Нет блокирующих зависимостей
  - Задача соответствует Definition of Ready команды

## 4. Рабочий процесс

### 4.1 Жизненный цикл задачи
1. **Backlog** → Задача в программном бэклоге
2. **Refined** → Задача детализирована и готова к взятию в спринт
3. **Sprint Backlog** → Задача включена в текущий спринт
4. **In Progress** → Разработчик взял задачу в работу
5. **Review** → Код ожидает проверки (PR)
6. **Testing** → Функциональность проходит тестирование QA
7. **Done** → Задача полностью выполнена по критериям Definition of Done

### 4.2 Definition of Done (DoD)
- Написан код, соответствующий стандартам
- Пройдены все автоматические проверки (линтеры, статический анализ)
- Написаны модульные и интеграционные тесты
- Проведен code review и внесены необходимые правки
- Документация обновлена (API, README и т.д.)
- Функциональность протестирована QA
- Код смержен в основную ветку
- Успешно собран и развернут в тестовой среде

### 4.3 Управление кодом
- **Ветвление**: GitFlow
  - `main` - стабильная релизная ветка
  - `develop` - интеграционная ветка разработки
  - `feature/XXX-name` - ветки фич
  - `hotfix/XXX-name` - ветки для срочных исправлений
  - `release/X.Y.Z` - релизные ветки
- **Pull Requests**:
  - Требуется минимум 2 апрува от других разработчиков
  - CI должен пройти успешно
  - Должен соответствовать стандартам кодирования
- **Commit Conventions**:
  - Формат: `тип(область): сообщение`
  - Типы: feat, fix, docs, style, refactor, test, chore
  - Пример: `feat(auth): добавить двухфакторную аутентификацию`

## 5. Процесс CI/CD

### 5.1 Непрерывная интеграция (CI)
- **Триггеры**: push в ветку, создание PR
- **Проверки**:
  - Линтинг и статический анализ кода
  - Модульные тесты
  - Интеграционные тесты
  - Проверка безопасности (SAST)
  - Проверка зависимостей на уязвимости
- **Артефакты**:
  - Docker-образы
  - Отчеты о покрытии тестами
  - Отчеты о статическом анализе

### 5.2 Непрерывная поставка (CD)
- **Окружения**:
  - DEV - автоматический деплой из `develop`
  - STAGING - автоматический деплой из `release/*`
  - PRODUCTION - ручной запуск после утверждения
- **Процесс деплоя**:
  - Проверка инфраструктуры
  - Развертывание новой версии
  - Smoke-тесты
  - Переключение трафика
  - Мониторинг после деплоя
- **Rollback**: автоматический при провале smoke-тестов, ручной при обнаружении проблем после деплоя

## 6. Управление качеством

### 6.1 Типы тестирования
| Тип | Ответственные | Инструменты | Частота |
|-----|---------------|-------------|---------|
| Модульное | Разработчики | JUnit, Jest, GoogleTest | При каждом PR |
| Интеграционное | Разработчики, QA | Postman, RestAssured | При каждом PR |
| Функциональное | QA | Selenium, Cypress | После релиза в DEV |
| Нагрузочное | QA, DevOps | JMeter, Gatling | Еженедельно |
| Безопасность | Security Engineers | OWASP ZAP, SonarQube | Еженедельно |
| Приемочное | QA, Product Owner | Ручное тестирование | Перед релизом |

### 6.2 Стратегия автоматизации
- **Приоритеты автоматизации**:
  - Критические бизнес-процессы
  - Регрессионные тесты основного функционала
  - Часто используемые пользовательские сценарии
- **Цели покрытия**:
  - Модульные тесты: >80%
  - Интеграционные тесты: >70% API
  - UI-тесты: >50% критических сценариев

### 6.3 Управление тестовыми данными
- Использование фикстур для модульных тестов
- Изолированные базы данных для интеграционных тестов
- Управление тестовыми пользователями через API
- Анонимизированная копия реальных данных для нагрузочного тестирования

## 7. Координация и коммуникация

### 7.1 Регулярные встречи
| Встреча | Периодичность | Участники | Цель |
|---------|---------------|-----------|------|
| Командный Stand-up | Ежедневно | Команда | Статус задач, блокеры |
| Refinement | Еженедельно | Команда, PO | Детализация бэклога |
| Sprint Planning | Раз в 2 недели | Команда, PO, SM | Планирование спринта |
| Sprint Review | Раз в 2 недели | Команда, PO, заинтересованные лица | Демонстрация результатов |
| Ретроспектива | Раз в 2 недели | Команда, SM | Улучшение процессов |
| PO Sync | Еженедельно | Все PO, RTE | Синхронизация бэклогов |
| System Demo | Раз в 2 недели | Все команды, заинтересованные лица | Демонстрация системы в целом |
| Scrum of Scrums | 2 раза в неделю | Представители команд, RTE | Координация между командами |

### 7.2 Инструменты
- **Управление задачами**: Jira
- **Документация**: Confluence
- **Код**: GitLab/GitHub
- **Коммуникация**: Slack, Teams
- **CI/CD**: Jenkins, GitLab CI
- **Мониторинг**: Prometheus, Grafana
- **Логирование**: ELK Stack

### 7.3 Артефакты
- **Product Backlog**: централизованный Jira-проект
- **Program Board**: доска с эпиками и фичами программного уровня
- **Sprint Backlog**: командные Jira-доски
- **Sprint Burndown**: автоматически в Jira
- **Документация**: Confluence, автоматическая генерация API-документации

## 8. Управление рисками

### 8.1 Процесс управления рисками
- **Идентификация**: на PI Planning и регулярно в течение разработки
- **Анализ**: оценка вероятности и воздействия
- **Приоритизация**: матрица рисков
- **Митигация**: определение мер по снижению
- **Мониторинг**: еженедельная проверка статуса

### 8.2 Категории рисков
- **Технические**: совместимость, производительность, безопасность
- **Ресурсные**: доступность специалистов, внешние зависимости
- **Бизнес-риски**: соответствие требованиям, конкуренция
- **Проектные**: сроки, качество, стоимость

### 8.3 Реагирование на инциденты
- Заранее определенные планы действий для типовых инцидентов
- Подход "stop the line" при критических проблемах
- Быстрая эскалация к соответствующему уровню
- Post-mortem анализ после каждого крупного инцидента

## 9. Метрики и измерение

### 9.1 Метрики процесса
| Метрика | Цель | Как измеряется |
|---------|------|----------------|
| Velocity | Предсказуемость планирования | Story Points за спринт |
| Lead Time | Время от создания до доставки | Среднее время в днях |
| Cycle Time | Время активной работы | Среднее время в днях |
| Deployment Frequency | Частота релизов | Количество в неделю |
| Change Failure Rate | Качество релизов | % релизов с критическими багами |
| MTTR | Скорость восстановления | Среднее время исправления инцидента |

### 9.2 Метрики продукта
| Метрика | Цель | Как измеряется |
|---------|------|----------------|
| Test Coverage | Качество кода | % покрытия кода тестами |
| Technical Debt | Сложность поддержки | Оценка SonarQube |
| Code Smells | Качество кода | Количество на 1000 строк |
| Bug Density | Качество продукта | Количество багов на компонент |
| Uptime | Стабильность | % доступности сервиса |
| Response Time | Производительность | Среднее время ответа API |

### 9.3 Отчетность
- Автоматическая генерация отчетов из Jira и CI/CD систем
- Дэшборды для разных аудиторий (команды, менеджмент)
- Еженедельный сводный отчет по статусу разработки
- Ежемесячный отчет о метриках процесса и качества

## 10. Внедрение методологии

### 10.1 Последовательность действий
1. **Первые 2 недели**:
   - Формирование структуры команд
   - Настройка инструментов и процессов
   - Проведение тренингов по методологии
2. **Недели 3-4**:
   - Первоначальное наполнение бэклога
   - Проведение первого PI Planning
   - Начало работы команд по Scrum
3. **Недели 5-8**:
   - Первые итерации разработки
   - Настройка CI/CD-конвейера
   - Адаптация процессов на основе обратной связи
4. **Недели 9-12**:
   - Первый полноценный Program Increment
   - Полномасштабная работа всех команд
   - Ретроспектива и улучшение процессов

### 10.2 Ключевые роли во внедрении
- **Agile Coach**: обучение, консультирование, адаптация методологии
- **Руководитель разработки**: обеспечение ресурсов, устранение организационных препятствий
- **Scrum Masters**: внедрение практик на уровне команд
- **RTE**: координация на уровне программы

### 10.3 Критерии успешного внедрения
- Все команды работают в едином ритме синхронизированных спринтов
- Процесс CI/CD настроен и используется всеми командами
- Автоматизированное тестирование интегрировано в процесс разработки
- Прозрачность процесса и метрик для всех участников
- Регулярное проведение всех церемоний и встреч
- Положительная динамика ключевых метрик процесса

Не пиши код нового файла если не хватает токенов для того чтобы написать его код в этом же ответе
Пиши сразу production-ready код, ориентируйся (где нужно на использование российских сервисов)
Каждый фаил должен полностью реализовывать все в коде что он предполагает
Каждый фаил должен содержать абсолютно полный код
Предполагается что весь код будешь писать ты. Абсолютно весь
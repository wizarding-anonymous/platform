# Спецификация микросервиса "Auth Service"

## Содержание

1. [Введение](#1-введение)
2. [Глоссарий](#2-глоссарий)
3. [Архитектура](#3-архитектура)
   - [3.1 Обзор](#31-обзор)
   - [3.2 Компоненты](#32-компоненты)
   - [3.3 Технологический стек](#33-технологический-стек)
   - [3.4 Взаимодействие с другими микросервисами](#34-взаимодействие-с-другими-микросервисами)
   - [3.5 Диаграммы](#35-диаграммы)
4. [Бизнес-логика и сценарии использования](#4-бизнес-логика-и-сценарии-использования)
   - [4.1 Основные сценарии](#41-основные-сценарии)
   - [4.2 Пограничные случаи](#42-пограничные-случаи)
5. [API и интерфейсы](#5-api-и-интерфейсы)
   - [5.1 REST API](#51-rest-api)
   - [5.2 gRPC API](#52-grpc-api)
   - [5.3 События (Events)](#53-события-events)
   - [5.4 Форматы данных](#54-форматы-данных)
   - [5.5 Обработка ошибок](#55-обработка-ошибок)
6. [Интеграции](#6-интеграции)
   - [6.1 Интеграция с API Gateway](#61-интеграция-с-api-gateway)
   - [6.2 Интеграция с Account Service](#62-интеграция-с-account-service)
   - [6.3 Интеграция с Payment Service](#63-интеграция-с-payment-service)
   - [6.4 Интеграция с Developer Service](#64-интеграция-с-developer-service)
   - [6.5 Интеграция с Admin Service](#65-интеграция-с-admin-service)
   - [6.6 Интеграция с Flutter-клиентом](#66-интеграция-с-flutter-клиентом)
7. [Безопасность](#7-безопасность)
   - [7.1 Аутентификация](#71-аутентификация)
   - [7.2 Авторизация (RBAC)](#72-авторизация-rbac)
   - [7.3 Защита данных](#73-защита-данных)
   - [7.4 Управление секретами](#74-управление-секретами)
   - [7.5 Аудит безопасности](#75-аудит-безопасности)
8. [Инфраструктура и развертывание](#8-инфраструктура-и-развертывание)
   - [8.1 Dockerfile](#81-dockerfile)
   - [8.2 Kubernetes-манифесты](#82-kubernetes-манифесты)
   - [8.3 Конфигурационные параметры](#83-конфигурационные-параметры)
   - [8.4 Процесс развертывания](#84-процесс-развертывания)
9. [Мониторинг, логирование и трассировка](#9-мониторинг-логирование-и-трассировка)
   - [9.1 Мониторинг](#91-мониторинг)
   - [9.2 Логирование](#92-логирование)
   - [9.3 Трассировка](#93-трассировка)
10. [Тестирование](#10-тестирование)
    - [10.1 Стратегия тестирования](#101-стратегия-тестирования)
    - [10.2 Модульные тесты](#102-модульные-тесты)
    - [10.3 Интеграционные тесты](#103-интеграционные-тесты)
    - [10.4 Нагрузочные тесты](#104-нагрузочные-тесты)
11. [Приложения](#11-приложения)
    - [11.1 Примеры запросов/ответов API](#111-примеры-запросов-ответов-api)
    - [11.2 Схема базы данных](#112-схема-базы-данных)

## 1. Введение

Микросервис "Auth Service" является центральным компонентом платформы, отвечающим за аутентификацию и авторизацию пользователей, управление сессиями и ролями. Он обеспечивает безопасный доступ ко всем ресурсам и функциям платформы, взаимодействуя с другими микросервисами для проверки прав доступа и предоставления информации о пользователе. Auth Service реализует различные методы аутентификации, включая стандартную аутентификацию по логину/паролю, JWT-токены, интеграцию с Telegram и двухфакторную аутентификацию (2FA), а также поддерживает ролевую модель доступа (RBAC) в соответствии с Единым реестром ролей пользователей.

Основная задача Auth Service — гарантировать, что только аутентифицированные и авторизованные пользователи могут выполнять действия в системе, соответствующие их ролям и разрешениям. Сервис также отвечает за управление жизненным циклом токенов доступа и обновления, обеспечивая безопасное и удобное управление сессиями пользователей.


## 2. Глоссарий

В данном разделе приведены определения ключевых терминов, используемых в спецификации микросервиса "Auth Service", в соответствии с [Единым глоссарием терминов и определений для российского аналога Steam.txt](/home/ubuntu/upload/(Дополнительный%20фаил)%20Единый%20глоссарий%20терминов%20и%20определений%20для%20российского%20аналога%20Steam.txt).

- **Access Token (Токен доступа)**: Краткосрочный криптографический токен (обычно JWT), выдаваемый пользователю после успешной аутентификации. Используется для авторизации запросов к защищенным ресурсам API. Имеет ограниченный срок действия.
- **Account Service (Микросервис Аккаунтов)**: Микросервис, отвечающий за управление профилями пользователей, настройками, связями с социальными сетями и другой информацией, связанной с аккаунтом.
- **Admin Service (Микросервис Администрирования)**: Микросервис, предоставляющий интерфейсы для администраторов платформы для управления пользователями, контентом, настройками системы и другими административными задачами.
- **API (Application Programming Interface)**: Интерфейс программирования приложений; набор определений, протоколов и инструментов для создания программного обеспечения и приложений.
- **API Gateway (Шлюз API)**: Единая точка входа для всех клиентских запросов к микросервисам платформы. Отвечает за маршрутизацию, аутентификацию, авторизацию, агрегацию ответов и другие задачи.
- **Authentication (Аутентификация)**: Процесс проверки подлинности пользователя или системы, подтверждающий, что субъект является тем, за кого себя выдает.
- **Authorization (Авторизация)**: Процесс определения прав доступа аутентифицированного пользователя или системы к определенным ресурсам или функциям.
- **Auth Service (Микросервис Аутентификации)**: Данный микросервис, отвечающий за аутентификацию и авторизацию пользователей, управление сессиями, ролями и токенами.
- **Backend**: Серверная часть приложения, отвечающая за обработку бизнес-логики, взаимодействие с базами данных и предоставление API для клиентских приложений.
- **bcrypt**: Адаптивная криптографическая хеш-функция для хранения паролей, устойчивая к атакам перебора.
- **Biometric Authentication (Биометрическая аутентификация)**: Метод аутентификации, использующий уникальные биологические характеристики пользователя (например, отпечаток пальца, распознавание лица) для подтверждения личности.
- **CI/CD (Continuous Integration/Continuous Delivery)**: Практики непрерывной интеграции и непрерывной доставки, направленные на автоматизацию сборки, тестирования и развертывания программного обеспечения.
- **ConfigMap**: Объект Kubernetes для хранения неконфиденциальных конфигурационных данных в виде пар ключ-значение.
- **CORS (Cross-Origin Resource Sharing)**: Механизм, позволяющий веб-странице запрашивать ресурсы с другого домена (источника), отличного от того, с которого была загружена сама страница.
- **CRUD (Create, Read, Update, Delete)**: Базовые операции для работы с данными: Создание, Чтение, Обновление, Удаление.
- **Deployment (Развертывание)**: Процесс установки и настройки программного обеспечения для использования в определенной среде (например, продакшен).
- **Docker**: Платформа для разработки, доставки и запуска приложений в контейнерах.
- **Dockerfile**: Текстовый файл, содержащий инструкции для сборки образа Docker.
- **ELK Stack (Elasticsearch, Logstash, Kibana)**: Популярный стек технологий для сбора, обработки, хранения и визуализации логов.
- **Endpoint (Эндпоинт)**: Конечная точка API, представляющая собой URL-адрес, по которому можно получить доступ к определенному ресурсу или выполнить операцию.
- **ETag (Entity Tag)**: HTTP-заголовок, используемый для кэширования и условных запросов. Представляет собой идентификатор конкретной версии ресурса.
- **Event (Событие)**: Сообщение, передаваемое между компонентами системы (часто асинхронно), информирующее о произошедшем изменении состояния или действии.
- **Flutter**: UI-фреймворк от Google для создания нативных приложений для мобильных, веб- и десктопных платформ из единой кодовой базы.
- **Frontend**: Клиентская часть приложения, с которой взаимодействует пользователь (например, веб-интерфейс, мобильное приложение).
- **Gin (gin-gonic/gin)**: Высокопроизводительный HTTP-фреймворк для языка Go.
- **Go (Golang)**: Компилируемый многопоточный язык программирования, разработанный Google.
- **golang-migrate**: Инструмент для управления миграциями схемы базы данных для Go-приложений.
- **go-redis**: Клиентская библиотека для работы с Redis на языке Go.
- **gRPC (gRPC Remote Procedure Calls)**: Высокопроизводительный фреймворк RPC (удаленный вызов процедур) с открытым исходным кодом, разработанный Google.
- **gzip**: Формат сжатия файлов и утилита для сжатия/распаковки.
- **Helm**: Менеджер пакетов для Kubernetes, упрощающий развертывание и управление приложениями.
- **HTTP (Hypertext Transfer Protocol)**: Протокол передачи данных, используемый в веб-технологиях.
- **HTTPS (Hypertext Transfer Protocol Secure)**: Расширение протокола HTTP, поддерживающее шифрование с помощью TLS/SSL.
- **Idempotency (Идемпотентность)**: Свойство операции, при котором ее многократное выполнение дает тот же результат, что и однократное.
- **If-Modified-Since**: HTTP-заголовок, используемый для условных запросов, позволяющий серверу не отправлять ресурс, если он не изменился с указанной даты.
- **Infrastructure (Инфраструктура)**: Совокупность аппаратных и программных средств, обеспечивающих функционирование информационной системы.
- **Integration (Интеграция)**: Процесс объединения различных программных компонентов или систем для совместной работы.
- **Istio**: Платформа service mesh с открытым исходным кодом для управления, защиты и мониторинга микросервисов.
- **Jaeger**: Распределенная система трассировки с открытым исходным кодом.
- **JSON (JavaScript Object Notation)**: Текстовый формат обмена данными, основанный на синтаксисе JavaScript.
- **JWT (JSON Web Token)**: Открытый стандарт (RFC 7519) для создания токенов доступа, которые содержат JSON-объект с утверждениями (claims). Используется для безопасной передачи информации между сторонами.
- **jwt-go**: Библиотека для работы с JWT на языке Go.
- **Kafka (Apache Kafka)**: Распределенная платформа потоковой обработки событий.
- **Kubernetes (K8s)**: Платформа с открытым исходным кодом для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями.
- **Load Balancing (Балансировка нагрузки)**: Распределение входящих запросов между несколькими серверами для повышения производительности и отказоустойчивости.
- **Logging (Логирование)**: Процесс записи информации о событиях, происходящих в системе, для последующего анализа и отладки.
- **Logrus**: Популярная библиотека для структурированного логирования на языке Go.
- **Microservice (Микросервис)**: Архитектурный стиль, при котором приложение строится как набор небольших, независимо развертываемых сервисов.
- **Monitoring (Мониторинг)**: Процесс сбора и анализа данных о производительности и состоянии системы для обеспечения ее стабильной работы.
- **Notification Service (Микросервис Уведомлений)**: Микросервис, отвечающий за отправку уведомлений пользователям через различные каналы (WebSocket, push-уведомления, email).
- **OAuth 2.0**: Открытый протокол авторизации, позволяющий приложениям получать ограниченный доступ к учетным записям пользователей на других сервисах.
- **OpenTelemetry (OTel)**: Набор API, SDK, инструментов и интеграций для сбора и экспорта данных телеметрии (метрик, логов, трассировок).
- **Password Hashing (Хеширование паролей)**: Процесс преобразования пароля в необратимую строку символов (хеш) для безопасного хранения.
- **Payment Service (Микросервис Платежей)**: Микросервис, отвечающий за обработку платежей, управление подписками и взаимодействие с платежными шлюзами.
- **Permission (Разрешение)**: Конкретное право на выполнение определенного действия или доступ к определенному ресурсу.
- **pgx**: Библиотека для работы с PostgreSQL на языке Go.
- **PostgreSQL**: Мощная объектно-реляционная система управления базами данных с открытым исходным кодом.
- **Prometheus**: Система мониторинга и оповещения с открытым исходным кодом.
- **prometheus-client**: Библиотека для инструментирования Go-приложений метриками Prometheus.
- **Protocol Buffers (Protobuf)**: Механизм сериализации структурированных данных, разработанный Google. Используется в gRPC.
- **RBAC (Role-Based Access Control)**: Модель управления доступом на основе ролей, где разрешения назначаются ролям, а роли — пользователям.
- **Redis**: Быстрое хранилище данных типа "ключ-значение", часто используемое для кэширования и обмена сообщениями.
- **Refresh Token (Токен обновления)**: Долгосрочный токен, используемый для безопасного получения нового Access Token без необходимости повторной аутентификации пользователя.
- **REST (Representational State Transfer)**: Архитектурный стиль для построения распределенных систем, часто используемый для создания веб-сервисов.
- **Role (Роль)**: Набор разрешений, определяющий уровень доступа пользователя к ресурсам и функциям системы.
- **RPC (Remote Procedure Call)**: Технология, позволяющая программе вызывать процедуру (функцию) в другом адресном пространстве (обычно на другом компьютере).
- **Secret**: Объект Kubernetes для хранения конфиденциальных данных, таких как пароли, токены или ключи.
- **Security (Безопасность)**: Комплекс мер, направленных на защиту системы от несанкционированного доступа, использования, раскрытия, изменения или уничтожения.
- **Service (Сервис)**: В контексте Kubernetes — абстракция, определяющая логический набор подов и политику доступа к ним.
- **Service Mesh**: Инфраструктурный уровень для управления взаимодействием между микросервисами.
- **Session (Сессия)**: Период взаимодействия пользователя с системой, обычно связанный с аутентификацией и хранением состояния.
- **Specification (Спецификация)**: Подробное описание требований, дизайна или характеристик системы или ее компонента.
- **SSL (Secure Sockets Layer)**: Криптографический протокол, обеспечивающий безопасную передачу данных. Предшественник TLS.
- **Stateless/Stateful**: Свойство компонента системы. Stateless-компоненты не хранят состояние между запросами, Stateful — хранят.
- **Telegram Login**: Механизм аутентификации пользователей через их аккаунт в мессенджере Telegram.
- **Testing (Тестирование)**: Процесс проверки программного обеспечения на соответствие требованиям и выявление ошибок.
- **TLS (Transport Layer Security)**: Криптографический протокол, обеспечивающий безопасную передачу данных по сети. Пришел на смену SSL.
- **Token (Токен)**: Строка символов, используемая для представления прав доступа или идентификации.
- **Tracing (Трассировка)**: Метод мониторинга и отладки распределенных систем путем отслеживания пути запроса через различные компоненты.
- **2FA (Two-Factor Authentication / Двухфакторная аутентификация)**: Метод аутентификации, требующий от пользователя предоставления двух различных типов доказательств своей личности (например, пароль и код из SMS).
- **UI (User Interface)**: Пользовательский интерфейс; средства, с помощью которых пользователь взаимодействует с системой.
- **UUID (Universally Unique Identifier)**: 128-битный идентификатор, гарантирующий уникальность в распределенных системах.
- **Validation (Валидация)**: Проверка данных на соответствие определенным правилам или формату.
- **Vault (HashiCorp Vault)**: Инструмент для безопасного хранения и управления секретами.
- **Versioning (Версионирование)**: Процесс управления различными версиями программного обеспечения, API или данных.
- **WebSocket**: Протокол связи, обеспечивающий полнодуплексное соединение между клиентом и сервером через одно TCP-соединение.
- **YAML (YAML Ain't Markup Language)**: Человекочитаемый формат сериализации данных, часто используемый для конфигурационных файлов.
- **Zap**: Быстрая, структурированная библиотека логирования для Go.


## 3. Архитектура

### 3.1 Обзор

Auth Service построен на основе микросервисной архитектуры с использованием языка Go. Он представляет собой stateless-сервис, взаимодействующий с другими компонентами системы через REST API, gRPC и асинхронные события Kafka. Сервис использует PostgreSQL в качестве основной базы данных для хранения информации о пользователях, ролях, сессиях и токенах, а также Redis для кэширования данных сессий и временных токенов.

Сервис развертывается в виде Docker-контейнера под управлением Kubernetes, что обеспечивает масштабируемость и отказоустойчивость. Управление конфигурацией и секретами осуществляется через Kubernetes ConfigMaps/Secrets и HashiCorp Vault.

### 3.2 Компоненты

- **API Layer (REST/gRPC)**: Обрабатывает входящие запросы от API Gateway и других микросервисов. Отвечает за валидацию запросов, аутентификацию и авторизацию.
- **Business Logic Layer**: Реализует основную логику аутентификации (JWT, Telegram, 2FA), авторизации (RBAC), управления сессиями и токенами.
- **Data Access Layer**: Отвечает за взаимодействие с базой данных (PostgreSQL) и кэшем (Redis).
- **Event Publisher/Consumer**: Публикует события об изменениях (например, `user.registered`) и потребляет события от других сервисов через Kafka.

### 3.3 Технологический стек

#### Backend
- **Язык программирования**: Go (версия 1.21+)
- **Веб-фреймворк (REST)**: Gin (gin-gonic/gin)
- **gRPC фреймворк**: google.golang.org/grpc
- **База данных**: PostgreSQL (версия 15+)
- **ORM/Драйвер БД**: pgx
- **Кэш**: Redis (версия 7+)
- **Клиент кэша**: go-redis
- **Очередь сообщений**: Apache Kafka
- **Клиент Kafka**: confluent-kafka-go
- **Работа с JWT**: jwt-go (или альтернатива, например, golang-jwt/jwt)
- **Хеширование паролей**: bcrypt (golang.org/x/crypto/bcrypt)
- **Логирование**: Zap или Logrus
- **Мониторинг (метрики)**: Prometheus (prometheus-client)
- **Трассировка**: OpenTelemetry (OTel)
- **Миграции БД**: golang-migrate
- **Контейнеризация**: Docker
- **Оркестрация**: Kubernetes (K8s)
- **Управление релизами**: Helm
- **Управление секретами**: HashiCorp Vault, Kubernetes Secrets
- **Service Mesh (опционально)**: Istio

#### Frontend (Клиентское приложение)
- **Фреймворк**: Flutter (версия 3.10+)
- **Язык**: Dart
- **Управление состоянием**: Provider, Riverpod, BLoC (на выбор команды)
- **Работа с сетью**: http, dio
- **Хранение токенов**: flutter_secure_storage
- **Локальная БД/Кэш**: Hive, sqflite
- **Биометрическая аутентификация**: local_auth

### 3.4 Взаимодействие с другими микросервисами

Auth Service активно взаимодействует со следующими микросервисами:

- **API Gateway**: Принимает все запросы от клиентов, валидирует токены через Auth Service, проксирует запросы к Auth Service.
- **Account Service**: Создает профили пользователей при регистрации (через REST API или событие `user.registered`), получает информацию о пользователе для проверки статуса.
- **Payment Service**: Предоставляет информацию об аутентификации пользователя для проведения платежных операций.
- **Developer Service**: Предоставляет информацию о ролях и разрешениях разработчиков.
- **Admin Service**: Предоставляет API для управления пользователями и ролями администраторами.
- **Notification Service**: Потребляет события (например, о необходимости подтверждения email/телефона) для отправки уведомлений.

Взаимодействие осуществляется через синхронные (REST, gRPC) и асинхронные (Kafka Events) механизмы.

### 3.5 Диаграммы

*(Примечание: Диаграммы должны быть добавлены в виде изображений или ссылок на внешние ресурсы. Здесь приведено только их описание.)*

- **Диаграмма архитектуры**: Визуальное представление компонентов Auth Service и их связей.
- **Диаграмма взаимодействия**: Схема, показывающая потоки запросов и событий между Auth Service и другими микросервисами (API Gateway, Account Service, etc.).
- **Диаграмма потоков данных**: Иллюстрация движения данных пользователя при аутентификации, регистрации и управлении сессией.
- **Диаграмма последовательности (Sequence Diagram)**: Детальное описание шагов для ключевых сценариев, таких как JWT-аутентификация, обновление токена, Telegram-логин.
- **Схема базы данных**: ER-диаграмма таблиц PostgreSQL, используемых Auth Service.

## 4. Бизнес-логика и сценарии использования

### 4.1 Основные сценарии

#### Регистрация пользователя
1. Пользователь отправляет запрос на регистрацию с email, паролем и другими необходимыми данными
2. Auth Service валидирует данные (формат email, сложность пароля и т.д.)
3. Проверяет, не существует ли уже пользователь с таким email
4. Хеширует пароль с использованием bcrypt
5. Создает запись пользователя в базе данных
6. Генерирует токен подтверждения email
7. Публикует событие `user.registered` для Account Service
8. Возвращает успешный ответ с временным токеном доступа

#### Аутентификация по логину/паролю
1. Пользователь отправляет запрос на аутентификацию с email и паролем
2. Auth Service находит пользователя по email
3. Проверяет хеш пароля
4. Если включена 2FA, запрашивает второй фактор
5. Генерирует пару токенов (Access Token и Refresh Token)
6. Сохраняет информацию о сессии и Refresh Token
7. Возвращает токены клиенту

#### Аутентификация через Telegram
1. Пользователь инициирует процесс Telegram-авторизации
2. Auth Service генерирует уникальный идентификатор запроса
3. Клиент получает данные от Telegram (через Telegram Login Widget)
4. Клиент отправляет полученные данные в Auth Service
5. Auth Service верифицирует данные с использованием Telegram API
6. Находит или создает пользователя, связанного с Telegram ID
7. Генерирует пару токенов (Access Token и Refresh Token)
8. Возвращает токены клиенту

#### Обновление токена доступа
1. Клиент отправляет запрос с истекшим Access Token и действующим Refresh Token
2. Auth Service валидирует Refresh Token
3. Проверяет, не был ли Refresh Token отозван или скомпрометирован
4. Генерирует новую пару токенов
5. Обновляет информацию о сессии
6. Возвращает новые токены клиенту

#### Проверка прав доступа
1. Другой микросервис отправляет запрос на проверку прав доступа с токеном и требуемым разрешением
2. Auth Service валидирует токен
3. Извлекает роль пользователя и связанные разрешения
4. Проверяет наличие требуемого разрешения
5. Возвращает результат проверки

#### Управление ролями пользователей
1. Администратор отправляет запрос на изменение роли пользователя
2. Auth Service проверяет права администратора
3. Валидирует запрашиваемую роль
4. Обновляет роль пользователя в базе данных
5. Публикует событие об изменении роли
6. Возвращает обновленную информацию о пользователе

### 4.2 Пограничные случаи

#### Обработка блокировки аккаунта
1. При обнаружении подозрительной активности (множественные неудачные попытки входа)
2. Auth Service временно блокирует аккаунт
3. Записывает информацию о блокировке в журнал аудита
4. Публикует событие о блокировке для Notification Service
5. Возвращает соответствующую ошибку при попытках аутентификации

#### Восстановление пароля
1. Пользователь запрашивает восстановление пароля
2. Auth Service генерирует уникальный токен восстановления с ограниченным сроком действия
3. Публикует событие для Notification Service для отправки email
4. При получении запроса с токеном восстановления проверяет его валидность
5. Позволяет пользователю установить новый пароль
6. Отзывает все активные сессии пользователя

#### Отзыв всех токенов пользователя
1. Пользователь или администратор запрашивает выход из всех устройств
2. Auth Service отмечает все Refresh Token пользователя как отозванные
3. Добавляет все активные Access Token в черный список (в Redis)
4. Публикует событие об отзыве токенов
5. Возвращает подтверждение операции

## 5. API и интерфейсы

### 5.1 REST API

Auth Service предоставляет следующие REST API эндпоинты:

#### Аутентификация и управление сессиями

| Метод | Путь | Описание | Параметры запроса | Ответ |
|-------|------|----------|------------------|-------|
| POST | `/api/v1/auth/register` | Регистрация нового пользователя | `email`, `password`, `username` (опционально) | `201 Created` с временным токеном |
| POST | `/api/v1/auth/login` | Аутентификация по логину/паролю | `email`, `password` | `200 OK` с токенами |
| POST | `/api/v1/auth/telegram-login` | Аутентификация через Telegram | Данные от Telegram Login Widget | `200 OK` с токенами |
| POST | `/api/v1/auth/refresh-token` | Обновление токена доступа | `refresh_token` | `200 OK` с новыми токенами |
| POST | `/api/v1/auth/logout` | Выход из системы (отзыв текущего токена) | - | `204 No Content` |
| POST | `/api/v1/auth/logout-all` | Выход из всех устройств | - | `204 No Content` |
| POST | `/api/v1/auth/verify-email` | Подтверждение email | `token` | `200 OK` |
| POST | `/api/v1/auth/resend-verification` | Повторная отправка подтверждения | `email` | `200 OK` |
| POST | `/api/v1/auth/forgot-password` | Запрос на восстановление пароля | `email` | `200 OK` |
| POST | `/api/v1/auth/reset-password` | Сброс пароля | `token`, `new_password` | `200 OK` |
| POST | `/api/v1/auth/2fa/enable` | Включение 2FA | - | `200 OK` с QR-кодом |
| POST | `/api/v1/auth/2fa/verify` | Проверка кода 2FA | `code` | `200 OK` |
| POST | `/api/v1/auth/2fa/disable` | Отключение 2FA | `code` | `200 OK` |

#### Управление пользователями и ролями

| Метод | Путь | Описание | Параметры запроса | Ответ |
|-------|------|----------|------------------|-------|
| GET | `/api/v1/auth/users` | Получение списка пользователей (для админов) | Параметры пагинации | `200 OK` со списком |
| GET | `/api/v1/auth/users/{id}` | Получение информации о пользователе | - | `200 OK` с данными |
| PUT | `/api/v1/auth/users/{id}` | Обновление информации о пользователе | Обновляемые поля | `200 OK` с обновленными данными |
| DELETE | `/api/v1/auth/users/{id}` | Удаление пользователя | - | `204 No Content` |
| GET | `/api/v1/auth/roles` | Получение списка ролей | - | `200 OK` со списком |
| POST | `/api/v1/auth/users/{id}/roles` | Назначение роли пользователю | `role_id` | `200 OK` |
| DELETE | `/api/v1/auth/users/{id}/roles/{role_id}` | Удаление роли у пользователя | - | `204 No Content` |

#### Валидация и проверка прав

| Метод | Путь | Описание | Параметры запроса | Ответ |
|-------|------|----------|------------------|-------|
| POST | `/api/v1/auth/validate-token` | Проверка валидности токена | `token` (в заголовке) | `200 OK` с данными пользователя |
| POST | `/api/v1/auth/check-permission` | Проверка наличия разрешения | `permission`, `token` (в заголовке) | `200 OK` с результатом |

### 5.2 gRPC API

Auth Service также предоставляет gRPC API для высокопроизводительного взаимодействия с другими микросервисами:

```protobuf
syntax = "proto3";

package auth;

service AuthService {
  // Валидация токена
  rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse);
  
  // Проверка разрешения
  rpc CheckPermission(CheckPermissionRequest) returns (CheckPermissionResponse);
  
  // Получение информации о пользователе
  rpc GetUser(GetUserRequest) returns (UserResponse);
  
  // Получение ролей пользователя
  rpc GetUserRoles(GetUserRequest) returns (UserRolesResponse);
}

message ValidateTokenRequest {
  string token = 1;
}

message ValidateTokenResponse {
  bool valid = 1;
  string user_id = 2;
  repeated string roles = 3;
  int64 expires_at = 4;
}

message CheckPermissionRequest {
  string token = 1;
  string permission = 2;
}

message CheckPermissionResponse {
  bool has_permission = 1;
}

message GetUserRequest {
  string user_id = 1;
}

message UserResponse {
  string id = 1;
  string email = 2;
  string username = 3;
  bool email_verified = 4;
  bool two_factor_enabled = 5;
  int64 created_at = 6;
  int64 updated_at = 7;
}

message UserRolesResponse {
  string user_id = 1;
  repeated Role roles = 2;
}

message Role {
  string id = 1;
  string name = 2;
  repeated string permissions = 3;
}
```

### 5.3 События (Events)

Auth Service публикует и потребляет следующие события через Kafka:

#### Публикуемые события

| Событие | Топик | Формат | Описание |
|---------|-------|--------|----------|
| `user.registered` | `auth.events` | `{"event_type": "user.registered", "payload": {"user_id": "uuid", "email": "string", "username": "string", "created_at": "timestamp"}}` | Публикуется при успешной регистрации пользователя |
| `user.email_verified` | `auth.events` | `{"event_type": "user.email_verified", "payload": {"user_id": "uuid", "email": "string", "verified_at": "timestamp"}}` | Публикуется при подтверждении email |
| `user.role_changed` | `auth.events` | `{"event_type": "user.role_changed", "payload": {"user_id": "uuid", "old_roles": ["role1"], "new_roles": ["role1", "role2"], "changed_by": "uuid", "changed_at": "timestamp"}}` | Публикуется при изменении ролей пользователя |
| `user.password_reset` | `auth.events` | `{"event_type": "user.password_reset", "payload": {"user_id": "uuid", "reset_at": "timestamp"}}` | Публикуется при сбросе пароля |
| `user.account_locked` | `auth.events` | `{"event_type": "user.account_locked", "payload": {"user_id": "uuid", "reason": "string", "locked_at": "timestamp", "unlock_at": "timestamp"}}` | Публикуется при блокировке аккаунта |

#### Потребляемые события

| Событие | Топик | Формат | Описание |
|---------|-------|--------|----------|
| `user.deleted` | `account.events` | `{"event_type": "user.deleted", "payload": {"user_id": "uuid", "deleted_at": "timestamp"}}` | Обрабатывается для удаления данных аутентификации |
| `user.status_changed` | `account.events` | `{"event_type": "user.status_changed", "payload": {"user_id": "uuid", "old_status": "string", "new_status": "string", "changed_at": "timestamp"}}` | Обрабатывается для обновления статуса пользователя |

### 5.4 Форматы данных

#### Пользователь (User)

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "username": "username",
  "email_verified": true,
  "two_factor_enabled": false,
  "status": "active",
  "roles": ["user"],
  "created_at": "2023-01-01T12:00:00Z",
  "updated_at": "2023-01-02T14:30:00Z"
}
```

#### Токены (Tokens)

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

#### Роль (Role)

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440001",
  "name": "admin",
  "description": "Администратор системы",
  "permissions": [
    "users.read",
    "users.write",
    "roles.read",
    "roles.write"
  ],
  "created_at": "2023-01-01T12:00:00Z",
  "updated_at": "2023-01-01T12:00:00Z"
}
```

#### Ошибка (Error)

```json
{
  "error": {
    "code": "auth_error",
    "message": "Неверный email или пароль",
    "details": {
      "field": "password",
      "reason": "invalid"
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440002"
  }
}
```

### 5.5 Обработка ошибок

Auth Service использует стандартизированный формат ошибок для всех API:

| Код HTTP | Код ошибки | Описание |
|----------|------------|----------|
| 400 | `validation_error` | Ошибка валидации данных |
| 401 | `unauthorized` | Отсутствие или недействительность токена аутентификации |
| 403 | `forbidden` | Недостаточно прав для выполнения операции |
| 404 | `not_found` | Запрашиваемый ресурс не найден |
| 409 | `conflict` | Конфликт данных (например, email уже существует) |
| 422 | `unprocessable_entity` | Невозможно обработать запрос |
| 429 | `too_many_requests` | Превышен лимит запросов |
| 500 | `internal_error` | Внутренняя ошибка сервера |

Все ошибки включают уникальный `request_id` для отслеживания и отладки, а также детали ошибки, когда это применимо.

## 6. Интеграции

### 6.1 Интеграция с API Gateway

API Gateway является единой точкой входа для всех клиентских запросов к Auth Service. Интеграция осуществляется через REST API и включает следующие аспекты:

#### Проксирование запросов
API Gateway проксирует запросы к Auth Service, добавляя необходимые заголовки и выполняя базовую валидацию:
- Все запросы к `/api/v1/auth/*` направляются в Auth Service
- Добавляются заголовки `X-Request-ID`, `X-Real-IP` и другие служебные заголовки
- Выполняется базовая валидация формата запросов

#### Валидация токенов
API Gateway использует эндпоинт `/api/v1/auth/validate-token` для проверки токенов доступа:
- Извлекает токен из заголовка `Authorization`
- Отправляет запрос на валидацию в Auth Service
- Кэширует результаты валидации для оптимизации производительности
- Добавляет информацию о пользователе в заголовки запросов к другим микросервисам

#### Обработка истекших токенов
API Gateway реализует прозрачное обновление истекших токенов:
- При получении ошибки 401 с кодом `token_expired` от Auth Service
- Если в запросе присутствует валидный Refresh Token
- Автоматически запрашивает новую пару токенов
- Повторяет исходный запрос с новым Access Token

#### Оптимизация для Flutter-клиента
- Поддержка CORS для веб-версии Flutter-приложения
- Сжатие ответов (gzip) для оптимизации трафика
- Поддержка условных запросов (ETag, If-Modified-Since)
- Стандартизированный формат ошибок для удобной обработки на клиенте

### 6.2 Интеграция с Account Service

Auth Service тесно интегрируется с Account Service для управления профилями пользователей:

#### Создание профиля пользователя
При регистрации нового пользователя:
- Auth Service создает базовую запись пользователя с учетными данными
- Публикует событие `user.registered` в Kafka
- Account Service подписан на это событие и создает полный профиль пользователя
- Альтернативно, Auth Service может напрямую вызвать API Account Service для создания профиля

#### Синхронизация данных пользователя
- Auth Service запрашивает статус пользователя у Account Service перед аутентификацией
- Account Service уведомляет Auth Service об изменениях статуса пользователя через события
- При удалении аккаунта в Account Service, Auth Service получает событие и удаляет данные аутентификации

#### Связывание с Telegram-аккаунтом
- Auth Service обрабатывает данные Telegram Login Widget
- Верифицирует данные через Telegram API
- Связывает Telegram ID с аккаунтом пользователя
- Отправляет информацию о связывании в Account Service для обновления профиля

### 6.3 Интеграция с Payment Service

Auth Service предоставляет Payment Service информацию для проверки аутентификации и авторизации при платежных операциях:

#### Проверка прав доступа для платежей
- Payment Service запрашивает проверку прав через gRPC API
- Auth Service проверяет наличие необходимых разрешений у пользователя
- Возвращает результат проверки и информацию о пользователе
- Записывает информацию о запросе в журнал аудита

#### Дополнительная аутентификация для критичных операций
- Payment Service может запросить дополнительную аутентификацию для крупных платежей
- Auth Service предоставляет механизм одноразовых кодов или 2FA
- Верифицирует дополнительные факторы аутентификации
- Возвращает результат верификации

### 6.4 Интеграция с Developer Service

Auth Service взаимодействует с Developer Service для управления ролями и разрешениями разработчиков:

#### Управление ролями разработчиков
- Developer Service запрашивает информацию о ролях через gRPC API
- Auth Service предоставляет специальные роли для разработчиков
- Обрабатывает запросы на изменение ролей от Developer Service
- Публикует события об изменении ролей

#### Проверка прав доступа разработчиков
- Developer Service запрашивает проверку прав для доступа к API и ресурсам
- Auth Service проверяет наличие необходимых разрешений
- Возвращает детальную информацию о доступных разрешениях
- Обеспечивает гранулярный контроль доступа к различным функциям

### 6.5 Интеграция с Admin Service

Admin Service использует расширенные возможности Auth Service для управления пользователями и их правами:

#### Управление пользователями
- Admin Service получает доступ к API для создания, обновления и удаления пользователей
- Auth Service предоставляет расширенные возможности фильтрации и поиска
- Обеспечивает пагинацию результатов для эффективной работы с большими списками
- Предоставляет детальную информацию о пользователях и их сессиях

#### Управление ролями и разрешениями
- Admin Service использует API для назначения и отзыва ролей
- Auth Service обеспечивает валидацию изменений согласно политикам безопасности
- Записывает все административные действия в журнал аудита
- Публикует события об изменениях для других заинтересованных сервисов

#### Аудит действий
- Admin Service получает доступ к журналам аудита безопасности
- Auth Service предоставляет API для поиска и фильтрации записей аудита
- Обеспечивает неизменяемость записей аудита
- Предоставляет механизмы экспорта данных аудита

### 6.6 Интеграция с Flutter-клиентом

Auth Service оптимизирован для работы с Flutter-клиентом через API Gateway:

#### Аутентификация на клиенте
- Поддержка стандартных механизмов аутентификации (логин/пароль)
- Интеграция с Telegram Login Widget для Flutter
- Поддержка биометрической аутентификации через local_auth
- Безопасное хранение токенов с использованием flutter_secure_storage

#### Управление токенами на клиенте
- Автоматическое обновление токенов при истечении срока действия
- Прозрачная для пользователя обработка ошибок аутентификации
- Механизмы для безопасного выхода из системы
- Поддержка множественных устройств одного пользователя

#### Оптимизации для мобильных устройств
- Минимизация размера ответов для экономии трафика
- Поддержка сжатия данных (gzip)
- Эффективное кэширование на клиенте
- Адаптивные таймауты для работы в условиях нестабильного соединения

## 7. Безопасность

### 7.1 Аутентификация

Auth Service поддерживает несколько методов аутентификации:

#### JWT-аутентификация
- Использование JWT (JSON Web Tokens) для безопасной передачи информации о пользователе
- Структура токена включает стандартные поля (iss, sub, exp, iat) и дополнительные claims (roles, permissions)
- Подпись токенов с использованием алгоритма HMAC SHA-256 (HS256) или RSA (RS256)
- Срок действия Access Token: 15-60 минут (настраивается)
- Срок действия Refresh Token: 7-30 дней (настраивается)

#### Telegram-авторизация
- Интеграция с Telegram Login Widget для аутентификации через Telegram
- Верификация данных с использованием Telegram Bot API
- Связывание Telegram ID с аккаунтом пользователя
- Поддержка автоматического создания аккаунта при первой авторизации через Telegram

#### Двухфакторная аутентификация (2FA)
- Поддержка TOTP (Time-based One-Time Password) по стандарту RFC 6238
- Генерация и верификация одноразовых кодов
- Безопасное хранение секретных ключей
- Резервные коды для восстановления доступа

#### Биометрическая аутентификация
- Поддержка на стороне клиента через Flutter local_auth
- Локальная верификация биометрических данных на устройстве
- Безопасное хранение токенов, защищенных биометрией
- Совместимость с различными типами биометрических сенсоров (отпечаток пальца, Face ID)

### 7.2 Авторизация (RBAC)

Auth Service реализует ролевую модель контроля доступа (RBAC) в соответствии с Единым реестром ролей:

#### Роли пользователей
- **guest**: Неаутентифицированный пользователь с минимальными правами
- **user**: Базовая роль для всех аутентифицированных пользователей
- **premium_user**: Пользователь с премиум-подпиской
- **developer**: Разработчик, имеющий доступ к Developer API
- **publisher**: Издатель, имеющий расширенные права для публикации контента
- **moderator**: Модератор с правами на модерацию контента
- **admin**: Администратор с расширенными правами управления
- **system_admin**: Системный администратор с полным доступом

#### Иерархия ролей
- Роли образуют иерархию, где каждая роль наследует разрешения нижестоящих ролей
- Пользователь может иметь несколько ролей одновременно
- Эффективные разрешения пользователя — объединение разрешений всех его ролей

#### Матрица доступа
| Ресурс/Действие | guest | user | premium_user | developer | publisher | moderator | admin | system_admin |
|-----------------|-------|------|--------------|-----------|-----------|-----------|-------|--------------|
| Просмотр публичного профиля | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| Редактирование своего профиля | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| Просмотр списка пользователей | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ |
| Управление пользователями | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ |
| Управление ролями | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ |
| Просмотр журналов аудита | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ |
| Управление системными настройками | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ |

#### Проверка разрешений
- Проверка разрешений осуществляется на уровне API Gateway и внутри микросервисов
- Используется механизм claims в JWT-токенах для эффективной проверки
- Поддерживается кэширование разрешений для оптимизации производительности
- Реализована детальная проверка на уровне ресурсов и действий

### 7.3 Защита данных

#### Хранение паролей
- Хеширование паролей с использованием bcrypt (cost factor: 12+)
- Добавление уникальной соли для каждого пароля
- Регулярное обновление алгоритмов хеширования при необходимости
- Проверка сложности паролей при регистрации и смене

#### Шифрование данных
- Шифрование чувствительных данных в базе данных (AES-256)
- Использование TLS 1.3 для всех сетевых взаимодействий
- Шифрование Refresh Token в базе данных
- Защита от атак типа "человек посередине" (MITM)

#### Защита от распространенных атак
- Защита от SQL-инъекций через параметризованные запросы и ORM
- Защита от XSS через валидацию входных данных и заголовки Content-Security-Policy
- Защита от CSRF через токены и проверку Origin/Referer
- Защита от перебора паролей через ограничение попыток и временную блокировку

#### Обработка персональных данных
- Соответствие требованиям законодательства о персональных данных
- Минимизация собираемых данных
- Механизмы для удаления данных по запросу пользователя
- Журналирование доступа к персональным данным

### 7.4 Управление секретами

#### Хранение секретов
- Использование HashiCorp Vault для централизованного хранения секретов
- Ротация ключей шифрования и подписи JWT по расписанию
- Безопасное хранение учетных данных для внешних сервисов
- Интеграция с Kubernetes Secrets для доступа к секретам в runtime

#### Управление доступом к секретам
- Строгое разграничение доступа к секретам по принципу наименьших привилегий
- Аудит всех операций с секретами
- Автоматическая ротация учетных данных
- Интеграция с системой управления идентификацией для аутентификации сервисов

### 7.5 Аудит безопасности

#### Журналирование событий безопасности
- Журналирование всех попыток аутентификации (успешных и неуспешных)
- Журналирование изменений ролей и разрешений
- Журналирование доступа к чувствительным данным
- Журналирование административных действий

#### Анализ журналов
- Агрегация журналов в централизованной системе (ELK Stack)
- Автоматическое обнаружение подозрительной активности
- Оповещения о потенциальных инцидентах безопасности
- Сохранение журналов в соответствии с политикой хранения

## 8. Инфраструктура и развертывание

### 8.1 Dockerfile

Auth Service использует многоэтапный Dockerfile для оптимизации размера и безопасности образа:

```dockerfile
# Этап сборки
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Установка зависимостей
COPY go.mod go.sum ./
RUN go mod download

# Копирование исходного кода
COPY . .

# Сборка приложения
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o auth-service ./cmd/auth-service

# Этап финального образа
FROM alpine:3.18

# Установка необходимых пакетов
RUN apk --no-cache add ca-certificates tzdata && \
    addgroup -S appgroup && adduser -S appuser -G appgroup

# Копирование бинарного файла из этапа сборки
COPY --from=builder /app/auth-service /usr/local/bin/

# Копирование конфигурационных файлов
COPY --from=builder /app/configs /etc/auth-service

# Переключение на непривилегированного пользователя
USER appuser

# Определение точки входа
ENTRYPOINT ["auth-service"]
CMD ["--config", "/etc/auth-service/config.yaml"]

# Метаданные
LABEL maintainer="DevOps Team <devops@example.com>"
LABEL version="1.0.0"
LABEL description="Auth Service for Russian Steam Alternative"

# Проверка работоспособности
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget -q -O- http://localhost:8080/health || exit 1

# Порты
EXPOSE 8080 9090
```

### 8.2 Kubernetes-манифесты

#### Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: platform
  labels:
    app: auth-service
    component: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: auth-service
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: auth-service
        component: backend
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: auth-service
        image: ${REGISTRY}/auth-service:${VERSION}
        imagePullPolicy: Always
        ports:
        - name: http
          containerPort: 8080
        - name: grpc
          containerPort: 9090
        - name: metrics
          containerPort: 9091
        env:
        - name: CONFIG_FILE
          value: "/etc/auth-service/config.yaml"
        - name: LOG_LEVEL
          value: "info"
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: config
          mountPath: /etc/auth-service
          readOnly: true
        - name: secrets
          mountPath: /etc/auth-service/secrets
          readOnly: true
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 2
          failureThreshold: 3
      volumes:
      - name: config
        configMap:
          name: auth-service-config
      - name: secrets
        secret:
          secretName: auth-service-secrets
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
```

#### Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: auth-service
  namespace: platform
  labels:
    app: auth-service
    component: backend
spec:
  selector:
    app: auth-service
  ports:
  - name: http
    port: 8080
    targetPort: http
  - name: grpc
    port: 9090
    targetPort: grpc
  type: ClusterIP
```

#### ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: auth-service-config
  namespace: platform
data:
  config.yaml: |
    server:
      http:
        port: 8080
        read_timeout: 5s
        write_timeout: 10s
        idle_timeout: 120s
      grpc:
        port: 9090
        max_connection_idle: 60s
    
    database:
      host: postgres
      port: 5432
      name: auth_service
      user: ${DB_USER}
      sslmode: require
      max_open_conns: 20
      max_idle_conns: 5
      conn_max_lifetime: 1h
    
    redis:
      addr: redis:6379
      db: 0
      pool_size: 10
    
    kafka:
      brokers:
        - kafka-0.kafka-headless:9092
        - kafka-1.kafka-headless:9092
        - kafka-2.kafka-headless:9092
      producer:
        topic: auth.events
      consumer:
        group_id: auth-service
        topics:
          - account.events
    
    auth:
      access_token:
        expiration: 15m
        issuer: "auth-service"
      refresh_token:
        expiration: 7d
      password:
        min_length: 8
        require_uppercase: true
        require_lowercase: true
        require_digit: true
        require_special: true
    
    logging:
      level: info
      format: json
    
    tracing:
      enabled: true
      service_name: auth-service
      endpoint: jaeger-collector:14268/api/traces
      sample_rate: 0.1
    
    metrics:
      enabled: true
      port: 9091
```

### 8.3 Конфигурационные параметры

Auth Service поддерживает конфигурацию через файл YAML, переменные окружения и флаги командной строки:

#### Основные параметры
- `server.http.port`: Порт для HTTP-сервера (по умолчанию: 8080)
- `server.grpc.port`: Порт для gRPC-сервера (по умолчанию: 9090)
- `database.host`: Хост PostgreSQL (по умолчанию: localhost)
- `database.port`: Порт PostgreSQL (по умолчанию: 5432)
- `database.name`: Имя базы данных (по умолчанию: auth_service)
- `redis.addr`: Адрес Redis (по умолчанию: localhost:6379)
- `kafka.brokers`: Список брокеров Kafka (по умолчанию: localhost:9092)

#### Параметры аутентификации
- `auth.access_token.expiration`: Срок действия Access Token (по умолчанию: 15m)
- `auth.refresh_token.expiration`: Срок действия Refresh Token (по умолчанию: 7d)
- `auth.jwt.signing_key`: Ключ для подписи JWT (обязательный параметр)
- `auth.password.min_length`: Минимальная длина пароля (по умолчанию: 8)

#### Параметры логирования и мониторинга
- `logging.level`: Уровень логирования (по умолчанию: info)
- `logging.format`: Формат логов (по умолчанию: json)
- `tracing.enabled`: Включение трассировки (по умолчанию: false)
- `metrics.enabled`: Включение метрик (по умолчанию: true)

### 8.4 Процесс развертывания

#### CI/CD Pipeline
1. Сборка и тестирование:
   - Запуск модульных и интеграционных тестов
   - Статический анализ кода
   - Сборка Docker-образа
   - Сканирование образа на уязвимости

2. Развертывание в dev-окружение:
   - Автоматическое развертывание в Kubernetes
   - Запуск smoke-тестов
   - Проверка работоспособности API

3. Развертывание в staging-окружение:
   - Ручное подтверждение
   - Развертывание в Kubernetes
   - Запуск полного набора тестов
   - Проверка производительности

4. Развертывание в production-окружение:
   - Ручное подтверждение
   - Развертывание с использованием стратегии Canary/Blue-Green
   - Мониторинг метрик и логов
   - Автоматический откат при обнаружении проблем

#### Стратегия обновления
- Использование RollingUpdate для минимизации простоев
- Проверка готовности через readinessProbe перед направлением трафика
- Автоматический откат при превышении порога ошибок
- Возможность ручного отката через Helm

## 9. Мониторинг, логирование и трассировка

### 9.1 Мониторинг

Auth Service предоставляет набор метрик в формате Prometheus для мониторинга производительности и состояния:

#### Ключевые метрики
- `auth_requests_total{method="login|register|refresh", status="success|failure"}`: Общее количество запросов аутентификации
- `auth_request_duration_seconds{method, status}`: Время обработки запросов аутентификации
- `auth_token_validation_total{status="valid|invalid|expired"}`: Количество проверок токенов
- `auth_active_sessions_count`: Количество активных сессий
- `auth_database_query_duration_seconds{query_type}`: Время выполнения запросов к базе данных
- `auth_cache_hit_total`: Количество успешных обращений к кэшу
- `auth_cache_miss_total`: Количество промахов кэша
- `auth_error_total{type="validation|database|internal"}`: Количество ошибок по типам

#### Алерты
- **HighErrorRate**: Высокий процент ошибок аутентификации
- **SlowResponseTime**: Увеличение времени отклика API
- **HighDatabaseLatency**: Высокая задержка запросов к базе данных
- **TokenValidationFailures**: Аномальное количество неудачных проверок токенов
- **ServiceUnavailable**: Сервис недоступен или не проходит проверки работоспособности

#### Дашборды
- Общий дашборд с ключевыми метриками производительности
- Дашборд безопасности с метриками аутентификации и авторизации
- Дашборд для отладки с детальными метриками компонентов

### 9.2 Логирование

Auth Service использует структурированное логирование в формате JSON:

#### Уровни логирования
- **DEBUG**: Детальная информация для отладки
- **INFO**: Информация о нормальной работе сервиса
- **WARN**: Предупреждения, не влияющие на работу сервиса
- **ERROR**: Ошибки, влияющие на обработку текущего запроса
- **FATAL**: Критические ошибки, требующие немедленного вмешательства

#### Структура логов
```json
{
  "level": "info",
  "timestamp": "2023-01-01T12:00:00Z",
  "service": "auth-service",
  "instance": "auth-service-5d8f7c9c68-abcde",
  "trace_id": "550e8400-e29b-41d4-a716-446655440000",
  "request_id": "550e8400-e29b-41d4-a716-446655440001",
  "user_id": "550e8400-e29b-41d4-a716-446655440002",
  "method": "POST",
  "path": "/api/v1/auth/login",
  "status_code": 200,
  "duration_ms": 45,
  "message": "Successful login",
  "additional_info": {
    "ip": "192.168.1.1",
    "user_agent": "Mozilla/5.0 ..."
  }
}
```

#### Интеграция с ELK Stack
- Отправка логов в Elasticsearch через Filebeat
- Индексирование и хранение логов в соответствии с политикой хранения
- Визуализация и анализ логов через Kibana
- Настройка алертов на основе паттернов в логах

### 9.3 Трассировка

Auth Service интегрируется с OpenTelemetry для распределенной трассировки:

#### Трассируемые операции
- Входящие HTTP и gRPC запросы
- Запросы к базе данных и Redis
- Публикация и потребление событий Kafka
- Вызовы внешних API (Telegram API и др.)

#### Атрибуты трассировки
- `service.name`: Имя сервиса (auth-service)
- `http.method`: HTTP метод
- `http.url`: URL запроса
- `http.status_code`: Код ответа
- `db.system`: Тип базы данных (postgresql, redis)
- `db.statement`: SQL запрос (с параметризацией)
- `messaging.system`: Система обмена сообщениями (kafka)
- `messaging.destination`: Топик Kafka

#### Интеграция с Jaeger
- Отправка данных трассировки в Jaeger Collector
- Визуализация трасс через Jaeger UI
- Анализ производительности и узких мест
- Корреляция трасс с логами через trace_id

## 10. Тестирование

### 10.1 Стратегия тестирования

Auth Service покрыт различными типами тестов для обеспечения качества и надежности:

- **Модульные тесты**: Проверка отдельных компонентов и функций
- **Интеграционные тесты**: Проверка взаимодействия компонентов
- **Системные тесты**: Проверка работы сервиса в целом
- **Нагрузочные тесты**: Проверка производительности и масштабируемости
- **Тесты безопасности**: Проверка защищенности от уязвимостей

### 10.2 Модульные тесты

Модульные тесты покрывают основные компоненты Auth Service:

- **Handlers**: Тестирование обработчиков HTTP и gRPC запросов
- **Services**: Тестирование бизнес-логики
- **Repositories**: Тестирование доступа к данным
- **Middleware**: Тестирование промежуточного ПО
- **Utils**: Тестирование вспомогательных функций

Примеры модульных тестов:

```go
func TestLoginHandler_ValidCredentials(t *testing.T) {
    // Arrange
    mockService := mocks.NewMockAuthService()
    mockService.On("Login", mock.Anything, "user@example.com", "password").Return(authTokens, nil)
    
    handler := handlers.NewAuthHandler(mockService)
    router := gin.Default()
    router.POST("/login", handler.Login)
    
    // Act
    w := httptest.NewRecorder()
    req, _ := http.NewRequest("POST", "/login", strings.NewReader(`{"email":"user@example.com","password":"password"}`))
    req.Header.Set("Content-Type", "application/json")
    router.ServeHTTP(w, req)
    
    // Assert
    assert.Equal(t, 200, w.Code)
    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(t, err)
    assert.Contains(t, response, "access_token")
    assert.Contains(t, response, "refresh_token")
    
    mockService.AssertExpectations(t)
}
```

### 10.3 Интеграционные тесты

Интеграционные тесты проверяют взаимодействие компонентов Auth Service:

- **API тесты**: Проверка работы API с реальной базой данных
- **Интеграция с Kafka**: Проверка публикации и потребления событий
- **Интеграция с Redis**: Проверка кэширования и хранения сессий
- **Интеграция с другими микросервисами**: Проверка взаимодействия с Account Service и др.

Примеры интеграционных тестов:

```go
func TestIntegration_UserRegistrationAndLogin(t *testing.T) {
    // Arrange
    testDB := setupTestDatabase()
    defer cleanupTestDatabase(testDB)
    
    app := setupTestApp(testDB)
    
    // Act - Register
    registerResp := httptest.NewRecorder()
    registerReq, _ := http.NewRequest("POST", "/api/v1/auth/register", strings.NewReader(`{
        "email": "newuser@example.com",
        "password": "SecurePassword123!",
        "username": "newuser"
    }`))
    registerReq.Header.Set("Content-Type", "application/json")
    app.ServeHTTP(registerResp, registerReq)
    
    // Assert - Register
    assert.Equal(t, 201, registerResp.Code)
    
    // Act - Login
    loginResp := httptest.NewRecorder()
    loginReq, _ := http.NewRequest("POST", "/api/v1/auth/login", strings.NewReader(`{
        "email": "newuser@example.com",
        "password": "SecurePassword123!"
    }`))
    loginReq.Header.Set("Content-Type", "application/json")
    app.ServeHTTP(loginResp, loginReq)
    
    // Assert - Login
    assert.Equal(t, 200, loginResp.Code)
    var loginResponse map[string]interface{}
    err := json.Unmarshal(loginResp.Body.Bytes(), &loginResponse)
    assert.NoError(t, err)
    assert.Contains(t, loginResponse, "access_token")
    assert.Contains(t, loginResponse, "refresh_token")
}
```

### 10.4 Нагрузочные тесты

Нагрузочные тесты проверяют производительность и масштабируемость Auth Service:

- **Тесты производительности**: Проверка времени отклика при различной нагрузке
- **Тесты масштабируемости**: Проверка работы при горизонтальном масштабировании
- **Стресс-тесты**: Проверка работы при экстремальной нагрузке
- **Тесты стабильности**: Проверка работы при длительной нагрузке

Примеры сценариев нагрузочных тестов:

- Аутентификация 1000 пользователей в секунду
- Валидация 5000 токенов в секунду
- Одновременная регистрация 500 пользователей
- Длительная работа под нагрузкой в течение 24 часов

## 11. Приложения

### 11.1 Примеры запросов/ответов API

#### Пример запроса на регистрацию

```http
POST /api/v1/auth/register HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!",
  "username": "username"
}
```

Ответ:

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 900,
  "message": "Пользователь успешно зарегистрирован. Пожалуйста, подтвердите email."
}
```

#### Пример запроса на аутентификацию

```http
POST /api/v1/auth/login HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

Ответ:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 900,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "username": "username",
    "roles": ["user"]
  }
}
```

#### Пример запроса на обновление токена

```http
POST /api/v1/auth/refresh-token HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

Ответ:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 900
}
```

#### Пример запроса на проверку разрешения

```http
POST /api/v1/auth/check-permission HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "permission": "users.read"
}
```

Ответ:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "has_permission": true
}
```

### 11.2 Схема базы данных

#### Таблица users

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) NOT NULL UNIQUE,
    username VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    two_factor_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    two_factor_secret VARCHAR(255),
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    last_login_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
```

#### Таблица roles

```sql
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```

#### Таблица permissions

```sql
CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```

#### Таблица role_permissions

```sql
CREATE TABLE role_permissions (
    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    permission_id UUID NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    PRIMARY KEY (role_id, permission_id)
);
```

#### Таблица user_roles

```sql
CREATE TABLE user_roles (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    PRIMARY KEY (user_id, role_id)
);
```

#### Таблица refresh_tokens

```sql
CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    revoked BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
```

#### Таблица external_accounts

```sql
CREATE TABLE external_accounts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider VARCHAR(50) NOT NULL,
    provider_user_id VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    UNIQUE (provider, provider_user_id)
);

CREATE INDEX idx_external_accounts_user_id ON external_accounts(user_id);
```

#### Таблица audit_logs

```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100) NOT NULL,
    resource_id VARCHAR(255),
    ip_address VARCHAR(45),
    user_agent TEXT,
    details JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
```



### 11.2 Схема базы данных

Ниже представлена полная схема базы данных PostgreSQL для микросервиса Auth Service, включая SQL-скрипты для создания таблиц, индексов и ограничений.

```sql
-- Пользователи
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255),
    status VARCHAR(50) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'blocked', 'pending_verification')),
    email_verified_at TIMESTAMP WITH TIME ZONE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    deleted_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_deleted_at ON users(deleted_at);

-- Роли
CREATE TABLE roles (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Разрешения
CREATE TABLE permissions (
    id VARCHAR(100) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    resource VARCHAR(100), -- Опционально: ресурс, к которому относится разрешение
    action VARCHAR(50),    -- Опционально: действие (read, write, delete)
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Связь ролей и разрешений (Многие ко многим)
CREATE TABLE role_permissions (
    role_id VARCHAR(50) NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    permission_id VARCHAR(100) NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (role_id, permission_id)
);

-- Связь пользователей и ролей (Многие ко многим)
CREATE TABLE user_roles (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id VARCHAR(50) NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    assigned_by UUID REFERENCES users(id), -- Кто назначил роль
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id)
);

CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);
CREATE INDEX idx_user_roles_role_id ON user_roles(role_id);

-- Сессии
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    ip_address VARCHAR(45),
    user_agent TEXT,
    device_info JSONB, -- Информация об устройстве (ОС, браузер и т.д.)
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    last_activity_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);

-- Токены обновления
CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL UNIQUE, -- Хеш токена
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    revoked_at TIMESTAMP WITH TIME ZONE,
    revoked_reason VARCHAR(100)
);

CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_session_id ON refresh_tokens(session_id);
CREATE INDEX idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);

-- Внешние аккаунты (для OAuth/социального входа)
CREATE TABLE external_accounts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider VARCHAR(50) NOT NULL, -- Например, 'vk', 'telegram'
    external_id VARCHAR(255) NOT NULL, -- ID пользователя у провайдера
    access_token TEXT, -- Токен доступа провайдера
    refresh_token TEXT, -- Токен обновления провайдера
    token_expires_at TIMESTAMP WITH TIME ZONE,
    profile_data JSONB, -- Данные профиля от провайдера
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    last_used_at TIMESTAMP WITH TIME ZONE,
    UNIQUE (provider, external_id), -- Уникальность связки провайдер + внешний ID
    UNIQUE (user_id, provider) -- Один пользователь - один аккаунт на провайдера
);

CREATE INDEX idx_external_accounts_user_id ON external_accounts(user_id);

-- MFA устройства (для двухфакторной аутентификации)
CREATE TABLE mfa_devices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL CHECK (type IN ('totp', 'sms', 'email', 'backup_code')), -- Тип устройства/метода
    name VARCHAR(255), -- Название устройства (например, 'Мой телефон')
    secret TEXT, -- Секрет для TOTP или номер телефона/email
    backup_codes JSONB, -- Зашифрованные резервные коды
    verified BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    last_used_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_mfa_devices_user_id ON mfa_devices(user_id);

-- API ключи (для разработчиков или сервисов)
CREATE TABLE api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Пользователь-владелец ключа
    name VARCHAR(255) NOT NULL,
    key_prefix VARCHAR(8) NOT NULL UNIQUE, -- Префикс для идентификации ключа
    key_hash VARCHAR(255) NOT NULL, -- Хеш самого ключа
    permissions JSONB, -- Разрешения, связанные с ключом
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    last_used_at TIMESTAMP WITH TIME ZONE,
    revoked_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);

-- Журнал аудита действий
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES users(id), -- Пользователь, выполнивший действие (может быть NULL для системных действий)
    action VARCHAR(100) NOT NULL, -- Тип действия (например, 'login', 'password_reset', 'role_assigned')
    resource_type VARCHAR(100), -- Тип ресурса, над которым выполнено действие (например, 'user', 'session')
    resource_id VARCHAR(255), -- ID ресурса
    ip_address VARCHAR(45),
    user_agent TEXT,
    status VARCHAR(50) NOT NULL DEFAULT 'success' CHECK (status IN ('success', 'failure')),
    details JSONB, -- Дополнительные детали события
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_resource_type_id ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);

-- Таблица для хранения временных кодов (верификация email, сброс пароля)
CREATE TABLE verification_codes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL CHECK (type IN ('email_verification', 'password_reset', 'mfa_setup')), -- Тип кода
    code_hash VARCHAR(255) NOT NULL, -- Хеш кода
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    used_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_verification_codes_user_id_type ON verification_codes(user_id, type);
CREATE INDEX idx_verification_codes_expires_at ON verification_codes(expires_at);
```

### Миграции базы данных

Для управления миграциями схемы базы данных используется инструмент `golang-migrate/migrate`. Миграции хранятся в директории `migrations` в формате `YYYYMMDDHHMMSS_description.up.sql` и `YYYYMMDDHHMMSS_description.down.sql`.

Пример команды для применения миграций:
```bash
migrate -database "postgres://user:password@host:port/dbname?sslmode=disable" -path migrations up
```



## 4. Бизнес-логика и сценарии использования

### 4.1 Основные сценарии

#### 4.1.1 Регистрация нового пользователя

**Описание**: Процесс создания новой учетной записи пользователя в системе.

**Шаги**:
1. Пользователь заполняет форму регистрации (имя пользователя, email, пароль)
2. Система проверяет уникальность имени пользователя и email
3. Система валидирует сложность пароля
4. Система хеширует пароль с использованием Argon2id
5. Система создает запись пользователя в базе данных со статусом `pending_verification`
6. Система генерирует код подтверждения email и сохраняет его в таблице `verification_codes`
7. Система публикует событие `auth.user.registered` с данными пользователя
8. Notification Service получает событие и отправляет письмо с кодом подтверждения
9. Система возвращает успешный ответ с ID пользователя

**Бизнес-правила**:
- Имя пользователя должно быть уникальным, содержать от 3 до 30 символов, только буквы, цифры и символы `-`, `_`
- Email должен быть уникальным и соответствовать формату RFC 5322
- Пароль должен содержать минимум 8 символов, включая как минимум одну заглавную букву, одну строчную букву, одну цифру и один специальный символ
- Хеширование пароля должно использовать алгоритм Argon2id с параметрами: memory=64MB, iterations=3, parallelism=4
- Новые пользователи получают роль `user` по умолчанию

**Обработка ошибок**:
- Если имя пользователя уже занято: HTTP 409 Conflict, код ошибки `username_already_exists`
- Если email уже занят: HTTP 409 Conflict, код ошибки `email_already_exists`
- Если пароль не соответствует требованиям: HTTP 400 Bad Request, код ошибки `password_too_weak`
- Если формат email неверный: HTTP 400 Bad Request, код ошибки `invalid_email_format`

**Пример запроса**:
```json
POST /api/v1/auth/register
Content-Type: application/json

{
  "username": "ivan_petrov",
  "email": "ivan.petrov@example.com",
  "password": "P@ssw0rd123",
  "display_name": "Иван Петров"
}
```

**Пример успешного ответа**:
```json
HTTP/1.1 201 Created
Content-Type: application/json

{
  "user_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "username": "ivan_petrov",
  "email": "ivan.petrov@example.com",
  "status": "pending_verification",
  "created_at": "2025-05-24T12:34:56Z"
}
```

**Пример ответа с ошибкой**:
```json
HTTP/1.1 409 Conflict
Content-Type: application/json

{
  "error": {
    "code": "username_already_exists",
    "message": "Пользователь с таким именем уже существует",
    "details": {
      "field": "username",
      "value": "ivan_petrov"
    }
  }
}
```

#### 4.1.2 Подтверждение email

**Описание**: Процесс подтверждения email-адреса пользователя после регистрации.

**Шаги**:
1. Пользователь получает email с кодом подтверждения
2. Пользователь переходит по ссылке или вводит код в форму
3. Система проверяет валидность кода и его срок действия
4. Система обновляет статус пользователя на `active` и устанавливает `email_verified_at`
5. Система удаляет использованный код из таблицы `verification_codes`
6. Система публикует событие `auth.user.email_verified`
7. Система возвращает успешный ответ

**Бизнес-правила**:
- Код подтверждения действителен в течение 24 часов
- Код подтверждения может быть использован только один раз
- Пользователь не может войти в систему до подтверждения email (опционально, зависит от настроек)

**Обработка ошибок**:
- Если код неверный: HTTP 400 Bad Request, код ошибки `invalid_verification_code`
- Если код просрочен: HTTP 400 Bad Request, код ошибки `expired_verification_code`
- Если код уже использован: HTTP 400 Bad Request, код ошибки `already_used_verification_code`

#### 4.1.3 Аутентификация пользователя (логин)

**Описание**: Процесс входа пользователя в систему с использованием имени пользователя/email и пароля.

**Шаги**:
1. Пользователь вводит имя пользователя/email и пароль
2. Система находит пользователя по имени пользователя или email
3. Система проверяет статус пользователя (активен, заблокирован и т.д.)
4. Система проверяет пароль с использованием Argon2id
5. Система проверяет, требуется ли двухфакторная аутентификация
6. Если 2FA не требуется:
   a. Система создает новую сессию в таблице `sessions`
   b. Система генерирует пару токенов (access и refresh)
   c. Система сохраняет хеш refresh-токена в таблице `refresh_tokens`
   d. Система обновляет `last_login_at` пользователя
   e. Система записывает успешный вход в журнал аудита
   f. Система возвращает токены пользователю
7. Если 2FA требуется:
   a. Система генерирует временный токен для 2FA
   b. Система возвращает статус, требующий 2FA, и временный токен

**Бизнес-правила**:
- Пользователь может войти, используя имя пользователя или email
- Пользователь должен иметь статус `active`
- Access-токен действителен в течение 15 минут
- Refresh-токен действителен в течение 30 дней
- Система должна записывать IP-адрес, User-Agent и информацию об устройстве
- Система должна обнаруживать подозрительные входы (новое местоположение, устройство)

**Обработка ошибок**:
- Если пользователь не найден: HTTP 401 Unauthorized, код ошибки `invalid_credentials`
- Если пароль неверный: HTTP 401 Unauthorized, код ошибки `invalid_credentials`
- Если пользователь заблокирован: HTTP 403 Forbidden, код ошибки `user_blocked`
- Если email не подтвержден: HTTP 403 Forbidden, код ошибки `email_not_verified`

**Пример запроса**:
```json
POST /api/v1/auth/login
Content-Type: application/json

{
  "login": "ivan.petrov@example.com",
  "password": "P@ssw0rd123"
}
```

**Пример успешного ответа**:
```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "def5020089a5c5eff5a924a8...",
  "token_type": "Bearer",
  "expires_in": 900,
  "user": {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "username": "ivan_petrov",
    "display_name": "Иван Петров",
    "roles": ["user"]
  }
}
```

**Пример ответа с требованием 2FA**:
```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "2fa_required",
  "temp_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "available_methods": ["totp", "sms"],
  "expires_in": 300
}
```

#### 4.1.4 Двухфакторная аутентификация (2FA)

**Описание**: Процесс подтверждения личности пользователя с использованием второго фактора после успешного ввода пароля.

**Шаги**:
1. Пользователь получает временный токен после успешной проверки пароля
2. Пользователь выбирает метод 2FA (TOTP, SMS, Email) и получает/генерирует код
3. Пользователь отправляет код вместе с временным токеном
4. Система проверяет валидность временного токена
5. Система проверяет правильность кода 2FA
6. Система создает новую сессию и генерирует токены (аналогично обычному входу)
7. Система возвращает токены пользователю

**Бизнес-правила**:
- Временный токен действителен в течение 5 минут
- Код TOTP действителен в течение 30 секунд
- Код SMS/Email действителен в течение 10 минут
- Максимальное количество попыток ввода кода - 5
- Система должна предотвращать перебор кодов (rate limiting)

**Обработка ошибок**:
- Если временный токен недействителен: HTTP 401 Unauthorized, код ошибки `invalid_temp_token`
- Если код 2FA неверный: HTTP 401 Unauthorized, код ошибки `invalid_2fa_code`
- Если превышено количество попыток: HTTP 429 Too Many Requests, код ошибки `too_many_attempts`

#### 4.1.5 Обновление токена доступа

**Описание**: Процесс получения нового access-токена с использованием refresh-токена.

**Шаги**:
1. Клиент отправляет refresh-токен
2. Система проверяет валидность refresh-токена
3. Система находит связанную сессию и пользователя
4. Система генерирует новый access-токен
5. Система возвращает новый access-токен клиенту

**Бизнес-правила**:
- Refresh-токен может быть использован только один раз (опционально)
- При использовании refresh-токена система может генерировать новую пару токенов
- Система должна проверять, не был ли refresh-токен отозван

**Обработка ошибок**:
- Если refresh-токен недействителен: HTTP 401 Unauthorized, код ошибки `invalid_refresh_token`
- Если refresh-токен отозван: HTTP 401 Unauthorized, код ошибки `revoked_refresh_token`
- Если сессия истекла: HTTP 401 Unauthorized, код ошибки `session_expired`

#### 4.1.6 Выход из системы (логаут)

**Описание**: Процесс завершения сессии пользователя.

**Шаги**:
1. Клиент отправляет запрос на выход с access-токеном
2. Система находит сессию, связанную с токеном
3. Система отзывает все refresh-токены, связанные с сессией
4. Система помечает сессию как завершенную
5. Система записывает событие выхода в журнал аудита
6. Система возвращает успешный ответ

**Бизнес-правила**:
- При выходе должны отзываться все refresh-токены, связанные с сессией
- Система должна поддерживать выход со всех устройств (опционально)

**Обработка ошибок**:
- Если токен недействителен: HTTP 401 Unauthorized, код ошибки `invalid_token`

#### 4.1.7 Сброс пароля

**Описание**: Процесс восстановления доступа к учетной записи при забытом пароле.

**Шаги**:
1. Пользователь запрашивает сброс пароля, указывая email
2. Система находит пользователя по email
3. Система генерирует уникальный токен сброса пароля и сохраняет его в таблице `verification_codes`
4. Система публикует событие `auth.user.password_reset_requested`
5. Notification Service отправляет email со ссылкой для сброса пароля
6. Пользователь переходит по ссылке и вводит новый пароль
7. Система проверяет валидность токена сброса
8. Система обновляет пароль пользователя
9. Система отзывает все активные сессии и токены пользователя
10. Система записывает событие сброса пароля в журнал аудита
11. Система возвращает успешный ответ

**Бизнес-правила**:
- Токен сброса пароля действителен в течение 1 часа
- Новый пароль должен соответствовать требованиям к сложности
- Новый пароль не должен совпадать с предыдущим
- После сброса пароля все активные сессии должны быть завершены

**Обработка ошибок**:
- Если email не найден: HTTP 200 OK (для предотвращения утечки информации)
- Если токен сброса недействителен: HTTP 400 Bad Request, код ошибки `invalid_reset_token`
- Если токен просрочен: HTTP 400 Bad Request, код ошибки `expired_reset_token`
- Если новый пароль не соответствует требованиям: HTTP 400 Bad Request, код ошибки `password_too_weak`

### 4.2 Пограничные случаи

#### 4.2.1 Обнаружение подозрительной активности

**Описание**: Процесс обнаружения и реагирования на подозрительную активность в учетной записи пользователя.

**Шаги**:
1. Система анализирует параметры входа (IP-адрес, устройство, время)
2. Система сравнивает параметры с историческими данными пользователя
3. Если обнаружены аномалии, система помечает вход как подозрительный
4. Система публикует событие `auth.user.suspicious_login_detected`
5. Notification Service отправляет уведомление пользователю
6. Система может требовать дополнительную верификацию (2FA, подтверждение email)

**Бизнес-правила**:
- Система должна хранить историю входов пользователя
- Система должна определять аномалии на основе географического расположения, устройства, времени суток
- Система должна иметь настраиваемые пороги для определения подозрительной активности

#### 4.2.2 Блокировка учетной записи после неудачных попыток входа

**Описание**: Процесс временной блокировки учетной записи после нескольких неудачных попыток входа.

**Шаги**:
1. Система отслеживает неудачные попытки входа для каждого пользователя
2. После превышения порога (например, 5 попыток) система временно блокирует возможность входа
3. Система записывает событие блокировки в журнал аудита
4. Система возвращает сообщение о временной блокировке
5. По истечении времени блокировки (например, 15 минут) система разрешает новые попытки входа

**Бизнес-правила**:
- Максимальное количество неудачных попыток: 5
- Время блокировки: 15 минут
- Счетчик попыток сбрасывается после успешного входа
- Система должна использовать экспоненциальное увеличение времени блокировки при повторных блокировках

#### 4.2.3 Управление одновременными сессиями

**Описание**: Процесс управления несколькими активными сессиями одного пользователя.

**Шаги**:
1. Система отслеживает все активные сессии пользователя
2. Пользователь может просматривать список своих активных сессий
3. Пользователь может завершить отдельные сессии или все сессии, кроме текущей
4. Система отзывает соответствующие токены и обновляет статус сессий
5. Система записывает события в журнал аудита

**Бизнес-правила**:
- Максимальное количество одновременных сессий: настраиваемое (по умолчанию 5)
- При достижении лимита сессий система может автоматически завершать самые старые сессии
- Система должна предоставлять информацию о каждой сессии (IP, устройство, время последней активности)

#### 4.2.4 Обработка истекших токенов

**Описание**: Процесс обработки запросов с истекшими токенами доступа.

**Шаги**:
1. Клиент отправляет запрос с истекшим access-токеном
2. Система определяет, что токен истек
3. Система возвращает ошибку с кодом `token_expired`
4. Клиент должен использовать refresh-токен для получения нового access-токена

**Бизнес-правила**:
- Система должна проверять срок действия токена перед проверкой подписи
- Система должна возвращать точное время истечения токена
- Клиент должен обрабатывать ошибки истечения токена и автоматически обновлять токены

**Обработка ошибок**:
- Если токен истек: HTTP 401 Unauthorized, код ошибки `token_expired`


## 5. API и интерфейсы

### 5.1 REST API

Auth Service предоставляет REST API для взаимодействия с клиентскими приложениями. Все эндпоинты доступны через API Gateway.

#### 5.1.1 Общие принципы REST API

- Базовый URL: `/api/v1/auth`
- Формат данных: JSON
- Аутентификация: Bearer Token (JWT)
- Версионирование: через URL-путь (`/api/v1/`, `/api/v2/`)
- Пагинация: параметры `limit` и `offset` или `page` и `per_page`
- Сортировка: параметр `sort=field:direction` (например, `sort=created_at:desc`)
- Фильтрация: параметры запроса в формате `field=value` или `field[operator]=value`
- Коды состояния HTTP: стандартные (200, 201, 400, 401, 403, 404, 409, 429, 500)
- Формат ошибок: унифицированный объект с полями `code`, `message`, `details`

#### 5.1.2 Эндпоинты аутентификации

| Метод | Путь | Описание | Аутентификация |
|-------|------|----------|----------------|
| POST | /register | Регистрация нового пользователя | Нет |
| POST | /login | Вход в систему | Нет |
| POST | /logout | Выход из системы | Да |
| POST | /refresh | Обновление токена доступа | Нет (только refresh token) |
| POST | /verify-email | Подтверждение email | Нет |
| POST | /resend-verification | Повторная отправка кода подтверждения | Нет |
| POST | /forgot-password | Запрос на сброс пароля | Нет |
| POST | /reset-password | Сброс пароля | Нет |
| POST | /2fa/verify | Подтверждение 2FA | Нет (только временный токен) |

#### 5.1.3 Эндпоинты управления пользователями

| Метод | Путь | Описание | Аутентификация |
|-------|------|----------|----------------|
| GET | /me | Получение информации о текущем пользователе | Да |
| PUT | /me | Обновление информации о текущем пользователе | Да |
| PUT | /me/password | Изменение пароля | Да |
| GET | /me/sessions | Получение списка активных сессий | Да |
| DELETE | /me/sessions/{id} | Завершение конкретной сессии | Да |
| DELETE | /me/sessions | Завершение всех сессий, кроме текущей | Да |

#### 5.1.4 Эндпоинты управления 2FA

| Метод | Путь | Описание | Аутентификация |
|-------|------|----------|----------------|
| GET | /me/2fa | Получение статуса 2FA | Да |
| POST | /me/2fa/totp | Настройка TOTP | Да |
| POST | /me/2fa/totp/verify | Подтверждение TOTP | Да |
| DELETE | /me/2fa/totp | Отключение TOTP | Да |
| POST | /me/2fa/backup-codes | Генерация резервных кодов | Да |
| GET | /me/2fa/backup-codes | Получение резервных кодов | Да |

#### 5.1.5 Эндпоинты для внешней аутентификации

| Метод | Путь | Описание | Аутентификация |
|-------|------|----------|----------------|
| GET | /oauth/{provider} | Инициирование OAuth-потока | Нет |
| GET | /oauth/{provider}/callback | Callback для OAuth | Нет |
| POST | /telegram/login | Вход через Telegram | Нет |

#### 5.1.6 Эндпоинты для разработчиков

| Метод | Путь | Описание | Аутентификация |
|-------|------|----------|----------------|
| GET | /me/api-keys | Получение списка API-ключей | Да |
| POST | /me/api-keys | Создание нового API-ключа | Да |
| DELETE | /me/api-keys/{id} | Удаление API-ключа | Да |

#### 5.1.7 Административные эндпоинты

| Метод | Путь | Описание | Аутентификация |
|-------|------|----------|----------------|
| GET | /admin/users | Получение списка пользователей | Да (admin) |
| GET | /admin/users/{id} | Получение информации о пользователе | Да (admin) |
| PUT | /admin/users/{id} | Обновление информации о пользователе | Да (admin) |
| PUT | /admin/users/{id}/block | Блокировка пользователя | Да (admin) |
| PUT | /admin/users/{id}/unblock | Разблокировка пользователя | Да (admin) |
| PUT | /admin/users/{id}/roles | Управление ролями пользователя | Да (admin) |
| GET | /admin/roles | Получение списка ролей | Да (admin) |
| POST | /admin/roles | Создание новой роли | Да (admin) |
| PUT | /admin/roles/{id} | Обновление роли | Да (admin) |
| DELETE | /admin/roles/{id} | Удаление роли | Да (admin) |
| GET | /admin/audit-logs | Получение журнала аудита | Да (admin) |

### 5.2 gRPC API

Auth Service предоставляет gRPC API для внутреннего взаимодействия с другими микросервисами.

#### 5.2.1 Определение сервиса (auth.proto)

```protobuf
syntax = "proto3";

package auth;

option go_package = "github.com/gameplatform/auth-service/proto/auth";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

service AuthService {
  // Проверка токена и получение информации о пользователе
  rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse) {}
  
  // Проверка наличия разрешения у пользователя
  rpc CheckPermission(CheckPermissionRequest) returns (CheckPermissionResponse) {}
  
  // Получение информации о пользователе
  rpc GetUserInfo(GetUserInfoRequest) returns (UserInfo) {}
  
  // Получение списка пользователей (для админов)
  rpc GetUsers(GetUsersRequest) returns (GetUsersResponse) {}
  
  // Блокировка пользователя
  rpc BlockUser(BlockUserRequest) returns (UserInfo) {}
  
  // Разблокировка пользователя
  rpc UnblockUser(UnblockUserRequest) returns (UserInfo) {}
  
  // Назначение роли пользователю
  rpc AssignRole(AssignRoleRequest) returns (UserInfo) {}
  
  // Отзыв роли у пользователя
  rpc RevokeRole(RevokeRoleRequest) returns (UserInfo) {}
  
  // Проверка здоровья сервиса
  rpc HealthCheck(google.protobuf.Empty) returns (HealthCheckResponse) {}
}

message ValidateTokenRequest {
  string token = 1;
}

message ValidateTokenResponse {
  bool valid = 1;
  UserInfo user = 2;
  repeated string roles = 3;
  repeated string permissions = 4;
  google.protobuf.Timestamp expires_at = 5;
}

message CheckPermissionRequest {
  string user_id = 1;
  string permission = 2;
  string resource_id = 3; // Опционально
}

message CheckPermissionResponse {
  bool has_permission = 1;
}

message GetUserInfoRequest {
  string user_id = 1;
}

message UserInfo {
  string id = 1;
  string username = 2;
  string email = 3;
  string status = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp email_verified_at = 6;
  google.protobuf.Timestamp last_login_at = 7;
  repeated string roles = 8;
}

message GetUsersRequest {
  int32 page = 1;
  int32 per_page = 2;
  string status = 3; // Опциональный фильтр по статусу
  string search = 4; // Опциональный поиск по имени пользователя или email
  string sort = 5;   // Поле для сортировки
  bool desc = 6;     // Направление сортировки
}

message GetUsersResponse {
  repeated UserInfo users = 1;
  int32 total = 2;
  int32 page = 3;
  int32 per_page = 4;
  int32 total_pages = 5;
}

message BlockUserRequest {
  string user_id = 1;
  string reason = 2;
  string blocked_by = 3; // ID администратора
}

message UnblockUserRequest {
  string user_id = 1;
  string unblocked_by = 2; // ID администратора
}

message AssignRoleRequest {
  string user_id = 1;
  string role_id = 2;
  string assigned_by = 3; // ID администратора
}

message RevokeRoleRequest {
  string user_id = 1;
  string role_id = 2;
  string revoked_by = 3; // ID администратора
}

message HealthCheckResponse {
  enum Status {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  Status status = 1;
}
```

#### 5.2.2 Использование gRPC API

Пример использования gRPC API в Go-клиенте:

```go
package main

import (
    "context"
    "log"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    
    pb "github.com/gameplatform/auth-service/proto/auth"
)

func main() {
    // Установка соединения с сервером
    conn, err := grpc.Dial("auth-service:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        log.Fatalf("did not connect: %v", err)
    }
    defer conn.Close()
    
    // Создание клиента
    client := pb.NewAuthServiceClient(conn)
    
    // Установка таймаута
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()
    
    // Проверка токена
    resp, err := client.ValidateToken(ctx, &pb.ValidateTokenRequest{
        Token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    })
    if err != nil {
        log.Fatalf("could not validate token: %v", err)
    }
    
    if resp.Valid {
        log.Printf("Token is valid for user: %s", resp.User.Username)
        log.Printf("User roles: %v", resp.Roles)
        log.Printf("User permissions: %v", resp.Permissions)
    } else {
        log.Println("Token is invalid")
    }
}
```

### 5.3 События (Events)

Auth Service публикует и потребляет события через Kafka для асинхронного взаимодействия с другими микросервисами.

#### 5.3.1 Публикуемые события

| Событие | Тема (Topic) | Описание | Формат данных |
|---------|--------------|----------|---------------|
| `auth.user.registered` | `auth-events` | Регистрация нового пользователя | JSON |
| `auth.user.email_verified` | `auth-events` | Подтверждение email пользователя | JSON |
| `auth.user.password_reset_requested` | `auth-events` | Запрос на сброс пароля | JSON |
| `auth.user.password_changed` | `auth-events` | Изменение пароля пользователя | JSON |
| `auth.user.blocked` | `auth-events` | Блокировка пользователя | JSON |
| `auth.user.unblocked` | `auth-events` | Разблокировка пользователя | JSON |
| `auth.user.roles_changed` | `auth-events` | Изменение ролей пользователя | JSON |
| `auth.user.suspicious_login_detected` | `auth-events` | Обнаружение подозрительного входа | JSON |
| `auth.user.login_success` | `auth-events` | Успешный вход пользователя | JSON |
| `auth.user.login_failed` | `auth-events` | Неудачная попытка входа | JSON |

#### 5.3.2 Потребляемые события

| Событие | Тема (Topic) | Описание | Формат данных |
|---------|--------------|----------|---------------|
| `account.user.profile_updated` | `account-events` | Обновление профиля пользователя | JSON |
| `admin.user.force_logout` | `admin-events` | Принудительный выход пользователя | JSON |
| `admin.user.block` | `admin-events` | Запрос на блокировку пользователя | JSON |
| `admin.user.unblock` | `admin-events` | Запрос на разблокировку пользователя | JSON |

#### 5.3.3 Формат событий

Все события используют общий формат CloudEvents:

```json
{
  "specversion": "1.0",
  "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "source": "auth-service",
  "type": "auth.user.registered",
  "time": "2025-05-24T12:34:56Z",
  "datacontenttype": "application/json",
  "data": {
    "user_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "username": "ivan_petrov",
    "email": "ivan.petrov@example.com",
    "created_at": "2025-05-24T12:34:56Z"
  }
}
```

Пример события блокировки пользователя:

```json
{
  "specversion": "1.0",
  "id": "a1b2c3d4-e5f6-4a5b-9c8d-0e1f2a3b4c5d",
  "source": "auth-service",
  "type": "auth.user.blocked",
  "time": "2025-05-24T14:30:00Z",
  "datacontenttype": "application/json",
  "data": {
    "user_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "username": "ivan_petrov",
    "reason": "Нарушение правил платформы",
    "blocked_by": "a2b3c4d5-e6f7-8a9b-0c1d-2e3f4a5b6c7d",
    "blocked_at": "2025-05-24T14:30:00Z"
  }
}
```

### 5.4 Форматы данных

#### 5.4.1 JWT-токен

Auth Service использует JWT (JSON Web Token) для аутентификации и авторизации. Структура токена:

**Header**:
```json
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "key-id-1"
}
```

**Payload**:
```json
{
  "sub": "f47ac10b-58cc-4372-a567-0e02b2c3d479", // ID пользователя
  "iss": "auth-service", // Издатель токена
  "aud": ["api-gateway"], // Аудитория токена
  "exp": 1716561600, // Время истечения (Unix timestamp)
  "iat": 1716558000, // Время выдачи (Unix timestamp)
  "jti": "a1b2c3d4-e5f6-4a5b-9c8d-0e1f2a3b4c5d", // Уникальный ID токена
  "username": "ivan_petrov", // Имя пользователя
  "roles": ["user"], // Роли пользователя
  "permissions": ["library.read", "catalog.read"], // Разрешения пользователя
  "session_id": "b2c3d4e5-f6a7-8b9c-0d1e-2f3a4b5c6d7e" // ID сессии
}
```

#### 5.4.2 Refresh-токен

Refresh-токен представляет собой случайную строку, которая хранится в базе данных в хешированном виде. Пример:

```
def5020089a5c5eff5a924a8a6e8cbd4b0a710a43af613a3fdd0a3af6e0935b37e1d34a6
```

#### 5.4.3 Пользовательские данные

Формат данных пользователя в ответах API:

```json
{
  "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "username": "ivan_petrov",
  "email": "ivan.petrov@example.com",
  "display_name": "Иван Петров",
  "status": "active",
  "email_verified": true,
  "created_at": "2025-01-15T10:30:00Z",
  "last_login_at": "2025-05-24T12:34:56Z",
  "roles": ["user"],
  "has_2fa": true,
  "available_2fa_methods": ["totp"]
}
```

#### 5.4.4 Формат ошибок

Унифицированный формат ошибок для всех API:

```json
{
  "error": {
    "code": "invalid_credentials",
    "message": "Неверное имя пользователя или пароль",
    "details": {
      "field": "password",
      "reason": "incorrect"
    }
  }
}
```

### 5.5 Обработка ошибок

#### 5.5.1 Коды ошибок REST API

| HTTP-код | Код ошибки | Описание |
|----------|------------|----------|
| 400 | `invalid_request` | Неверный формат запроса |
| 400 | `invalid_email_format` | Неверный формат email |
| 400 | `password_too_weak` | Пароль не соответствует требованиям |
| 400 | `invalid_verification_code` | Неверный код подтверждения |
| 400 | `expired_verification_code` | Истекший код подтверждения |
| 400 | `invalid_reset_token` | Неверный токен сброса пароля |
| 400 | `expired_reset_token` | Истекший токен сброса пароля |
| 400 | `invalid_2fa_code` | Неверный код 2FA |
| 401 | `invalid_credentials` | Неверные учетные данные |
| 401 | `invalid_token` | Недействительный токен |
| 401 | `token_expired` | Истекший токен |
| 401 | `invalid_refresh_token` | Недействительный токен обновления |
| 401 | `revoked_refresh_token` | Отозванный токен обновления |
| 403 | `user_blocked` | Пользователь заблокирован |
| 403 | `email_not_verified` | Email не подтвержден |
| 403 | `insufficient_permissions` | Недостаточно прав |
| 404 | `user_not_found` | Пользователь не найден |
| 409 | `username_already_exists` | Имя пользователя уже занято |
| 409 | `email_already_exists` | Email уже занят |
| 429 | `too_many_attempts` | Слишком много попыток |
| 500 | `internal_server_error` | Внутренняя ошибка сервера |

#### 5.5.2 Коды ошибок gRPC API

| gRPC-код | Описание |
|----------|----------|
| `INVALID_ARGUMENT` | Неверные аргументы запроса |
| `UNAUTHENTICATED` | Ошибка аутентификации |
| `PERMISSION_DENIED` | Недостаточно прав |
| `NOT_FOUND` | Ресурс не найден |
| `ALREADY_EXISTS` | Ресурс уже существует |
| `RESOURCE_EXHAUSTED` | Превышены лимиты запросов |
| `FAILED_PRECONDITION` | Не выполнены предварительные условия |
| `INTERNAL` | Внутренняя ошибка сервера |

#### 5.5.3 Стратегия обработки ошибок

1. **Логирование**: Все ошибки логируются с соответствующим уровнем (ERROR для серьезных ошибок, WARN для предупреждений)
2. **Трассировка**: Ошибки включаются в трассировку запросов для облегчения отладки
3. **Метрики**: Ведется подсчет ошибок по типам для мониторинга
4. **Безопасность**: Чувствительная информация не раскрывается в сообщениях об ошибках
5. **Локализация**: Сообщения об ошибках локализуются на стороне клиента


## 12. Требования и цели

### 12.1 Функциональные требования

- **FR-AUTH-001**: Система должна предоставлять возможность регистрации новых пользователей с использованием уникального имени пользователя и email.
- **FR-AUTH-002**: Система должна требовать подтверждение email-адреса после регистрации.
- **FR-AUTH-003**: Система должна обеспечивать аутентификацию пользователей по имени пользователя/email и паролю.
- **FR-AUTH-004**: Система должна поддерживать двухфакторную аутентификацию (2FA) с использованием TOTP, SMS и резервных кодов.
- **FR-AUTH-005**: Система должна предоставлять механизм сброса пароля через email.
- **FR-AUTH-006**: Система должна использовать JWT для управления сессиями и аутентификации API-запросов.
- **FR-AUTH-007**: Система должна поддерживать обновление токенов доступа с использованием токенов обновления.
- **FR-AUTH-008**: Система должна предоставлять возможность выхода из системы (завершение сессии).
- **FR-AUTH-009**: Система должна поддерживать аутентификацию через внешних провайдеров (OAuth 2.0, Telegram).
- **FR-AUTH-010**: Система должна реализовывать ролевую модель доступа (RBAC) для управления правами пользователей.
- **FR-AUTH-011**: Система должна предоставлять API для управления пользователями, ролями и разрешениями (для администраторов).
- **FR-AUTH-012**: Система должна вести подробный журнал аудита всех действий, связанных с аутентификацией и авторизацией.
- **FR-AUTH-013**: Система должна предоставлять API для управления API-ключами для разработчиков.
- **FR-AUTH-014**: Система должна обнаруживать и реагировать на подозрительную активность при входе.
- **FR-AUTH-015**: Система должна временно блокировать учетные записи после нескольких неудачных попыток входа.

### 12.2 Нефункциональные требования

- **NFR-AUTH-001 (Производительность)**: Время ответа на запросы аутентификации (логин, проверка токена) не должно превышать 200 мс при 95-м перцентиле под нагрузкой 1000 запросов в секунду.
- **NFR-AUTH-002 (Масштабируемость)**: Система должна быть горизонтально масштабируемой для обработки пиковых нагрузок до 5000 запросов в секунду.
- **NFR-AUTH-003 (Надежность)**: Доступность сервиса должна составлять не менее 99.95%.
- **NFR-AUTH-004 (Безопасность)**: Система должна соответствовать стандартам OWASP Top 10, использовать безопасные алгоритмы хеширования (Argon2id) и шифрования, защищать от атак перебора и утечек данных.
- **NFR-AUTH-005 (Сопровождаемость)**: Код должен быть чистым, хорошо документированным, покрыт тестами (не менее 85% покрытия).
- **NFR-AUTH-006 (Совместимость)**: API должны быть совместимы с основными веб-браузерами и мобильными платформами (через Flutter SDK).

### 12.3 Бизнес-цели

- **GOAL-AUTH-001**: Обеспечить безопасный и надежный процесс аутентификации для всех пользователей платформы.
- **GOAL-AUTH-002**: Снизить количество инцидентов безопасности, связанных с компрометацией учетных записей, на 90% в течение первого года.
- **GOAL-AUTH-003**: Упростить процесс интеграции новых микросервисов с системой аутентификации и авторизации.
- **GOAL-AUTH-004**: Обеспечить соответствие требованиям законодательства в области хранения и обработки персональных данных.

### 12.4 Ключевые показатели эффективности (KPI)

- **KPI-AUTH-001**: Процент успешных аутентификаций: > 99.5%
- **KPI-AUTH-002**: Среднее время ответа на запрос логина: < 150 мс
- **KPI-AUTH-003**: Количество инцидентов безопасности, связанных с Auth Service: < 1 в квартал
- **KPI-AUTH-004**: Уровень доступности сервиса: >= 99.95%
- **KPI-AUTH-005**: Процент пользователей, включивших 2FA: > 30% (в течение года)

### 12.5 Метрики для мониторинга

- Количество запросов в секунду (RPS) по эндпоинтам
- Задержка ответа (latency) по эндпоинтам (средняя, 95-й, 99-й перцентили)
- Количество ошибок по типам (4xx, 5xx)
- Уровень использования CPU, памяти, сети подами сервиса
- Количество активных сессий
- Количество зарегистрированных пользователей
- Количество успешных/неудачных попыток входа
- Количество событий аудита в час
- Задержка репликации базы данных
- Глубина очереди Kafka (для потребляемых событий)


## 13. Матрица ролей и прав доступа

### 13.1 Роли пользователей

| Роль | Описание | Наследование |
|------|----------|--------------|
| `guest` | Неаутентифицированный пользователь | - |
| `user` | Базовая роль для всех аутентифицированных пользователей | - |
| `premium_user` | Пользователь с премиум-подпиской | `user` |
| `developer` | Разработчик игр | `user` |
| `publisher` | Издатель игр | `developer` |
| `moderator` | Модератор контента | `user` |
| `support` | Сотрудник поддержки | `moderator` |
| `admin` | Администратор платформы | `support` |
| `system` | Системный пользователь (для внутренних сервисов) | - |

### 13.2 Разрешения (Permissions)

| Разрешение | Описание | Ресурс | Действие |
|------------|----------|--------|----------|
| `auth.login` | Вход в систему | `auth` | `login` |
| `auth.register` | Регистрация нового пользователя | `auth` | `register` |
| `auth.password.reset` | Сброс пароля | `auth` | `reset_password` |
| `auth.2fa.manage` | Управление 2FA | `auth` | `manage_2fa` |
| `auth.sessions.view` | Просмотр активных сессий | `auth` | `view_sessions` |
| `auth.sessions.manage` | Управление сессиями | `auth` | `manage_sessions` |
| `auth.api_keys.view` | Просмотр API-ключей | `auth` | `view_api_keys` |
| `auth.api_keys.manage` | Управление API-ключами | `auth` | `manage_api_keys` |
| `auth.users.view` | Просмотр пользователей | `auth` | `view_users` |
| `auth.users.manage` | Управление пользователями | `auth` | `manage_users` |
| `auth.users.block` | Блокировка пользователей | `auth` | `block_users` |
| `auth.roles.view` | Просмотр ролей | `auth` | `view_roles` |
| `auth.roles.manage` | Управление ролями | `auth` | `manage_roles` |
| `auth.permissions.view` | Просмотр разрешений | `auth` | `view_permissions` |
| `auth.permissions.manage` | Управление разрешениями | `auth` | `manage_permissions` |
| `auth.audit.view` | Просмотр журнала аудита | `auth` | `view_audit` |

### 13.3 Матрица доступа

| Разрешение | guest | user | premium_user | developer | publisher | moderator | support | admin | system |
|------------|-------|------|-------------|-----------|-----------|-----------|---------|-------|--------|
| `auth.login` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `auth.register` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `auth.password.reset` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `auth.2fa.manage` | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `auth.sessions.view` | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `auth.sessions.manage` | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `auth.api_keys.view` | ✗ | ✗ | ✗ | ✓ | ✓ | ✗ | ✓ | ✓ | ✓ |
| `auth.api_keys.manage` | ✗ | ✗ | ✗ | ✓ | ✓ | ✗ | ✗ | ✓ | ✓ |
| `auth.users.view` | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ | ✓ |
| `auth.users.manage` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ |
| `auth.users.block` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ |
| `auth.roles.view` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ |
| `auth.roles.manage` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ |
| `auth.permissions.view` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ |
| `auth.permissions.manage` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ |
| `auth.audit.view` | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ |

### 13.4 Проверка прав доступа

Проверка прав доступа осуществляется на нескольких уровнях:

1. **API Gateway**: Проверка базовой аутентификации и валидности токена
2. **Auth Service**: Проверка детальных разрешений для защищенных эндпоинтов
3. **Другие микросервисы**: Проверка через gRPC-вызов к Auth Service

Пример проверки прав в Go-коде:

```go
// Middleware для проверки разрешений
func RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("user_id")
        if userID == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            c.Abort()
            return
        }
        
        // Получение клиента gRPC
        authClient := getAuthServiceClient()
        
        // Проверка разрешения
        resp, err := authClient.CheckPermission(context.Background(), &pb.CheckPermissionRequest{
            UserId:     userID,
            Permission: permission,
        })
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "internal_server_error"})
            c.Abort()
            return
        }
        
        if !resp.HasPermission {
            c.JSON(http.StatusForbidden, gin.H{"error": "permission_denied"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

## 14. Инфраструктура и развертывание

### 14.1 Требования к инфраструктуре

- **Kubernetes**: Версия 1.26+
- **База данных**: PostgreSQL 15+
- **Кэш**: Redis 7+
- **Очередь сообщений**: Kafka 3.3+
- **Трассировка**: Jaeger
- **Мониторинг**: Prometheus + Grafana
- **Логирование**: ELK Stack (Elasticsearch, Logstash, Kibana)

### 14.2 Dockerfile

```dockerfile
# Этап сборки
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Установка зависимостей
COPY go.mod go.sum ./
RUN go mod download

# Копирование исходного кода
COPY . .

# Сборка приложения
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o auth-service ./cmd/auth-service

# Этап финального образа
FROM alpine:3.18

# Установка необходимых пакетов
RUN apk --no-cache add ca-certificates tzdata && \
    update-ca-certificates

# Создание непривилегированного пользователя
RUN adduser -D -H -h /app appuser
USER appuser

WORKDIR /app

# Копирование бинарного файла из этапа сборки
COPY --from=builder /app/auth-service .
COPY --from=builder /app/configs ./configs
COPY --from=builder /app/migrations ./migrations

# Определение переменных окружения
ENV GIN_MODE=release \
    PORT=8080 \
    CONFIG_PATH=/app/configs/config.yaml

# Проверка работоспособности
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget -qO- http://localhost:8080/health || exit 1

# Открытие портов
EXPOSE 8080 50051

# Запуск приложения
CMD ["./auth-service"]
```

### 14.3 Kubernetes-манифесты

#### 14.3.1 Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: gameplatform
  labels:
    app: auth-service
    component: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: auth-service
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: auth-service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: auth-service
        image: ${REGISTRY}/gameplatform/auth-service:${VERSION}
        imagePullPolicy: Always
        ports:
        - name: http
          containerPort: 8080
        - name: grpc
          containerPort: 50051
        env:
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: auth-service-config
              key: db_host
        - name: DB_PORT
          valueFrom:
            configMapKeyRef:
              name: auth-service-config
              key: db_port
        - name: DB_NAME
          valueFrom:
            configMapKeyRef:
              name: auth-service-config
              key: db_name
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: auth-service-secrets
              key: db_user
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: auth-service-secrets
              key: db_password
        - name: REDIS_HOST
          valueFrom:
            configMapKeyRef:
              name: auth-service-config
              key: redis_host
        - name: REDIS_PORT
          valueFrom:
            configMapKeyRef:
              name: auth-service-config
              key: redis_port
        - name: KAFKA_BROKERS
          valueFrom:
            configMapKeyRef:
              name: auth-service-config
              key: kafka_brokers
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: auth-service-secrets
              key: jwt_secret
        - name: JWT_PRIVATE_KEY
          valueFrom:
            secretKeyRef:
              name: auth-service-secrets
              key: jwt_private_key
        - name: JWT_PUBLIC_KEY
          valueFrom:
            secretKeyRef:
              name: auth-service-secrets
              key: jwt_public_key
        - name: OTEL_EXPORTER_JAEGER_ENDPOINT
          value: "http://jaeger-collector:14268/api/traces"
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 20
        volumeMounts:
        - name: config-volume
          mountPath: /app/configs
      volumes:
      - name: config-volume
        configMap:
          name: auth-service-config-files
```

#### 14.3.2 Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: auth-service
  namespace: gameplatform
  labels:
    app: auth-service
spec:
  selector:
    app: auth-service
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: grpc
    port: 50051
    targetPort: 50051
  type: ClusterIP
```

#### 14.3.3 ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: auth-service-config
  namespace: gameplatform
data:
  db_host: "postgres-auth"
  db_port: "5432"
  db_name: "auth_service"
  redis_host: "redis-auth"
  redis_port: "6379"
  kafka_brokers: "kafka-0.kafka-headless:9092,kafka-1.kafka-headless:9092,kafka-2.kafka-headless:9092"
```

#### 14.3.4 Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: auth-service-secrets
  namespace: gameplatform
type: Opaque
data:
  db_user: <base64-encoded-value>
  db_password: <base64-encoded-value>
  jwt_secret: <base64-encoded-value>
  jwt_private_key: <base64-encoded-value>
  jwt_public_key: <base64-encoded-value>
```

### 14.4 Конфигурационный файл

```yaml
# config.yaml
server:
  http:
    port: 8080
    read_timeout: 10s
    write_timeout: 10s
    idle_timeout: 60s
  grpc:
    port: 50051
    max_connection_idle: 60s
    max_connection_age: 300s

database:
  host: ${DB_HOST}
  port: ${DB_PORT}
  name: ${DB_NAME}
  user: ${DB_USER}
  password: ${DB_PASSWORD}
  ssl_mode: disable
  max_open_conns: 25
  max_idle_conns: 25
  conn_max_lifetime: 5m

redis:
  host: ${REDIS_HOST}
  port: ${REDIS_PORT}
  db: 0
  pool_size: 10

kafka:
  brokers: ${KAFKA_BROKERS}
  consumer_group: auth-service
  topics:
    publish: auth-events
    subscribe:
      - account-events
      - admin-events

jwt:
  access_token:
    secret: ${JWT_SECRET}
    private_key: ${JWT_PRIVATE_KEY}
    public_key: ${JWT_PUBLIC_KEY}
    algorithm: RS256
    expires_in: 15m
  refresh_token:
    expires_in: 30d

security:
  password:
    min_length: 8
    require_uppercase: true
    require_lowercase: true
    require_digit: true
    require_special: true
  argon2:
    memory: 65536
    iterations: 3
    parallelism: 4
    salt_length: 16
    key_length: 32
  rate_limit:
    login:
      requests: 5
      duration: 1m
    register:
      requests: 3
      duration: 1m
    reset_password:
      requests: 3
      duration: 1m

logging:
  level: info
  format: json
  output: stdout

tracing:
  enabled: true
  service_name: auth-service
  exporter: jaeger

metrics:
  enabled: true
  path: /metrics
```

### 14.5 CI/CD Pipeline

#### 14.5.1 GitLab CI/CD (.gitlab-ci.yml)

```yaml
stages:
  - test
  - build
  - deploy

variables:
  REGISTRY: registry.gameplatform.ru
  IMAGE_NAME: gameplatform/auth-service
  DOCKER_HOST: tcp://docker:2375
  DOCKER_DRIVER: overlay2

test:
  stage: test
  image: golang:1.21
  script:
    - go mod download
    - go test -v -race -coverprofile=coverage.out ./...
    - go tool cover -func=coverage.out
  artifacts:
    paths:
      - coverage.out
    expire_in: 1 week

lint:
  stage: test
  image: golangci/golangci-lint:v1.54
  script:
    - golangci-lint run --timeout 5m

build:
  stage: build
  image: docker:20.10
  services:
    - docker:20.10-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $REGISTRY
    - docker build -t $REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA -t $REGISTRY/$IMAGE_NAME:latest .
    - docker push $REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA
    - docker push $REGISTRY/$IMAGE_NAME:latest
  only:
    - main
    - tags

deploy-dev:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context gameplatform/gameplatform:dev
    - sed -i "s|\${REGISTRY}|$REGISTRY|g; s|\${VERSION}|$CI_COMMIT_SHA|g" kubernetes/deployment.yaml
    - kubectl apply -f kubernetes/namespace.yaml
    - kubectl apply -f kubernetes/configmap.yaml
    - kubectl apply -f kubernetes/secret.yaml
    - kubectl apply -f kubernetes/deployment.yaml
    - kubectl apply -f kubernetes/service.yaml
    - kubectl rollout status deployment/auth-service -n gameplatform
  environment:
    name: development
  only:
    - main

deploy-prod:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context gameplatform/gameplatform:prod
    - sed -i "s|\${REGISTRY}|$REGISTRY|g; s|\${VERSION}|$CI_COMMIT_TAG|g" kubernetes/deployment.yaml
    - kubectl apply -f kubernetes/namespace.yaml
    - kubectl apply -f kubernetes/configmap.yaml
    - kubectl apply -f kubernetes/secret.yaml
    - kubectl apply -f kubernetes/deployment.yaml
    - kubectl apply -f kubernetes/service.yaml
    - kubectl rollout status deployment/auth-service -n gameplatform
  environment:
    name: production
  only:
    - tags
  when: manual
```

## 15. Примеры кода

### 15.1 Основная структура проекта

```
auth-service/
├── cmd/
│   └── auth-service/
│       └── main.go
├── configs/
│   └── config.yaml
├── internal/
│   ├── app/
│   │   └── app.go
│   ├── config/
│   │   └── config.go
│   ├── controller/
│   │   ├── http/
│   │   │   ├── handler.go
│   │   │   ├── auth_handler.go
│   │   │   ├── user_handler.go
│   │   │   └── admin_handler.go
│   │   └── grpc/
│   │       ├── server.go
│   │       └── auth_service.go
│   ├── domain/
│   │   ├── entity/
│   │   │   ├── user.go
│   │   │   ├── session.go
│   │   │   ├── role.go
│   │   │   └── audit_log.go
│   │   ├── repository/
│   │   │   ├── user_repository.go
│   │   │   ├── session_repository.go
│   │   │   └── role_repository.go
│   │   └── service/
│   │       ├── auth_service.go
│   │       ├── user_service.go
│   │       └── token_service.go
│   ├── infrastructure/
│   │   ├── database/
│   │   │   └── postgres.go
│   │   ├── cache/
│   │   │   └── redis.go
│   │   ├── messaging/
│   │   │   └── kafka.go
│   │   ├── security/
│   │   │   ├── password.go
│   │   │   └── jwt.go
│   │   └── tracing/
│   │       └── jaeger.go
│   └── middleware/
│       ├── auth.go
│       ├── logging.go
│       └── rate_limit.go
├── migrations/
│   ├── 20250101000000_create_users_table.up.sql
│   ├── 20250101000000_create_users_table.down.sql
│   └── ...
├── pkg/
│   ├── logger/
│   │   └── logger.go
│   ├── validator/
│   │   └── validator.go
│   └── errors/
│       └── errors.go
├── proto/
│   └── auth/
│       └── auth.proto
├── Dockerfile
├── go.mod
├── go.sum
└── README.md
```

### 15.2 Пример реализации аутентификации

```go
// internal/domain/service/auth_service.go
package service

import (
	"context"
	"errors"
	"time"

	"github.com/gameplatform/auth-service/internal/domain/entity"
	"github.com/gameplatform/auth-service/internal/domain/repository"
	"github.com/gameplatform/auth-service/internal/infrastructure/security"
	"github.com/gameplatform/auth-service/pkg/logger"
)

type AuthService struct {
	userRepo    repository.UserRepository
	sessionRepo repository.SessionRepository
	tokenSvc    TokenService
	passwordSvc security.PasswordService
	logger      logger.Logger
}

func NewAuthService(
	userRepo repository.UserRepository,
	sessionRepo repository.SessionRepository,
	tokenSvc TokenService,
	passwordSvc security.PasswordService,
	logger logger.Logger,
) *AuthService {
	return &AuthService{
		userRepo:    userRepo,
		sessionRepo: sessionRepo,
		tokenSvc:    tokenSvc,
		passwordSvc: passwordSvc,
		logger:      logger,
	}
}

type LoginRequest struct {
	Login    string `json:"login" validate:"required"`
	Password string `json:"password" validate:"required"`
	IP       string `json:"ip"`
	UserAgent string `json:"user_agent"`
	DeviceInfo map[string]interface{} `json:"device_info"`
}

type LoginResponse struct {
	AccessToken  string     `json:"access_token"`
	RefreshToken string     `json:"refresh_token"`
	TokenType    string     `json:"token_type"`
	ExpiresIn    int        `json:"expires_in"`
	User         *UserInfo  `json:"user"`
	RequireMFA   bool       `json:"require_mfa,omitempty"`
	MFAMethods   []string   `json:"mfa_methods,omitempty"`
	TempToken    string     `json:"temp_token,omitempty"`
}

type UserInfo struct {
	ID          string   `json:"id"`
	Username    string   `json:"username"`
	Email       string   `json:"email"`
	DisplayName string   `json:"display_name"`
	Roles       []string `json:"roles"`
}

func (s *AuthService) Login(ctx context.Context, req LoginRequest) (*LoginResponse, error) {
	// Поиск пользователя по логину (имя пользователя или email)
	user, err := s.userRepo.FindByLoginOrEmail(ctx, req.Login)
	if err != nil {
		s.logger.Warn("Login attempt failed: user not found", map[string]interface{}{
			"login": req.Login,
			"ip":    req.IP,
		})
		return nil, errors.New("invalid_credentials")
	}

	// Проверка статуса пользователя
	if user.Status != entity.UserStatusActive {
		s.logger.Warn("Login attempt for inactive user", map[string]interface{}{
			"user_id": user.ID,
			"status":  user.Status,
			"ip":      req.IP,
		})
		
		switch user.Status {
		case entity.UserStatusBlocked:
			return nil, errors.New("user_blocked")
		case entity.UserStatusPendingVerification:
			return nil, errors.New("email_not_verified")
		default:
			return nil, errors.New("user_inactive")
		}
	}

	// Проверка пароля
	if !s.passwordSvc.Verify(req.Password, user.PasswordHash) {
		s.logger.Warn("Login attempt with invalid password", map[string]interface{}{
			"user_id": user.ID,
			"ip":      req.IP,
		})
		
		// Увеличение счетчика неудачных попыток
		if err := s.userRepo.IncrementFailedLoginAttempts(ctx, user.ID); err != nil {
			s.logger.Error("Failed to increment failed login attempts", map[string]interface{}{
				"user_id": user.ID,
				"error":   err.Error(),
			})
		}
		
		return nil, errors.New("invalid_credentials")
	}

	// Проверка необходимости 2FA
	mfaDevices, err := s.userRepo.GetMFADevices(ctx, user.ID)
	if err != nil {
		s.logger.Error("Failed to get MFA devices", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		return nil, errors.New("internal_error")
	}

	// Если у пользователя есть настроенные MFA-устройства
	if len(mfaDevices) > 0 {
		// Генерация временного токена для 2FA
		tempToken, err := s.tokenSvc.GenerateTempToken(user.ID, 300) // 5 минут
		if err != nil {
			s.logger.Error("Failed to generate temp token for 2FA", map[string]interface{}{
				"user_id": user.ID,
				"error":   err.Error(),
			})
			return nil, errors.New("internal_error")
		}

		// Подготовка списка доступных методов 2FA
		methods := make([]string, 0, len(mfaDevices))
		for _, device := range mfaDevices {
			methods = append(methods, device.Type)
		}

		return &LoginResponse{
			RequireMFA: true,
			MFAMethods: methods,
			TempToken:  tempToken,
		}, nil
	}

	// Создание новой сессии
	session := &entity.Session{
		UserID:         user.ID,
		IPAddress:      req.IP,
		UserAgent:      req.UserAgent,
		DeviceInfo:     req.DeviceInfo,
		ExpiresAt:      time.Now().Add(30 * 24 * time.Hour), // 30 дней
		LastActivityAt: time.Now(),
	}

	if err := s.sessionRepo.Create(ctx, session); err != nil {
		s.logger.Error("Failed to create session", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		return nil, errors.New("internal_error")
	}

	// Получение ролей пользователя
	roles, err := s.userRepo.GetUserRoles(ctx, user.ID)
	if err != nil {
		s.logger.Error("Failed to get user roles", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		return nil, errors.New("internal_error")
	}

	// Генерация токенов
	accessToken, err := s.tokenSvc.GenerateAccessToken(user.ID, user.Username, roles, session.ID)
	if err != nil {
		s.logger.Error("Failed to generate access token", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		return nil, errors.New("internal_error")
	}

	refreshToken, err := s.tokenSvc.GenerateRefreshToken(user.ID, session.ID)
	if err != nil {
		s.logger.Error("Failed to generate refresh token", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		return nil, errors.New("internal_error")
	}

	// Обновление времени последнего входа
	if err := s.userRepo.UpdateLastLogin(ctx, user.ID); err != nil {
		s.logger.Error("Failed to update last login time", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		// Не возвращаем ошибку, так как это некритично
	}

	// Сброс счетчика неудачных попыток
	if err := s.userRepo.ResetFailedLoginAttempts(ctx, user.ID); err != nil {
		s.logger.Error("Failed to reset failed login attempts", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		// Не возвращаем ошибку, так как это некритично
	}

	// Запись события успешного входа в журнал аудита
	if err := s.logAuditEvent(ctx, "login_success", user.ID, req.IP, req.UserAgent); err != nil {
		s.logger.Error("Failed to log audit event", map[string]interface{}{
			"user_id": user.ID,
			"error":   err.Error(),
		})
		// Не возвращаем ошибку, так как это некритично
	}

	// Проверка подозрительной активности
	if s.isSuspiciousLogin(ctx, user.ID, req.IP, req.DeviceInfo) {
		// Публикация события о подозрительном входе
		s.publishSuspiciousLoginEvent(ctx, user.ID, req.IP, req.UserAgent, req.DeviceInfo)
	}

	return &LoginResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		TokenType:    "Bearer",
		ExpiresIn:    900, // 15 минут в секундах
		User: &UserInfo{
			ID:          user.ID,
			Username:    user.Username,
			Email:       user.Email,
			DisplayName: user.DisplayName,
			Roles:       roles,
		},
	}, nil
}

// Вспомогательные методы
func (s *AuthService) logAuditEvent(ctx context.Context, action, userID, ip, userAgent string) error {
	// Реализация
	return nil
}

func (s *AuthService) isSuspiciousLogin(ctx context.Context, userID, ip string, deviceInfo map[string]interface{}) bool {
	// Реализация
	return false
}

func (s *AuthService) publishSuspiciousLoginEvent(ctx context.Context, userID, ip, userAgent string, deviceInfo map[string]interface{}) {
	// Реализация
}
```

### 15.3 Пример HTTP-контроллера

```go
// internal/controller/http/auth_handler.go
package http

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gameplatform/auth-service/internal/domain/service"
	"github.com/gameplatform/auth-service/pkg/logger"
	"github.com/gameplatform/auth-service/pkg/validator"
)

type AuthHandler struct {
	authService *service.AuthService
	logger      logger.Logger
	validator   validator.Validator
}

func NewAuthHandler(authService *service.AuthService, logger logger.Logger, validator validator.Validator) *AuthHandler {
	return &AuthHandler{
		authService: authService,
		logger:      logger,
		validator:   validator,
	}
}

func (h *AuthHandler) Register(router *gin.Engine) {
	auth := router.Group("/api/v1/auth")
	{
		auth.POST("/register", h.Register)
		auth.POST("/login", h.Login)
		auth.POST("/logout", h.Logout)
		auth.POST("/refresh", h.RefreshToken)
		auth.POST("/verify-email", h.VerifyEmail)
		auth.POST("/resend-verification", h.ResendVerification)
		auth.POST("/forgot-password", h.ForgotPassword)
		auth.POST("/reset-password", h.ResetPassword)
		auth.POST("/2fa/verify", h.VerifyTwoFactor)
	}
}

// Login godoc
// @Summary Аутентификация пользователя
// @Description Вход пользователя в систему с использованием имени пользователя/email и пароля
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginRequest true "Данные для входа"
// @Success 200 {object} LoginResponse "Успешный вход"
// @Success 200 {object} TwoFactorRequiredResponse "Требуется двухфакторная аутентификация"
// @Failure 400 {object} ErrorResponse "Неверный запрос"
// @Failure 401 {object} ErrorResponse "Неверные учетные данные"
// @Failure 403 {object} ErrorResponse "Пользователь заблокирован или email не подтвержден"
// @Failure 429 {object} ErrorResponse "Слишком много попыток"
// @Failure 500 {object} ErrorResponse "Внутренняя ошибка сервера"
// @Router /api/v1/auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) {
	var req struct {
		Login    string `json:"login" binding:"required"`
		Password string `json:"password" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": gin.H{
				"code":    "invalid_request",
				"message": "Неверный формат запроса",
				"details": err.Error(),
			},
		})
		return
	}

	// Получение IP и User-Agent
	ip := c.ClientIP()
	userAgent := c.GetHeader("User-Agent")

	// Подготовка запроса к сервису
	loginReq := service.LoginRequest{
		Login:      req.Login,
		Password:   req.Password,
		IP:         ip,
		UserAgent:  userAgent,
		DeviceInfo: map[string]interface{}{
			"user_agent": userAgent,
			// Дополнительная информация об устройстве может быть добавлена здесь
		},
	}

	// Вызов сервиса
	resp, err := h.authService.Login(c.Request.Context(), loginReq)
	if err != nil {
		switch err.Error() {
		case "invalid_credentials":
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": gin.H{
					"code":    "invalid_credentials",
					"message": "Неверное имя пользователя или пароль",
				},
			})
		case "user_blocked":
			c.JSON(http.StatusForbidden, gin.H{
				"error": gin.H{
					"code":    "user_blocked",
					"message": "Пользователь заблокирован",
				},
			})
		case "email_not_verified":
			c.JSON(http.StatusForbidden, gin.H{
				"error": gin.H{
					"code":    "email_not_verified",
					"message": "Email не подтвержден",
				},
			})
		case "too_many_attempts":
			c.JSON(http.StatusTooManyRequests, gin.H{
				"error": gin.H{
					"code":    "too_many_attempts",
					"message": "Слишком много попыток входа. Попробуйте позже.",
				},
			})
		default:
			h.logger.Error("Login error", map[string]interface{}{
				"error": err.Error(),
				"login": req.Login,
				"ip":    ip,
			})
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": gin.H{
					"code":    "internal_server_error",
					"message": "Внутренняя ошибка сервера",
				},
			})
		}
		return
	}

	// Если требуется 2FA
	if resp.RequireMFA {
		c.JSON(http.StatusOK, gin.H{
			"status":           "2fa_required",
			"temp_token":       resp.TempToken,
			"available_methods": resp.MFAMethods,
			"expires_in":       300,
		})
		return
	}

	// Успешный вход
	c.JSON(http.StatusOK, resp)
}
```

### 15.4 Пример gRPC-сервера

```go
// internal/controller/grpc/auth_service.go
package grpc

import (
	"context"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/gameplatform/auth-service/internal/domain/service"
	pb "github.com/gameplatform/auth-service/proto/auth"
	"github.com/gameplatform/auth-service/pkg/logger"
)

type AuthServiceServer struct {
	pb.UnimplementedAuthServiceServer
	authService *service.AuthService
	userService *service.UserService
	logger      logger.Logger
}

func NewAuthServiceServer(
	authService *service.AuthService,
	userService *service.UserService,
	logger logger.Logger,
) *AuthServiceServer {
	return &AuthServiceServer{
		authService: authService,
		userService: userService,
		logger:      logger,
	}
}

func (s *AuthServiceServer) ValidateToken(ctx context.Context, req *pb.ValidateTokenRequest) (*pb.ValidateTokenResponse, error) {
	// Проверка токена
	claims, err := s.authService.ValidateToken(ctx, req.Token)
	if err != nil {
		s.logger.Warn("Token validation failed", map[string]interface{}{
			"error": err.Error(),
		})
		return &pb.ValidateTokenResponse{
			Valid: false,
		}, nil
	}

	// Получение информации о пользователе
	user, err := s.userService.GetUserByID(ctx, claims.UserID)
	if err != nil {
		s.logger.Error("Failed to get user by ID", map[string]interface{}{
			"user_id": claims.UserID,
			"error":   err.Error(),
		})
		return nil, status.Error(codes.Internal, "internal_error")
	}

	// Преобразование времени истечения токена
	expiresAt := timestamppb.New(claims.ExpiresAt)

	return &pb.ValidateTokenResponse{
		Valid: true,
		User: &pb.UserInfo{
			Id:              user.ID,
			Username:        user.Username,
			Email:           user.Email,
			Status:          user.Status,
			CreatedAt:       timestamppb.New(user.CreatedAt),
			EmailVerifiedAt: timestamppb.New(user.EmailVerifiedAt),
			LastLoginAt:     timestamppb.New(user.LastLoginAt),
			Roles:           claims.Roles,
		},
		Roles:       claims.Roles,
		Permissions: claims.Permissions,
		ExpiresAt:   expiresAt,
	}, nil
}

func (s *AuthServiceServer) CheckPermission(ctx context.Context, req *pb.CheckPermissionRequest) (*pb.CheckPermissionResponse, error) {
	// Проверка разрешения
	hasPermission, err := s.authService.CheckPermission(ctx, req.UserId, req.Permission, req.ResourceId)
	if err != nil {
		s.logger.Error("Failed to check permission", map[string]interface{}{
			"user_id":    req.UserId,
			"permission": req.Permission,
			"resource_id": req.ResourceId,
			"error":      err.Error(),
		})
		return nil, status.Error(codes.Internal, "internal_error")
	}

	return &pb.CheckPermissionResponse{
		HasPermission: hasPermission,
	}, nil
}

func (s *AuthServiceServer) GetUserInfo(ctx context.Context, req *pb.GetUserInfoRequest) (*pb.UserInfo, error) {
	// Получение информации о пользователе
	user, err := s.userService.GetUserByID(ctx, req.UserId)
	if err != nil {
		s.logger.Error("Failed to get user by ID", map[string]interface{}{
			"user_id": req.UserId,
			"error":   err.Error(),
		})
		return nil, status.Error(codes.Internal, "internal_error")
	}

	// Получение ролей пользователя
	roles, err := s.userService.GetUserRoles(ctx, req.UserId)
	if err != nil {
		s.logger.Error("Failed to get user roles", map[string]interface{}{
			"user_id": req.UserId,
			"error":   err.Error(),
		})
		return nil, status.Error(codes.Internal, "internal_error")
	}

	return &pb.UserInfo{
		Id:              user.ID,
		Username:        user.Username,
		Email:           user.Email,
		Status:          user.Status,
		CreatedAt:       timestamppb.New(user.CreatedAt),
		EmailVerifiedAt: timestamppb.New(user.EmailVerifiedAt),
		LastLoginAt:     timestamppb.New(user.LastLoginAt),
		Roles:           roles,
	}, nil
}

func (s *AuthServiceServer) HealthCheck(ctx context.Context, _ *emptypb.Empty) (*pb.HealthCheckResponse, error) {
	// Проверка здоровья сервиса
	// Здесь можно добавить проверку подключения к базе данных, Redis и т.д.
	return &pb.HealthCheckResponse{
		Status: pb.HealthCheckResponse_SERVING,
	}, nil
}

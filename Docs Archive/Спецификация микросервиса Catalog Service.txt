# Спецификация микросервиса Catalog Service

**Версия:** 3.0
**Дата:** 2025-05-25

## Содержание

1. [Глоссарий](#1-глоссарий)
2. [Введение](#2-введение)
3. [Требования и цели](#3-требования-и-цели)
4. [Архитектура](#4-архитектура)
5. [Бизнес-логика и сценарии использования](#5-бизнес-логика-и-сценарии-использования)
6. [Структура данных и API](#6-структура-данных-и-api)
7. [Интеграции](#7-интеграции)
8. [Безопасность](#8-безопасность)
9. [Мониторинг, логирование и трассировка](#9-мониторинг-логирование-и-трассировка)
10. [Масштабируемость и отказоустойчивость](#10-масштабируемость-и-отказоустойчивость)
11. [Инфраструктурные файлы и развертывание](#11-инфраструктурные-файлы-и-развертывание)
12. [Роли и права доступа](#12-роли-и-права-доступа)
13. [Тестирование](#13-тестирование)
14. [Документация](#14-документация)

## 1. Глоссарий

Этот раздел содержит определения ключевых терминов, используемых в данной спецификации, для обеспечения единообразия и ясности. Определения основаны на [Едином глоссарии терминов и определений для российского аналога Steam](link-to-glossary-document) и дополнены техническими терминами, специфичными для данного микросервиса.

### 1.1 Бизнес-термины

- **Платформа**: Российский аналог Steam, цифровая платформа для дистрибуции игр и программного обеспечения.
- **Продукт (Product)**: Любой цифровой товар, доступный в каталоге платформы. Включает Игры, DLC, ПО, Комплекты.
- **Игра (Game)**: Основной тип продукта - интерактивное развлекательное программное обеспечение.
- **DLC (Downloadable Content)**: Дополнительный загружаемый контент для Игры, расширяющий ее функциональность или добавляющий новые элементы (например, уровни, предметы, скины).
- **ПО (Software)**: Программное обеспечение неигрового характера, распространяемое через платформу.
- **Комплект (Bundle)**: Набор из нескольких Продуктов (Игр, DLC, ПО), продаваемый как единое целое, часто со скидкой.
- **Метаданные (Metadata)**: Описательная информация о Продукте (название, описание, разработчик, издатель, дата выхода, системные требования, возрастные рейтинги, языки и т.д.).
- **Локализация (Localization)**: Адаптация метаданных и интерфейса Продукта для конкретного языка и региона.
- **Разработчик (Developer)**: Компания или физическое лицо, создавшее Продукт.
- **Издатель (Publisher)**: Компания, ответственная за маркетинг, дистрибуцию и продажу Продукта.
- **Жанр (Genre)**: Категория, классифицирующая Игры по стилю геймплея или тематике (например, RPG, Strategy, Action).
- **Тег (Tag)**: Метка, описывающая специфические характеристики или особенности Продукта (например, Multiplayer, Indie, Open World, VR Support). Могут быть системными (управляемыми администраторами) или пользовательскими (предложенными пользователями и одобренными модераторами).
- **Категория (Category)**: Более широкая классификация Продуктов (например, Single-player, Multi-player, Co-op, Steam Deck Verified).
- **Франшиза/Серия (Franchise/Series)**: Группа связанных Продуктов, объединенных общим миром, персонажами или брендом.
- **Коллекция (Collection)**: Курируемый список Продуктов, созданный администраторами или издателями (например, "Лучшие инди-игры 2025", "Игры по вселенной X").
- **Цена (Price)**: Стоимость Продукта. Может быть базовой и региональной.
- **Валюта (Currency)**: Денежная единица, в которой выражена Цена (RUB, USD, EUR и т.д.).
- **Региональная цена (Regional Price)**: Цена Продукта, установленная для конкретного географического региона.
- **Скидка (Discount)**: Временное или постоянное снижение Цены на Продукт. Может быть процентной или фиксированной.
- **Акция (Promotion/Sale)**: Маркетинговое мероприятие, в рамках которого предлагаются Скидки на определенные Продукты или группы Продуктов в течение ограниченного времени.
- **Промокод (Promo Code)**: Уникальный код, предоставляющий Скидку или доступ к Продукту.
- **Медиа-контент (Media Content)**: Графические и видеоматериалы, связанные с Продуктом (скриншоты, трейлеры, арты, обложки).
- **Скриншот (Screenshot)**: Статическое изображение, демонстрирующее игровой процесс или интерфейс Продукта.
- **Трейлер (Trailer)**: Видеоролик, рекламирующий или демонстрирующий Продукт.
- **Арт (Artwork)**: Концепт-арты, иллюстрации, обои, связанные с Продуктом.
- **Обложка (Cover/Capsule Image)**: Основное графическое представление Продукта в каталоге и библиотеке.
- **Системные требования (System Requirements)**: Минимальные и рекомендуемые характеристики аппаратного и программного обеспечения, необходимые для запуска Продукта на определенной платформе (Windows, macOS, Linux).
- **Платформа ОС (OS Platform)**: Операционная система, на которой может работать Продукт (Windows, macOS, Linux).
- **Возрастной рейтинг (Age Rating)**: Ограничение по возрасту для доступа к Продукту, установленное в соответствии с законодательством РФ (0+, 6+, 12+, 16+, 18+).
- **Модерация (Moderation)**: Процесс проверки контента Продукта (метаданные, медиа) на соответствие правилам платформы и законодательству перед публикацией.
- **Статус модерации (Moderation Status)**: Текущее состояние проверки контента (Pending, Approved, Rejected).
- **Статус продукта (Product Status)**: Жизненный цикл Продукта на платформе (Draft, In Review, Upcoming, Released, Delisted, Archived).
- **Достижение (Achievement)**: Виртуальная награда, выдаваемая пользователю за выполнение определенных условий в Игре. Catalog Service хранит метаданные достижений.
- **Рекомендация (Recommendation)**: Предложение Продукта пользователю, основанное на его предпочтениях, истории покупок, поведении или поведении других пользователей.
- **Отзыв (Review)**: Мнение пользователя о Продукте, включая оценку и текстовый комментарий. Управляется Social Service, но Catalog Service может хранить агрегированный рейтинг.
- **Рейтинг (Rating)**: Числовая или качественная оценка Продукта, основанная на отзывах пользователей или экспертных оценках.
- **Список желаемого (Wishlist)**: Список Продуктов, которые пользователь хочет приобрести в будущем. Управляется Library Service.
- **Библиотека пользователя (User Library)**: Список Продуктов, которыми владеет пользователь. Управляется Library Service.
- **Учетная запись пользователя (User Account)**: Запись, содержащая информацию о пользователе платформы. Управляется Account Service.
- **Роль (Role)**: Набор прав доступа, определяющий возможности пользователя или сервиса в системе (user, developer, publisher, moderator, admin, support, service).

### 1.2 Технические термины

- **Микросервис (Microservice)**: Независимо развертываемый компонент системы, реализующий определенную бизнес-возможность.
- **API (Application Programming Interface)**: Интерфейс для взаимодействия программных компонентов.
- **REST API (Representational State Transfer API)**: Архитектурный стиль API, использующий HTTP(S) для взаимодействия. Применяется для внешних и некоторых внутренних коммуникаций.
- **gRPC (gRPC Remote Procedure Calls)**: Высокопроизводительный фреймворк RPC от Google, использующий HTTP/2 и Protocol Buffers. Применяется для внутреннего взаимодействия микросервисов.
- **Protocol Buffers (Protobuf)**: Механизм сериализации структурированных данных от Google, используемый в gRPC.
- **JSON (JavaScript Object Notation)**: Текстовый формат обмена данными, используемый в REST API.
- **YAML (YAML Ain't Markup Language)**: Формат сериализации данных, часто используемый для конфигурационных файлов.
- **Событие (Event)**: Сообщение, описывающее произошедшее изменение состояния или действие в системе.
- **Шина событий (Event Bus)**: Система для асинхронной передачи Событий между компонентами (например, Kafka, NATS JetStream).
- **Kafka (Apache Kafka)**: Распределенная платформа потоковой передачи событий.
- **Топик Kafka (Kafka Topic)**: Именованный канал для публикации и подписки на потоки событий в Kafka.
- **CloudEvents**: Спецификация для описания данных событий в общем формате.
- **База данных (Database)**: Система для хранения и управления данными.
- **PostgreSQL**: Свободная объектно-реляционная СУБД.
- **SQL (Structured Query Language)**: Язык запросов к реляционным базам данных.
- **DDL (Data Definition Language)**: Подмножество SQL для определения структуры базы данных (CREATE TABLE, ALTER TABLE).
- **DML (Data Manipulation Language)**: Подмножество SQL для манипулирования данными (SELECT, INSERT, UPDATE, DELETE).
- **Транзакция (Transaction)**: Логическая единица работы с базой данных, обладающая свойствами ACID.
- **Репликация (Replication)**: Процесс копирования данных из одной базы данных (master) в другую (replica) для повышения доступности и производительности чтения.
- **Шардирование (Sharding)**: Горизонтальное разделение данных базы данных по нескольким серверам.
- **Поисковый движок (Search Engine)**: Система, оптимизированная для полнотекстового поиска и анализа данных.
- **Elasticsearch**: Распределенный поисковый и аналитический движок.
- **Индексация (Indexing)**: Процесс создания структур данных (индексов) для ускорения поиска.
- **Кэш (Cache)**: Система для временного хранения часто запрашиваемых данных для ускорения доступа.
- **Redis**: Нереляционная высокопроизводительная СУБД класса NoSQL, часто используемая как кэш или брокер сообщений.
- **CDN (Content Delivery Network)**: Географически распределенная сетевая инфраструктура для быстрой доставки контента.
- **S3 (Simple Storage Service)**: Сервис объектного хранения данных (или S3-совместимое хранилище).
- **Go (Golang)**: Язык программирования, используемый для разработки бэкенда.
- **Echo**: Высокопроизводительный, расширяемый, минималистичный веб-фреймворк для Go.
- **GORM**: ORM-библиотека для Go.
- **Squirrel**: Fluent SQL-генератор для Go.
- **Viper**: Библиотека для работы с конфигурацией в Go.
- **Zap**: Высокопроизводительная библиотека для структурированного логирования в Go.
- **OpenTelemetry**: Набор API, SDK и инструментов для сбора и экспорта телеметрии (метрик, логов, трассировок).
- **Jaeger**: Распределенная система трассировки.
- **Prometheus**: Система мониторинга и оповещения.
- **Grafana**: Платформа для визуализации данных и мониторинга.
- **Fluent Bit**: Сборщик и пересыльщик логов и метрик.
- **Docker**: Платформа контейнеризации.
- **Контейнер (Container)**: Изолированная среда для запуска приложения.
- **Образ Docker (Docker Image)**: Шаблон для создания контейнеров.
- **Dockerfile**: Файл с инструкциями для сборки образа Docker.
- **Kubernetes (K8s)**: Платформа оркестрации контейнеров.
- **Под (Pod)**: Минимальная развертываемая единица в Kubernetes, содержащая один или несколько контейнеров.
- **Deployment**: Объект Kubernetes, управляющий развертыванием и масштабированием подов.
- **Service**: Объект Kubernetes, предоставляющий сетевой доступ к подам.
- **ConfigMap**: Объект Kubernetes для хранения нечувствительной конфигурации.
- **Secret**: Объект Kubernetes для хранения чувствительной информации.
- **HPA (Horizontal Pod Autoscaler)**: Механизм Kubernetes для автоматического масштабирования подов.
- **CI/CD (Continuous Integration/Continuous Deployment)**: Практики непрерывной интеграции и развертывания.
- **Git**: Распределенная система контроля версий.
- **JWT (JSON Web Token)**: Стандарт для создания токенов доступа.
- **RBAC (Role-Based Access Control)**: Модель управления доступом на основе ролей.
- **mTLS (Mutual TLS)**: Взаимная аутентификация на основе TLS-сертификатов.
- **SLI (Service Level Indicator)**: Количественная метрика уровня обслуживания (например, latency, error rate).
- **SLO (Service Level Objective)**: Целевое значение для SLI (например, P95 latency < 150ms).
- **SLA (Service Level Agreement)**: Соглашение об уровне обслуживания, часто включающее SLO и последствия их нарушения.
- **RTO (Recovery Time Objective)**: Целевое время восстановления сервиса после сбоя.
- **RPO (Recovery Point Objective)**: Целевая точка восстановления данных (максимально допустимый объем потери данных).
- **CQRS (Command Query Responsibility Segregation)**: Архитектурный паттерн, разделяющий операции чтения и записи.
- **Stateless**: Свойство сервиса не хранить состояние между запросами, что облегчает масштабирование.
- **Idempotent**: Свойство операции, при котором повторное выполнение дает тот же результат, что и первое.

## 2. Введение

### 2.1 Назначение документа

Данный документ представляет собой **исчерпывающую** спецификацию микросервиса Catalog Service для российского аналога платформы Steam. Он служит **единственным источником правды** для всех аспектов разработки, развертывания и поддержки данного сервиса. Документ содержит максимально детализированное описание требований (функциональных и нефункциональных), архитектурных решений, бизнес-логики, форматов данных, API (REST и gRPC), интеграций с другими системами, подходов к обеспечению безопасности, мониторинга, масштабируемости, отказоустойчивости, а также процедур тестирования и развертывания. Спецификация предназначена для использования всеми участниками команды проекта: backend- и frontend-разработчиками, архитекторами, QA-инженерами, DevOps-специалистами, техническими писателями и менеджерами.

### 2.2 Область применения

Catalog Service является **ядром** платформы, отвечающим за всю информацию о цифровых продуктах. Его основные функции включают:

- **Централизованное управление каталогом**: Хранение и управление полными метаданными всех продуктов (игры, DLC, ПО, комплекты).
- **Ценообразование и акции**: Управление базовыми и региональными ценами, скидками, промокодами и акциями.
- **Таксономия и организация**: Управление жанрами, тегами, категориями, франшизами и коллекциями для структурирования каталога.
- **Поиск и обнаружение**: Предоставление мощных механизмов поиска, фильтрации и сортировки продуктов.
- **Управление медиа**: Хранение ссылок и метаданных для медиа-контента (скриншоты, трейлеры, арты), интеграция с CDN.
- **Управление достижениями**: Хранение метаданных достижений для игр.
- **Модерация**: Обеспечение механизмов и хранение статусов модерации контента продуктов.
- **Рекомендации**: Предоставление данных и API для системы рекомендаций.
- **Предоставление данных**: Обеспечение других микросервисов актуальной и согласованной информацией о продуктах через API и события.

### 2.3 Связь с другими микросервисами

Catalog Service является **ключевым поставщиком данных** для большинства других сервисов платформы и тесно интегрирован с ними:

- **Account Service**: Получает информацию о регионе пользователя для отображения региональных цен (опционально, может передаваться через API Gateway).
- **Auth Service**: Используется для аутентификации и авторизации запросов к защищенным API Catalog Service.
- **Library Service**: Получает метаданные продуктов для отображения в библиотеках и списках желаемого; получает метаданные достижений.
- **Payment Service**: Получает актуальные цены, скидки и информацию о продуктах для формирования заказов и обработки платежей.
- **Developer Service**: **Основной клиент** для API управления каталогом. Через него разработчики/издатели добавляют и обновляют свои продукты, цены, медиа.
- **Download Service**: Получает метаданные продуктов, информацию о версиях и ссылки на манифесты файлов для организации загрузок.
- **Social Service**: Получает метаданные продуктов для отображения в отзывах, обсуждениях, лентах активности.
- **Admin Service**: Использует API управления каталогом для модерации, управления глобальными настройками каталога, акциями.
- **Analytics Service**: Получает события об изменениях в каталоге (`product.created`, `price.updated` и т.д.) для сбора статистики и анализа. Может предоставлять данные для системы рекомендаций Catalog Service.
- **Notification Service**: Получает события от Catalog Service (`product.released.from.wishlist`, `discount.started`) для инициирования уведомлений пользователям.
- **API Gateway**: Проксирует все внешние запросы к Catalog Service, выполняет первичную аутентификацию/авторизацию, может кэшировать ответы.

## 3. Требования и цели

### 3.1 Назначение сервиса

Catalog Service – это **централизованная система управления жизненным циклом и метаданными всех цифровых продуктов**, доступных на платформе российского аналога Steam. Он обеспечивает согласованность, актуальность и доступность информации о продуктах для пользователей и других микросервисов, а также предоставляет инструменты для эффективного управления каталогом разработчиками, издателями и администраторами.

### 3.2 Основные цели

1.  **Единый источник правды**: Стать единственным достоверным источником информации обо всех продуктах, их ценах, метаданных, медиа и связях.
2.  **Полное управление жизненным циклом**: Поддерживать все этапы жизни продукта: от черновика и модерации до публикации, обновления, снятия с продажи и архивации.
3.  **Гибкое ценообразование**: Реализовать сложную логику управления ценами, включая региональные цены, различные типы скидок, акции и промокоды.
4.  **Эффективное обнаружение**: Предоставить пользователям мощные и быстрые инструменты поиска, фильтрации и навигации по каталогу.
5.  **Структуризация каталога**: Обеспечить богатую таксономию (жанры, теги, категории) и возможности организации продуктов (коллекции, франшизы).
6.  **Управление контентом**: Обеспечить хранение и управление метаданными медиа-контента и достижений.
7.  **Поддержка модерации**: Предоставить необходимые данные и статусы для процесса модерации контента.
8.  **Основа для рекомендаций**: Собирать и предоставлять данные для построения персонализированных и общих рекомендаций.
9.  **Надежность и производительность**: Обеспечить высокую доступность, низкую задержку ответов и горизонтальную масштабируемость сервиса.
10. **Безопасность**: Гарантировать безопасность хранимых данных и предоставляемых API.
11. **Интегрируемость**: Обеспечить четкие и стабильные интерфейсы (API и события) для взаимодействия с другими сервисами.

### 3.3 Функциональные требования

#### 3.3.1 Управление продуктами (CRUD)
- FR-CAT-001: Система должна позволять создавать новые продукты с указанием типа (Игра, DLC, ПО, Комплект).
- FR-CAT-002: Система должна позволять редактировать все метаданные существующего продукта.
- FR-CAT-003: Система должна поддерживать логическое удаление (архивацию) продуктов.
- FR-CAT-004: Система должна хранить и управлять связями между продуктами (например, DLC принадлежит Игре, Игра входит в Комплект).
- FR-CAT-005: Система должна поддерживать версионирование продуктов (для отслеживания изменений и связи с файлами в Download Service).
- FR-CAT-006: Система должна хранить информацию о разработчике(ах) и издателе продукта.
- FR-CAT-007: Система должна поддерживать управление статусами продукта (Draft, In Review, Upcoming, Released, Delisted, Archived).
- FR-CAT-008: Система должна хранить дату создания, последнего обновления и релиза продукта.

#### 3.3.2 Управление метаданными
- FR-CAT-010: Система должна хранить основное название продукта.
- FR-CAT-011: Система должна хранить подробное описание продукта (поддержка Markdown или другого форматирования).
- FR-CAT-012: Система должна хранить краткое описание продукта.
- FR-CAT-013: Система должна поддерживать локализацию названия и описаний как минимум на русский и английский языки.
- FR-CAT-014: Система должна хранить информацию о поддерживаемых языках интерфейса, озвучки и субтитров.
- FR-CAT-015: Система должна хранить системные требования для каждой поддерживаемой ОС (Windows, macOS, Linux), включая минимальные и рекомендуемые.
- FR-CAT-016: Система должна хранить возрастной рейтинг продукта (0+, 6+, 12+, 16+, 18+).
- FR-CAT-017: Система должна хранить ссылки на внешние ресурсы (сайт разработчика, сообщество, поддержка).
- FR-CAT-018: Система должна хранить информацию о правообладателе и юридическую информацию (EULA).

#### 3.3.3 Управление ценообразованием
- FR-CAT-020: Система должна позволять устанавливать базовую цену продукта в основной валюте (RUB).
- FR-CAT-021: Система должна позволять устанавливать региональные цены в различных валютах (USD, EUR и т.д.).
- FR-CAT-022: Система должна поддерживать установку цен для разных версий/изданий продукта (Standard, Deluxe).
- FR-CAT-023: Система должна позволять создавать и управлять скидками (процентными и фиксированными) с указанием периода действия.
- FR-CAT-024: Система должна позволять применять скидки к отдельным продуктам, комплектам или группам продуктов (по жанру, тегу, разработчику).
- FR-CAT-025: Система должна поддерживать создание и управление глобальными акциями (распродажами).
- FR-CAT-026: Система должна хранить историю изменения цен и скидок.
- FR-CAT-027: Система должна предоставлять API для получения актуальной цены продукта для пользователя с учетом региона и действующих скидок/акций.

#### 3.3.4 Управление таксономией
- FR-CAT-030: Система должна позволять управлять справочником жанров.
- FR-CAT-031: Система должна позволять управлять справочником системных тегов и категорий.
- FR-CAT-032: Система должна позволять присваивать продуктам один или несколько жанров.
- FR-CAT-033: Система должна позволять присваивать продуктам несколько тегов и категорий.
- FR-CAT-034: Система должна поддерживать пользовательские теги (с премодерацией).
- FR-CAT-035: Система должна позволять создавать и управлять франшизами/сериями и связывать с ними продукты.
- FR-CAT-036: Система должна позволять создавать и управлять курируемыми коллекциями продуктов.

#### 3.3.5 Поиск и фильтрация
- FR-CAT-040: Система должна обеспечивать полнотекстовый поиск по названию, описанию, разработчику, издателю.
- FR-CAT-041: Система должна поддерживать поиск с учетом морфологии русского и английского языков.
- FR-CAT-042: Система должна предоставлять фильтрацию продуктов по: жанру, тегу, категории, цене (диапазон), наличию скидки, дате выхода (диапазон), платформе ОС, поддерживаемым языкам, возрастному рейтингу, разработчику, издателю, статусу продукта.
- FR-CAT-043: Система должна предоставлять сортировку результатов поиска по: релевантности, популярности (требует данных из Analytics), дате выхода (новые/старые), названию (A-Z), цене (дешевые/дорогие), рейтингу (требует данных из Social/Analytics), размеру скидки.
- FR-CAT-044: Система должна поддерживать пагинацию результатов поиска и фильтрации.
- FR-CAT-045: Система должна предоставлять поисковые подсказки (suggestions) и автодополнение (autocomplete).
- FR-CAT-046: Поиск должен быть быстрым (см. Нефункциональные требования).

#### 3.3.6 Управление медиа-контентом
- FR-CAT-050: Система должна позволять привязывать к продукту скриншоты.
- FR-CAT-051: Система должна позволять привязывать к продукту трейлеры (ссылки на видеохостинги или загруженные файлы).
- FR-CAT-052: Система должна позволять привязывать к продукту арты и обложки разных размеров (для каталога, библиотеки, страницы продукта).
- FR-CAT-053: Система должна хранить метаданные для медиа-контента (тип, порядок отображения, описание/подпись).
- FR-CAT-054: Система должна предоставлять URL для доступа к медиа-контенту через CDN.
- FR-CAT-055: Система должна поддерживать загрузку медиа-контента через Developer Service или Admin Service.

#### 3.3.7 Управление достижениями
- FR-CAT-060: Система должна позволять создавать и управлять метаданными достижений для игр (ID, название, описание, иконка, условия получения, тип - обычное/скрытое).
- FR-CAT-061: Система должна связывать достижения с конкретной игрой.
- FR-CAT-062: Система должна предоставлять API для получения списка метаданных достижений для игры.

#### 3.3.8 Модерация
- FR-CAT-070: Система должна хранить статус модерации для продуктов и, возможно, для отдельных полей (описание, медиа).
- FR-CAT-071: Система должна предоставлять API для получения списка продуктов, ожидающих модерации.
- FR-CAT-072: Система должна позволять изменять статус модерации (Approved, Rejected) с указанием причины отклонения.
- FR-CAT-073: Система должна генерировать события при изменении статуса модерации.

#### 3.3.9 Рекомендации
- FR-CAT-080: Система должна предоставлять API для получения списка рекомендованных продуктов.
- FR-CAT-081: Система должна поддерживать различные типы рекомендаций: персонализированные (требуют user_id и данных из Analytics/Library), популярные, новые, похожие на указанный продукт, на основе кураторских подборок.
- FR-CAT-082: Система должна позволять настраивать алгоритмы рекомендаций (возможно, через Admin Service).

### 3.4 Нефункциональные требования

(Детализированы в разделах 8, 9, 10)

- NFR-CAT-001: **Производительность (Latency)**: P95 времени ответа для API чтения (поиск, детали продукта) < 150ms. P95 для API записи < 500ms.
- NFR-CAT-002: **Производительность (Throughput)**: Способность обрабатывать не менее 1000 запросов в секунду на чтение (пиковая нагрузка).
- NFR-CAT-003: **Масштабируемость**: Возможность горизонтального масштабирования для обработки растущей нагрузки.
- NFR-CAT-004: **Доступность**: Уровень доступности сервиса не менее 99.95%.
- NFR-CAT-005: **Надежность**: Отсутствие потери данных, устойчивость к сбоям отдельных компонентов.
- NFR-CAT-006: **Консистентность**: Обеспечение консистентности данных каталога (eventual consistency для реплик и кэшей, strong consistency для основных операций записи).
- NFR-CAT-007: **Безопасность**: Защита от распространенных веб-уязвимостей (OWASP Top 10), защита данных, безопасная аутентификация и авторизация.
- NFR-CAT-008: **Мониторинг**: Наличие исчерпывающих метрик, логов и трассировок для наблюдения за состоянием и производительностью сервиса.
- NFR-CAT-009: **Тестируемость**: Высокий уровень покрытия кода тестами (Unit > 80%, Integration).
- NFR-CAT-010: **Развертываемость**: Простота и автоматизация процесса развертывания и обновления сервиса.

## 4. Архитектура

### 4.1 Общая архитектура

Catalog Service реализуется как **независимый микросервис** в рамках общей архитектуры платформы. Внутренняя архитектура сервиса следует принципам **Чистой Архитектуры (Clean Architecture)**, дополненной элементами **CQRS (Command Query Responsibility Segregation)** для оптимизации операций чтения и записи.

**Ключевые принципы:**

1.  **Разделение ответственностей**: Четкое разделение на слои (Domain, Application, Infrastructure).
2.  **Независимость от фреймворков**: Доменный слой и слой приложения не зависят от конкретных библиотек баз данных, веб-фреймворков или брокеров сообщений.
3.  **Тестируемость**: Архитектура способствует написанию модульных и интеграционных тестов.
4.  **CQRS**: Логическое (и потенциально физическое) разделение моделей и путей обработки для команд (изменение состояния) и запросов (чтение состояния). Запросы могут использовать оптимизированные структуры данных (например, денормализованные данные в Elasticsearch или кэше), в то время как команды работают с основной моделью данных в PostgreSQL.

#### 4.1.1 Архитектурные слои (Детально)

1.  **Domain Layer (Внутренний слой)**:
    *   **Entities**: Основные бизнес-сущности с идентификаторами и изменяемым состоянием (Product, Genre, Tag, PriceRule, MediaItem, AchievementMeta). Содержат основную бизнес-логику и инварианты.
    *   **Value Objects**: Неизменяемые объекты, характеризующиеся своими атрибутами (Price, SystemRequirements, LocalizedString).
    *   **Aggregates**: Кластеры сущностей и объектов-значений, рассматриваемые как единое целое для обеспечения консистентности (например, Product Aggregate, включающий сам продукт, его цены, медиа, теги).
    *   **Domain Services**: Логика, не принадлежащая конкретной сущности, но оперирующая объектами домена.
    *   **Repository Interfaces**: Абстрактные интерфейсы для доступа к данным агрегатов (например, `ProductRepository`, `GenreRepository`).
2.  **Application Layer (Средний слой)**:
    *   **Use Cases / Application Services**: Реализуют сценарии использования системы. Оркеструют взаимодействие между репозиториями, доменными службами и другими компонентами. Содержат логику приложения, но не бизнес-логику.
    *   **Commands & Queries**: Объекты, представляющие команды на изменение состояния (например, `CreateProductCommand`) и запросы на получение данных (например, `GetProductByIDQuery`).
    *   **Command & Query Handlers**: Обработчики команд и запросов.
    *   **DTOs (Data Transfer Objects)**: Объекты для передачи данных между слоями и через границы сервиса (API). Не содержат логики.
    *   **Interfaces for Infrastructure**: Интерфейсы для внешних зависимостей (базы данных, кэши, брокеры сообщений, внешние API), которые реализуются в слое инфраструктуры.
3.  **Infrastructure Layer (Внешний слой)**:
    *   **Entrypoints / Transport Adapters**: Точки входа в сервис (REST контроллеры, gRPC серверы, обработчики сообщений Kafka).
    *   **Data Persistence Adapters**: Реализации интерфейсов репозиториев для конкретных хранилищ (PostgreSQL, Elasticsearch).
    *   **Cache Adapters**: Реализация интерфейса кэша (Redis).
    *   **Event Bus Adapters**: Реализация интерфейсов для публикации и подписки на события (Kafka).
    *   **External Service Clients**: Клиенты для взаимодействия с другими микросервисами (Auth, Library, Payment и т.д.) и внешними системами (CDN, S3).
    *   **Frameworks & Libraries**: Конкретные фреймворки и библиотеки (Echo, GORM, Zap, Viper, OpenTelemetry SDK и т.д.).
    *   **Configuration**: Загрузка и управление конфигурацией.
    *   **Logging, Metrics, Tracing**: Реализация механизмов телеметрии.

#### 4.1.2 Структура проекта (Go) - Детализированная

```
catalog-service/
├── api/                      # Контракты API
│   ├── grpc/                 # gRPC
│   │   └── proto/            # .proto файлы (версионированные, например, v1/catalog.proto)
│   │       └── v1/
│   │           └── catalog.proto
│   └── rest/                 # REST
│       └── openapi/          # OpenAPI v3 спецификации (openapi.yaml)
├── cmd/
│   └── server/
│       └── main.go           # Точка входа: инициализация логгера, конфига, DI-контейнера, запуск серверов (HTTP, gRPC)
├── configs/                  # Примеры конфигурационных файлов (config.example.yaml)
├── deployments/              # Файлы для развертывания
│   ├── docker/               # Dockerfile, docker-compose.yml (для локальной разработки)
│   └── kubernetes/           # Манифесты K8s (deployment.yaml, service.yaml, configmap.yaml, secret.yaml, hpa.yaml, etc.)
├── internal/
│   ├── app/                  # Слой приложения
│   │   ├── command/          # Команды и их обработчики (CQRS)
│   │   │   └── product_command.go
│   │   ├── query/            # Запросы и их обработчики (CQRS)
│   │   │   └── product_query.go
│   │   ├── service/          # Сервисы приложения (Use Cases)
│   │   │   └── catalog_service.go
│   │   └── interfaces/       # Интерфейсы, реализуемые инфраструктурой (Repositories, EventBus, etc.)
│   │       ├── product_repository.go
│   │       └── event_publisher.go
│   ├── domain/               # Доменный слой
│   │   ├── product/          # Агрегат Product
│   │   │   ├── product.go    # Сущность Product
│   │   │   ├── price.go      # Value Object Price
│   │   │   ├── media.go      # Сущность MediaItem
│   │   │   └── event.go      # Доменные события (ProductCreated, PriceUpdated)
│   │   ├── genre/            # Агрегат Genre
│   │   │   └── genre.go
│   │   ├── tag/              # Агрегат Tag
│   │   │   └── tag.go
│   │   └── shared/           # Общие доменные элементы (Value Objects, Domain Services)
│   │       └── localized_string.go
│   └── infrastructure/       # Слой инфраструктуры
│       ├── config/           # Загрузка конфигурации (Viper)
│       │   └── config.go
│       ├── database/         # Работа с БД
│       │   └── postgres/     # Реализация репозиториев для PostgreSQL (GORM/Squirrel)
│       │       ├── product_repository.go
│       │       └── db.go       # Управление подключением
│       ├── search/           # Работа с поисковым движком
│       │   └── elasticsearch/# Реализация поиска для Elasticsearch
│       │       └── product_search.go
│       ├── cache/            # Работа с кэшем
│       │   └── redis/        # Реализация кэша на Redis
│       │       └── product_cache.go
│       ├── cdn/              # Интеграция с CDN
│       │   └── cdn_client.go
│       ├── eventbus/         # Работа с шиной событий
│       │   └── kafka/        # Публикация/подписка на события Kafka
│       │       ├── publisher.go
│       │       └── consumer.go
│       ├── logging/          # Логирование (Zap)
│       │   └── logger.go
│       ├── metrics/          # Метрики (Prometheus)
│       │   └── metrics.go
│       ├── tracing/          # Трассировка (OpenTelemetry)
│       │   └── tracer.go
│       ├── transport/        # Транспортные адаптеры
│       │   ├── grpc/         # gRPC сервер и реализация сервисов
│       │   │   └── server.go
│       │   └── rest/         # REST сервер (Echo) и хендлеры
│       │       ├── server.go
│       │       └── handlers/
│       │           └── product_handler.go
│       └── clients/          # Клиенты для других микросервисов
│           ├── auth/
│           └── payment/
├── migrations/               # Миграции базы данных (golang-migrate)
│   └── postgres/
│       ├── 001_initial_schema.up.sql
│       └── 001_initial_schema.down.sql
├── pkg/                      # Общие пакеты (если есть код для внешнего использования или шаринга между internal)
│   ├── dtos/                 # Общие DTO (если используются в нескольких местах)
│   └── errorutils/           # Утилиты для работы с ошибками
├── test/                     # Тесты
│   ├── integration/          # Интеграционные тесты (с использованием testcontainers)
│   └── unit/                 # Модульные тесты
├── tools/                    # Вспомогательные инструменты (генераторы кода и т.д.)
├── go.mod
├── go.sum
└── README.md                 # Описание сервиса, инструкции по сборке и запуску
```

### 4.2 Компоненты системы (Логические)

Логически сервис можно разделить на следующие компоненты:

1.  **Product Core**: Управление основными сущностями Product, их жизненным циклом и метаданными.
2.  **Pricing Engine**: Управление ценами, скидками, акциями.
3.  **Taxonomy Manager**: Управление жанрами, тегами, категориями, коллекциями.
4.  **Media Manager**: Управление метаданными медиа-контента, генерация URL для CDN.
5.  **Achievement Metadata Store**: Хранение метаданных достижений.
6.  **Search & Discovery Service**: Обработка поисковых запросов, фильтрации, сортировки (взаимодействие с Elasticsearch).
7.  **Recommendation Provider**: Генерация и предоставление рекомендаций (может использовать данные из Analytics Service).
8.  **Moderation Support**: Предоставление данных и интерфейсов для поддержки процесса модерации.
9.  **API Layer (REST & gRPC)**: Предоставление внешних и внутренних интерфейсов.
10. **Event Publisher/Subscriber**: Взаимодействие с шиной событий.

### 4.3 Потоки данных (Data Flows) - Примеры

#### 4.3.1 Получение списка игр (Пользователь)

1.  **Frontend (Flutter)** -> **API Gateway (REST)**: `GET /api/v1/catalog/products?genre=action&sort_by=release_date&limit=20`
2.  **API Gateway** -> **Catalog Service (REST)**: `GET /products?genre=action&sort_by=release_date&limit=20` (добавляет `X-User-Id`, `X-User-Roles` если пользователь аутентифицирован)
3.  **Catalog Service (REST Handler)**: Валидирует запрос, извлекает параметры.
4.  **REST Handler** -> **Application Service (Query Handler)**: Вызывает `Handle(GetProductsQuery{...})`.
5.  **Query Handler** -> **Search Adapter (Elasticsearch)**: Формирует и выполняет поисковый запрос к Elasticsearch с фильтрами и сортировкой.
6.  **Elasticsearch** -> **Search Adapter**: Возвращает список ID продуктов и данные для сортировки.
7.  **Query Handler** -> **Product Repository (PostgreSQL/Cache)**: Запрашивает полные метаданные для найденных ID продуктов (сначала проверяет кэш Redis, затем идет в PostgreSQL).
8.  **PostgreSQL/Cache** -> **Product Repository**: Возвращает метаданные продуктов.
9.  **Query Handler** -> **Price Repository (PostgreSQL/Cache)**: Запрашивает актуальные цены для продуктов с учетом региона пользователя (если есть) и скидок.
10. **PostgreSQL/Cache** -> **Price Repository**: Возвращает цены.
11. **Query Handler**: Формирует DTO со списком продуктов и метаданными пагинации.
12. **Query Handler** -> **REST Handler**: Возвращает DTO.
13. **REST Handler**: Сериализует DTO в JSON и отправляет ответ `200 OK`.
14. **Catalog Service** -> **API Gateway**: Ответ.
15. **API Gateway** -> **Frontend**: Ответ.

#### 4.3.2 Добавление новой игры (Разработчик)

1.  **Developer Portal (Frontend)** -> **Developer Service (REST)**: `POST /api/v1/developer/products` с данными игры.
2.  **Developer Service**: Валидирует запрос, выполняет свою логику.
3.  **Developer Service** -> **Catalog Service (gRPC)**: Вызывает `rpc CreateProduct(CreateProductRequest{...})`.
4.  **Catalog Service (gRPC Handler)**: Валидирует запрос.
5.  **gRPC Handler** -> **Application Service (Command Handler)**: Вызывает `Handle(CreateProductCommand{...})`.
6.  **Command Handler**: 
    *   Начинает транзакцию в PostgreSQL.
    *   -> **Product Repository**: Сохраняет основную информацию о продукте.
    *   -> **Genre/Tag Repository**: Проверяет/создает жанры/теги и сохраняет связи.
    *   -> **Price Repository**: Сохраняет базовую цену.
    *   -> **Media Repository**: Сохраняет метаданные медиа.
    *   Устанавливает статус продукта `In Review`.
    *   Фиксирует транзакцию.
7.  **Command Handler** -> **Event Publisher (Kafka)**: Публикует событие `product.created` (или `product.submitted_for_review`).
8.  **Command Handler** -> **gRPC Handler**: Возвращает `CreateProductResponse` с ID созданного продукта.
9.  **Catalog Service** -> **Developer Service**: Ответ gRPC.
10. **Developer Service** -> **Developer Portal**: Ответ REST.

#### 4.3.3 Обновление цены продукта (Администратор/Акция)

1.  **Admin Panel / Scheduled Job** -> **Admin Service / Pricing Job**: Инициирует обновление цены.
2.  **Admin Service / Pricing Job** -> **Catalog Service (gRPC/REST)**: Вызывает `rpc UpdatePrice(UpdatePriceRequest{...})` или `POST /manage/products/{id}/prices`.
3.  **Catalog Service (Handler)**: Валидирует запрос.
4.  **Handler** -> **Application Service (Command Handler)**: Вызывает `Handle(UpdatePriceCommand{...})`.
5.  **Command Handler**: 
    *   -> **Price Repository (PostgreSQL)**: Обновляет цену в базе данных.
    *   -> **Cache Adapter (Redis)**: Инвалидирует или обновляет кэш цен для данного продукта.
6.  **Command Handler** -> **Event Publisher (Kafka)**: Публикует событие `price.updated` с деталями изменения.
7.  **Command Handler** -> **Handler**: Возвращает успешный ответ.
8.  **Catalog Service** -> **Admin Service / Pricing Job**: Ответ.

### 4.4 Технологический стек

- **Язык программирования**: Go (версия 1.21+)
- **Веб-фреймворк (REST)**: Echo (v4+)
- **RPC фреймворк (gRPC)**: `google.golang.org/grpc`
- **База данных**: PostgreSQL (версия 15+) с расширениями `uuid-ossp`, `pg_trgm`.
- **ORM/SQL Builder**: GORM (`gorm.io/gorm`) для простых CRUD и миграций (опционально), Squirrel (`github.com/Masterminds/squirrel`) для сложных запросов.
- **Миграции БД**: `github.com/golang-migrate/migrate`
- **Поисковый движок**: Elasticsearch (версия 8.x+)
- **Клиент Elasticsearch**: `github.com/elastic/go-elasticsearch/v8`
- **Кэширование**: Redis (версия 7.0+)
- **Клиент Redis**: `github.com/redis/go-redis/v9`
- **Брокер сообщений**: Apache Kafka (версия 3.x+)
- **Клиент Kafka**: `github.com/segmentio/kafka-go` или `github.com/confluentinc/confluent-kafka-go`
- **Контейнеризация**: Docker
- **Оркестрация**: Kubernetes (версия 1.25+)
- **Конфигурация**: Viper (`github.com/spf13/viper`)
- **Логирование**: Zap (`go.uber.org/zap`)
- **Мониторинг**: Prometheus (`github.com/prometheus/client_golang`), Grafana, Alertmanager.
- **Трассировка**: OpenTelemetry (`go.opentelemetry.io/otel`), Jaeger.
- **Валидация**: `github.com/go-playground/validator/v10`
- **DI Контейнер**: (Опционально) `go.uber.org/fx` или ручная инициализация зависимостей.

## 5. Бизнес-логика и сценарии использования

(Этот раздел будет содержать детальное описание ключевых бизнес-процессов и сценариев использования, например, "Публикация новой игры", "Проведение распродажи", "Модерация контента", "Поиск игры пользователем" с пошаговым описанием логики внутри Catalog Service)

*... (Раздел будет заполнен деталями) ...*

## 6. Структура данных и API

### 6.1 Модели данных (Go Структуры)

(Здесь будут представлены детальные Go структуры для всех сущностей, DTO, команд и запросов, с аннотациями GORM, JSON, и валидации. Пример из v2 будет расширен и дополнен)

```go
package product

import (
	"time"
	"github.com/google/uuid"
	"github.com/shopspring/decimal" // Используем decimal для цен
)

// --- Enums ---
type ProductType string
const (
	Game     ProductType = "game"
	DLC      ProductType = "dlc"
	Software ProductType = "software"
	Bundle   ProductType = "bundle"
)

type ModerationStatus string
const (
	Pending  ModerationStatus = "pending"
	Approved ModerationStatus = "approved"
	Rejected ModerationStatus = "rejected"
)

type ProductStatus string
const (
	StatusDraft     ProductStatus = "draft"
	StatusInReview  ProductStatus = "in_review"
	StatusUpcoming  ProductStatus = "upcoming"
	StatusReleased  ProductStatus = "released"
	StatusDelisted  ProductStatus = "delisted"
	StatusArchived  ProductStatus = "archived"
)

// --- Value Objects ---
type LocalizedString map[string]string // e.g., {"ru": "Название", "en": "Title"}

type SystemRequirements struct {
	OS        string `json:"os"`
	Processor string `json:"processor"`
	Memory    string `json:"memory"`
	Graphics  string `json:"graphics"`
	Storage   string `json:"storage"`
	Notes     string `json:"notes,omitempty"`
}

type PlatformRequirements struct {
	Windows *SystemRequirements `json:"windows,omitempty"`
	MacOS   *SystemRequirements `json:"macos,omitempty"`
	Linux   *SystemRequirements `json:"linux,omitempty"`
}

type PriceInfo struct {
	CurrencyCode string          `json:"currency_code"` // "RUB", "USD"
	Amount       decimal.Decimal `json:"amount"`
}

// --- Entities ---

// Product - Основная сущность продукта (Агрегат)
type Product struct {
	ID                 uuid.UUID            `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	Type               ProductType          `gorm:"type:varchar(50);not null;index" json:"type"`
	Status             ProductStatus        `gorm:"type:varchar(50);not null;default:'draft';index" json:"status"`
	Titles             LocalizedString      `gorm:"type:jsonb" json:"titles"`
	Descriptions       LocalizedString      `gorm:"type:jsonb" json:"descriptions"`
	ShortDescriptions  LocalizedString      `gorm:"type:jsonb" json:"short_descriptions,omitempty"`
	ReleaseDate        *time.Time           `gorm:"index" json:"release_date,omitempty"`
	DeveloperIDs       []uuid.UUID          `gorm:"type:uuid[];index:,type:gin" json:"developer_ids"` // Может быть несколько разработчиков
	PublisherID        uuid.UUID            `gorm:"type:uuid;index" json:"publisher_id"`
	Genres             []*Genre             `gorm:"many2many:product_genres;" json:"genres,omitempty"`
	Tags               []*Tag               `gorm:"many2many:product_tags;" json:"tags,omitempty"`
	Categories         []*Category          `gorm:"many2many:product_categories;" json:"categories,omitempty"`
	Media              []*MediaItem         `gorm:"foreignKey:ProductID" json:"media,omitempty"`
	Prices             []*ProductPrice      `gorm:"foreignKey:ProductID" json:"prices,omitempty"` // Региональные цены
	SystemRequirements PlatformRequirements `gorm:"type:jsonb" json:"system_requirements,omitempty"`
	SupportedLanguages LocalizedString      `gorm:"type:jsonb" json:"supported_languages,omitempty"` // {"interface": "ru,en", "audio": "ru", "subtitles": "ru,en,fr"}
	AgeRating          int                  `gorm:"default:0" json:"age_rating"` // 0, 6, 12, 16, 18
	AverageRating      float64              `gorm:"default:0.0" json:"average_rating"` // Агрегированный рейтинг
	ReviewCount        int                  `gorm:"default:0" json:"review_count"`   // Количество отзывов
	ModerationStatus   ModerationStatus     `gorm:"type:varchar(50);default:'pending';index" json:"moderation_status"`
	ModerationComment  string               `gorm:"type:text" json:"moderation_comment,omitempty"`
	IsVisible          bool                 `gorm:"default:false;index" json:"is_visible"` // Видимость в каталоге
	// --- Комплекты/DLC ---
	ParentProductID    *uuid.UUID           `gorm:"type:uuid;index" json:"parent_product_id,omitempty"` // Для DLC
	IncludedProductIDs []uuid.UUID          `gorm:"type:uuid[];index:,type:gin" json:"included_product_ids,omitempty"` // Для комплектов
	// --- Timestamps ---
	CreatedAt          time.Time            `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
	UpdatedAt          time.Time            `gorm:"default:CURRENT_TIMESTAMP" json:"updated_at"`
	PublishedAt        *time.Time           `gorm:"index" json:"published_at,omitempty"`
	DeletedAt          *time.Time           `gorm:"index" json:"-"` // Мягкое удаление
}

// Genre - Жанр
type Genre struct {
	ID       uuid.UUID       `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	Names    LocalizedString `gorm:"type:jsonb;uniqueIndex:idx_genre_names_unique" json:"names"`
	Slug     string          `gorm:"type:varchar(100);unique;not null" json:"slug"`
	Products []*Product      `gorm:"many2many:product_genres;" json:"-"`
}

// Tag - Тег
type Tag struct {
	ID       uuid.UUID       `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	Names    LocalizedString `gorm:"type:jsonb;uniqueIndex:idx_tag_names_unique" json:"names"`
	Slug     string          `gorm:"type:varchar(100);unique;not null" json:"slug"`
	IsSystem bool            `gorm:"default:true" json:"is_system"` // Системный или пользовательский
	Products []*Product      `gorm:"many2many:product_tags;" json:"-"`
}

// Category - Категория
type Category struct {
	ID       uuid.UUID       `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	Names    LocalizedString `gorm:"type:jsonb;uniqueIndex:idx_category_names_unique" json:"names"`
	Slug     string          `gorm:"type:varchar(100);unique;not null" json:"slug"`
	Products []*Product      `gorm:"many2many:product_categories;" json:"-"`
}

// MediaItem - Элемент медиа-контента
type MediaItem struct {
	ID          uuid.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	ProductID   uuid.UUID `gorm:"type:uuid;not null;index" json:"product_id"`
	Type        string    `gorm:"type:varchar(50);not null" json:"type"` // "screenshot", "trailer", "cover_small", "cover_large", "artwork"
	URL         string    `gorm:"type:text;not null" json:"url"` // URL на CDN
	ThumbnailURL string    `gorm:"type:text" json:"thumbnail_url,omitempty"`
	Order       int       `gorm:"default:0" json:"order"`
	Description LocalizedString `gorm:"type:jsonb" json:"description,omitempty"`
	CreatedAt   time.Time `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
}

// ProductPrice - Цена продукта (может быть несколько для разных регионов/валют)
type ProductPrice struct {
	ID           uuid.UUID       `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	ProductID    uuid.UUID       `gorm:"type:uuid;not null;index:idx_product_price_region,unique" json:"product_id"`
	RegionCode   string          `gorm:"type:varchar(10);not null;default:'DEFAULT';index:idx_product_price_region,unique" json:"region_code"` // "DEFAULT", "RU", "US", "EU"
	CurrencyCode string          `gorm:"type:varchar(3);not null" json:"currency_code"` // "RUB", "USD", "EUR"
	BaseAmount   decimal.Decimal `gorm:"type:decimal(12,2);not null" json:"base_amount"`
	// Поля для скидок могут быть здесь или в отдельной таблице/сервисе
	DiscountAmount *decimal.Decimal `gorm:"type:decimal(12,2)" json:"discount_amount,omitempty"`
	DiscountStart *time.Time        `json:"discount_start,omitempty"`
	DiscountEnd   *time.Time        `json:"discount_end,omitempty"`
	CreatedAt    time.Time         `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
	UpdatedAt    time.Time         `gorm:"default:CURRENT_TIMESTAMP" json:"updated_at"`
}

// AchievementMeta - Метаданные достижения
type AchievementMeta struct {
	ID             uuid.UUID       `gorm:"type:uuid;primary_key;default:uuid_generate_v4()" json:"id"`
	ProductID      uuid.UUID       `gorm:"type:uuid;not null;index" json:"product_id"`
	ApiName        string          `gorm:"type:varchar(100);not null;uniqueIndex:idx_ach_product_apiname" json:"api_name"` // Уникальный идентификатор для API игры
	Names          LocalizedString `gorm:"type:jsonb" json:"names"`
	Descriptions   LocalizedString `gorm:"type:jsonb" json:"descriptions"`
	IconURL        string          `gorm:"type:text" json:"icon_url"`
	IconGrayURL    string          `gorm:"type:text" json:"icon_gray_url,omitempty"` // Иконка для не полученного
	IsHidden       bool            `gorm:"default:false" json:"is_hidden"`
	DisplayOrder   int             `gorm:"default:0" json:"display_order"`
	GlobalProgress float64         `gorm:"default:0.0" json:"global_progress,omitempty"` // Процент игроков, получивших достижение
	CreatedAt      time.Time       `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
	UpdatedAt      time.Time       `gorm:"default:CURRENT_TIMESTAMP" json:"updated_at"`
}

// --- DTOs (Примеры) ---
type ProductListItemDTO struct {
	ID                uuid.UUID       `json:"id"`
	Type              ProductType     `json:"type"`
	Title             string          `json:"title"` // Локализованное
	ShortDescription  string          `json:"short_description,omitempty"` // Локализованное
	CoverImageURL     string          `json:"cover_image_url,omitempty"`
	ReleaseDate       *time.Time      `json:"release_date,omitempty"`
	DeveloperNames    []string        `json:"developer_names,omitempty"`
	PublisherName     string          `json:"publisher_name,omitempty"`
	Genres            []string        `json:"genres,omitempty"` // Локализованные
	Tags              []string        `json:"tags,omitempty"`   // Локализованные
	Price             *CurrentPriceDTO `json:"price,omitempty"` // Актуальная цена со скидкой
	AverageRating     float64         `json:"average_rating"`
	IsReleased        bool            `json:"is_released"`
}

type CurrentPriceDTO struct {
	CurrencyCode    string  `json:"currency_code"`
	FinalAmount     string  `json:"final_amount"` // Строка для точности
	BaseAmount      string  `json:"base_amount"`
	DiscountPercent int     `json:"discount_percent,omitempty"`
	IsDiscounted    bool    `json:"is_discounted"`
}

type ProductDetailsDTO struct {
	ID                 uuid.UUID            `json:"id"`
	Type               ProductType          `json:"type"`
	Status             ProductStatus        `json:"status"`
	Title              string               `json:"title"` // Локализованное
	Description        string               `json:"description"` // Локализованное
	ReleaseDate        *time.Time           `json:"release_date,omitempty"`
	Developers         []DeveloperInfoDTO   `json:"developers,omitempty"`
	Publisher          *PublisherInfoDTO    `json:"publisher,omitempty"`
	Genres             []GenreDTO           `json:"genres,omitempty"`
	Tags               []TagDTO             `json:"tags,omitempty"`
	Categories         []CategoryDTO        `json:"categories,omitempty"`
	Media              []MediaItemDTO       `json:"media,omitempty"`
	Price              *CurrentPriceDTO     `json:"price,omitempty"`
	SystemRequirements PlatformRequirements `json:"system_requirements,omitempty"`
	SupportedLanguages LocalizedString      `json:"supported_languages,omitempty"`
	AgeRating          int                  `json:"age_rating"`
	AverageRating      float64              `json:"average_rating"`
	ReviewCount        int                  `json:"review_count"`
	// ... другие поля ...
}

// ... другие DTO, команды, запросы ...
```

### 6.2 Схема базы данных PostgreSQL (DDL)

(Здесь будет представлена полная и актуальная DDL схема базы данных, созданная на основе Go структур и требований. Пример из v2 будет расширен и уточнен)

```sql
-- Расширения
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- Типы ENUM
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'product_type') THEN
        CREATE TYPE product_type AS ENUM ('game', 'dlc', 'software', 'bundle');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'moderation_status') THEN
        CREATE TYPE moderation_status AS ENUM ('pending', 'approved', 'rejected');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'product_status') THEN
        CREATE TYPE product_status AS ENUM ('draft', 'in_review', 'upcoming', 'released', 'delisted', 'archived');
    END IF;
END$$;

-- Таблица продуктов (products)
CREATE TABLE IF NOT EXISTS products (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    type product_type NOT NULL,
    status product_status NOT NULL DEFAULT 'draft',
    titles JSONB NOT NULL DEFAULT '{}'::jsonb,             -- {"ru": "Название", "en": "Title"}
    descriptions JSONB NOT NULL DEFAULT '{}'::jsonb,
    short_descriptions JSONB DEFAULT '{}'::jsonb,
    release_date TIMESTAMPTZ,
    developer_ids UUID[],                                  -- Массив ID разработчиков
    publisher_id UUID,                                     -- ID издателя (может быть FK на внешний сервис)
    system_requirements JSONB DEFAULT '{}'::jsonb,         -- {"windows": {...}, "macos": {...}, "linux": {...}}
    supported_languages JSONB DEFAULT '{}'::jsonb,         -- {"interface": "ru,en", "audio": "ru"}
    age_rating SMALLINT DEFAULT 0 CHECK (age_rating IN (0, 6, 12, 16, 18)),
    average_rating REAL DEFAULT 0.0,
    review_count INTEGER DEFAULT 0,
    moderation_status moderation_status DEFAULT 'pending',
    moderation_comment TEXT,
    is_visible BOOLEAN DEFAULT false,
    parent_product_id UUID REFERENCES products(id) ON DELETE SET NULL, -- Для DLC
    included_product_ids UUID[],                             -- Для комплектов
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    published_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ
);

-- Индексы для products
CREATE INDEX IF NOT EXISTS idx_products_status ON products (status);
CREATE INDEX IF NOT EXISTS idx_products_release_date ON products (release_date DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS idx_products_developer_ids ON products USING GIN (developer_ids);
CREATE INDEX IF NOT EXISTS idx_products_publisher_id ON products (publisher_id);
CREATE INDEX IF NOT EXISTS idx_products_moderation_status ON products (moderation_status);
CREATE INDEX IF NOT EXISTS idx_products_is_visible ON products (is_visible);
CREATE INDEX IF NOT EXISTS idx_products_parent_product_id ON products (parent_product_id);
CREATE INDEX IF NOT EXISTS idx_products_included_product_ids ON products USING GIN (included_product_ids);
CREATE INDEX IF NOT EXISTS idx_products_published_at ON products (published_at DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS idx_products_deleted_at ON products (deleted_at);
-- Индекс для полнотекстового поиска (пример для русского и английского)
CREATE INDEX IF NOT EXISTS idx_products_fts ON products USING GIN (
    to_tsvector('russian', coalesce(titles->>'ru', '')) ||
    to_tsvector('english', coalesce(titles->>'en', '')) ||
    to_tsvector('russian', coalesce(descriptions->>'ru', '')) ||
    to_tsvector('english', coalesce(descriptions->>'en', ''))
);

-- Таблица жанров (genres)
CREATE TABLE IF NOT EXISTS genres (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    names JSONB NOT NULL DEFAULT '{}'::jsonb,
    slug VARCHAR(100) UNIQUE NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS idx_genres_names_unique ON genres USING GIN (names);

-- Таблица тегов (tags)
CREATE TABLE IF NOT EXISTS tags (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    names JSONB NOT NULL DEFAULT '{}'::jsonb,
    slug VARCHAR(100) UNIQUE NOT NULL,
    is_system BOOLEAN DEFAULT true
);
CREATE UNIQUE INDEX IF NOT EXISTS idx_tags_names_unique ON tags USING GIN (names);

-- Таблица категорий (categories)
CREATE TABLE IF NOT EXISTS categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    names JSONB NOT NULL DEFAULT '{}'::jsonb,
    slug VARCHAR(100) UNIQUE NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS idx_categories_names_unique ON categories USING GIN (names);

-- Связующие таблицы M2M
CREATE TABLE IF NOT EXISTS product_genres (
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    genre_id UUID NOT NULL REFERENCES genres(id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, genre_id)
);
CREATE INDEX IF NOT EXISTS idx_product_genres_genre_id ON product_genres(genre_id);

CREATE TABLE IF NOT EXISTS product_tags (
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, tag_id)
);
CREATE INDEX IF NOT EXISTS idx_product_tags_tag_id ON product_tags(tag_id);

CREATE TABLE IF NOT EXISTS product_categories (
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, category_id)
);
CREATE INDEX IF NOT EXISTS idx_product_categories_category_id ON product_categories(category_id);

-- Таблица медиа-элементов (media_items)
CREATE TABLE IF NOT EXISTS media_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL, -- 'screenshot', 'trailer', 'cover_small', etc.
    url TEXT NOT NULL,
    thumbnail_url TEXT,
    item_order INTEGER DEFAULT 0,
    description JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS idx_media_items_product_id ON media_items (product_id, item_order);

-- Таблица цен продуктов (product_prices)
CREATE TABLE IF NOT EXISTS product_prices (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    region_code VARCHAR(10) NOT NULL DEFAULT 'DEFAULT', -- 'DEFAULT', 'RU', 'US', 'EU'
    currency_code VARCHAR(3) NOT NULL, -- 'RUB', 'USD', 'EUR'
    base_amount DECIMAL(12, 2) NOT NULL CHECK (base_amount >= 0),
    discount_amount DECIMAL(12, 2) CHECK (discount_amount >= 0),
    discount_start TIMESTAMPTZ,
    discount_end TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (product_id, region_code)
);
CREATE INDEX IF NOT EXISTS idx_product_prices_discount_end ON product_prices (discount_end);

-- Таблица метаданных достижений (achievement_metadata)
CREATE TABLE IF NOT EXISTS achievement_metadata (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    api_name VARCHAR(100) NOT NULL,
    names JSONB NOT NULL DEFAULT '{}'::jsonb,
    descriptions JSONB DEFAULT '{}'::jsonb,
    icon_url TEXT,
    icon_gray_url TEXT,
    is_hidden BOOLEAN DEFAULT false,
    display_order INTEGER DEFAULT 0,
    global_progress REAL DEFAULT 0.0 CHECK (global_progress >= 0 AND global_progress <= 100),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (product_id, api_name)
);
CREATE INDEX IF NOT EXISTS idx_achievement_metadata_product_id ON achievement_metadata (product_id, display_order);

-- ... другие таблицы, если необходимы (например, для разработчиков/издателей, если они управляются здесь) ...
```

### 6.3 Спецификация REST API

(Здесь будет представлена полная спецификация REST API в формате OpenAPI v3, включая все эндпоинты, параметры, тела запросов/ответов, коды ошибок. Пример из v2 будет расширен и детализирован)

**Основные принципы:**
- **Base URL**: `/api/v1/catalog` (устанавливается API Gateway)
- **Формат**: JSON (application/json)
- **Аутентификация**: JWT (проверяется API Gateway, информация о пользователе передается в заголовках `X-User-Id`, `X-User-Roles`, `X-User-Region`)
- **Авторизация**: RBAC на основе `X-User-Roles`.
- **Версионирование**: Через URL (`/v1/`).
- **Ошибки**: Стандартный формат (см. "Стандарты API...").
- **Пагинация**: `page` (default 1), `limit` (default 20, max 100).
- **Фильтрация/Сортировка**: Через query-параметры.
- **Именование**: snake_case для JSON и query params.
- **Даты**: ISO 8601 UTC (`YYYY-MM-DDTHH:mm:ssZ`).
- **Локализация**: Заголовок `Accept-Language` (например, `ru-RU, ru;q=0.9, en-US;q=0.8, en;q=0.7`) используется для выбора языка ответа в локализованных полях.

**Эндпоинты (Примеры):**

- **`GET /products`**: Получение списка продуктов.
  - **Query Params**: `page`, `limit`, `query` (поиск), `genre_slug`, `tag_slug`, `category_slug`, `developer_id`, `publisher_id`, `platform` (windows, macos, linux), `min_price`, `max_price`, `has_discount` (bool), `release_date_from`, `release_date_to`, `age_rating`, `sort_by` (release_date, price, rating, popularity, name), `sort_order` (asc, desc).
  - **Ответ**: `200 OK` (Список `ProductListItemDTO`, метаданные пагинации), `400 Bad Request`.
- **`GET /products/{product_id}`**: Получение деталей продукта.
  - **Ответ**: `200 OK` (`ProductDetailsDTO`), `404 Not Found`.
- **`GET /genres`**: Получение списка жанров.
- **`GET /tags`**: Получение списка тегов.
- **`GET /categories`**: Получение списка категорий.
- **`GET /products/{product_id}/achievements`**: Получение метаданных достижений.
- **`GET /recommendations`**: Получение рекомендаций.
  - **Query Params**: `type` (popular, new, personalized, similar_to={product_id}), `limit`.

- **`POST /manage/products`**: Создание продукта (Права: `admin`, `developer`, `publisher`).
- **`PUT /manage/products/{product_id}`**: Обновление продукта (Права: `admin`, `developer`¹, `publisher`¹).
- **`PATCH /manage/products/{product_id}/status`**: Изменение статуса продукта (Права: `admin`, `moderator`).
- **`POST /manage/products/{product_id}/prices`**: Добавление/обновление цены (Права: `admin`, `developer`¹, `publisher`¹).
- **`POST /manage/products/{product_id}/media`**: Добавление медиа (Права: `admin`, `developer`¹, `publisher`¹).
- **`POST /manage/products/{product_id}/achievements`**: Добавление/обновление достижений (Права: `admin`, `developer`¹, `publisher`¹).
- **`POST /manage/genres`**, **`PUT /manage/genres/{id}`**: Управление жанрами (Права: `admin`).
- **`POST /manage/tags`**, **`PUT /manage/tags/{id}`**: Управление тегами (Права: `admin`).

*(¹ - только для своих продуктов)*

*(Полная спецификация OpenAPI будет приложена отдельным файлом или встроена сюда)*

### 6.4 Спецификация gRPC API

(Здесь будет представлена полная спецификация gRPC API в формате Protobuf v3, включая все сервисы, методы, сообщения. Используется для внутреннего взаимодействия.)

**Основные принципы:**
- **Пакет**: `catalog.v1`
- **Аутентификация/Авторизация**: Через метаданные gRPC (передача JWT или внутренних токенов, ролей).
- **Ошибки**: Использование стандартных кодов ошибок gRPC (`google.rpc.Status`).
- **Именование**: CamelCase для полей Protobuf.

**Пример Protobuf (`catalog/v1/catalog.proto`):**

```protobuf
syntax = "proto3";

package catalog.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "google/rpc/status.proto";

option go_package = "github.com/yourorg/yourproject/gen/go/catalog/v1;catalogv1";

// Сервис для управления каталогом (внутренний)
service CatalogInternalService {
  // Получить детали продукта по ID (для других сервисов)
  rpc GetProductInternal(GetProductInternalRequest) returns (GetProductInternalResponse);
  // Получить список продуктов по ID (для других сервисов)
  rpc GetProductsInternal(GetProductsInternalRequest) returns (GetProductsInternalResponse);
  // Получить актуальную цену продукта (для Payment Service)
  rpc GetProductPrice(GetProductPriceRequest) returns (GetProductPriceResponse);
  // Создать продукт (вызывается Developer/Admin Service)
  rpc CreateProduct(CreateProductRequest) returns (CreateProductResponse);
  // Обновить продукт (вызывается Developer/Admin Service)
  rpc UpdateProduct(UpdateProductRequest) returns (UpdateProductResponse);
  // Получить метаданные достижений
  rpc GetAchievementMetadata(GetAchievementMetadataRequest) returns (GetAchievementMetadataResponse);
  // ... другие методы для управления ценами, медиа, таксономией ...
}

// --- Сообщения (Примеры) ---

message LocalizedString {
  map<string, string> values = 1; // {"ru": "Текст", "en": "Text"}
}

message ProductInternal {
  string id = 1; // UUID
  string type = 2; // "game", "dlc", etc.
  LocalizedString titles = 3;
  // ... другие поля, необходимые для внутреннего использования
  google.protobuf.Timestamp created_at = 50;
  google.protobuf.Timestamp updated_at = 51;
}

message GetProductInternalRequest {
  string product_id = 1; // UUID
  // Опционально: требуемые поля для оптимизации
  repeated string fields = 2;
}

message GetProductInternalResponse {
  ProductInternal product = 1;
}

message GetProductsInternalRequest {
  repeated string product_ids = 1; // UUIDs
  repeated string fields = 2;
}

message GetProductsInternalResponse {
  repeated ProductInternal products = 1;
}

message Price {
  string currency_code = 1; // "RUB", "USD"
  string amount = 2; // Используем строку для точности decimal
}

message GetProductPriceRequest {
  string product_id = 1; // UUID
  string region_code = 2; // "RU", "US", "DEFAULT"
  google.protobuf.StringValue user_id = 3; // Для возможных персональных скидок
}

message GetProductPriceResponse {
  string product_id = 1;
  Price base_price = 2;
  Price final_price = 3; // Цена с учетом скидок
  google.protobuf.Int32Value discount_percent = 4;
  bool is_discounted = 5;
}

message CreateProductRequest {
  // ... поля для создания продукта ...
  string request_id = 100; // Для идемпотентности
}

message CreateProductResponse {
  string product_id = 1; // UUID созданного продукта
}

// ... другие сообщения ...
```

### 6.5 Форматы событий (Kafka/CloudEvents)

(Здесь будет описан формат событий, публикуемых сервисом, с использованием спецификации CloudEvents.)

**Основные принципы:**
- **Брокер**: Kafka
- **Формат**: CloudEvents v1.0 (JSON encoding)
- **Топики**: Именование по шаблону `catalog.<entity>.<verb>` (например, `catalog.product.created`, `catalog.price.updated`).
- **Ключ сообщения (Key)**: Обычно ID сущности (например, `product_id`) для корректного партиционирования.

**Пример события `product.created`:**

```json
{
  "specversion": "1.0",
  "type": "com.yourplatform.catalog.product.created", // Тип события
  "source": "/service/catalog",                     // Источник события
  "subject": "product/a1b2c3d4-e5f6-7890-abcd-ef1234567890", // ID продукта
  "id": "unique-event-id-123",                      // Уникальный ID события
  "time": "2025-05-25T16:48:00Z",                   // Время события (UTC)
  "datacontenttype": "application/json",
  "data": {                                           // Полезная нагрузка
    "product_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "type": "game",
    "status": "in_review",
    "titles": {"ru": "Новая Игра", "en": "New Game"},
    "developer_ids": ["dev-uuid-1"],
    "publisher_id": "pub-uuid-1",
    "created_at": "2025-05-25T16:48:00Z"
    // ... другие важные поля ...
  }
}
```

**Список основных событий:**
- `catalog.product.created`
- `catalog.product.updated` (с указанием измененных полей)
- `catalog.product.status.changed`
- `catalog.product.visibility.changed`
- `catalog.product.deleted` (логическое удаление)
- `catalog.price.updated`
- `catalog.discount.started`
- `catalog.discount.ended`
- `catalog.genre.created` / `updated` / `deleted`
- `catalog.tag.created` / `updated` / `deleted`
- `catalog.achievement.metadata.updated`

## 7. Интеграции

(Детальное описание каждой интеграции: протокол, формат данных, ключевые API/события, цели взаимодействия)

### 7.1 Интеграция с API Gateway
- **Протокол**: REST (HTTPS)
- **Направление**: API Gateway -> Catalog Service
- **Цель**: Проксирование внешних запросов, добавление заголовков аутентификации/авторизации (`X-User-Id`, `X-User-Roles`, `X-User-Region`), возможное кэширование.

### 7.2 Интеграция с Developer Service
- **Протокол**: gRPC
- **Направление**: Developer Service -> Catalog Service
- **Цель**: Управление продуктами (CRUD), ценами, медиа, достижениями от имени разработчиков/издателей.
- **Ключевые API (Catalog Service)**: `CreateProduct`, `UpdateProduct`, `UpdatePrice`, `AddMedia`, `UpdateAchievementMetadata`.

### 7.3 Интеграция с Admin Service
- **Протокол**: gRPC или REST (управляющий API)
- **Направление**: Admin Service -> Catalog Service
- **Цель**: Модерация контента, управление глобальными настройками каталога (жанры, теги), управление продуктами/ценами с правами администратора.
- **Ключевые API (Catalog Service)**: `UpdateProductStatus`, `ManageGenres`, `ManageTags`, `CreateProduct`, `UpdatePrice` (с флагом admin).

### 7.4 Интеграция с Payment Service
- **Протокол**: gRPC
- **Направление**: Payment Service -> Catalog Service
- **Цель**: Получение актуальной цены продукта для конкретного пользователя/региона перед созданием заказа.
- **Ключевые API (Catalog Service)**: `GetProductPrice`.
- **Протокол**: Kafka (CloudEvents)
- **Направление**: Catalog Service -> Payment Service (и другие)
- **Цель**: Уведомление об изменении цен/скидок.
- **Ключевые События**: `catalog.price.updated`, `catalog.discount.started`, `catalog.discount.ended`.

### 7.5 Интеграция с Library Service
- **Протокол**: gRPC
- **Направление**: Library Service -> Catalog Service
- **Цель**: Получение метаданных продуктов для отображения в библиотеке/списке желаемого; получение метаданных достижений.
- **Ключевые API (Catalog Service)**: `GetProductsInternal`, `GetAchievementMetadata`.

### 7.6 Интеграция с Download Service
- **Протокол**: gRPC
- **Направление**: Download Service -> Catalog Service
- **Цель**: Получение метаданных продукта и информации о версиях/файлах для организации загрузки.
- **Ключевые API (Catalog Service)**: `GetProductInternal`, (возможно, отдельный `GetProductVersions`).

### 7.7 Интеграция с Analytics Service
- **Протокол**: Kafka (CloudEvents)
- **Направление**: Catalog Service -> Analytics Service
- **Цель**: Отправка событий об изменениях в каталоге для сбора статистики.
- **Ключевые События**: Все события `catalog.*`.
- **Протокол**: gRPC или REST
- **Направление**: Catalog Service -> Analytics Service (опционально)
- **Цель**: Получение данных для построения рекомендаций (например, популярные товары, пользовательские векторы).

### 7.8 Интеграция с Notification Service
- **Протокол**: Kafka (CloudEvents)
- **Направление**: Catalog Service -> Notification Service
- **Цель**: Инициирование уведомлений пользователям (например, о выходе игры из списка желаемого, старте скидки).
- **Ключевые События**: `catalog.product.released`, `catalog.discount.started` (с фильтрацией по подписчикам).

### 7.9 Интеграция с Auth Service
- **Протокол**: gRPC
- **Направление**: Catalog Service -> Auth Service
- **Цель**: Валидация JWT токенов и проверка прав доступа для защищенных API (если это не делегировано полностью API Gateway).
- **Ключевые API (Auth Service)**: `ValidateToken`, `CheckPermissions`.

### 7.10 Интеграция с CDN
- **Протокол**: HTTPS
- **Направление**: Catalog Service -> CDN (для загрузки), Пользователь/Frontend -> CDN (для скачивания)
- **Цель**: Хранение и быстрая доставка медиа-контента.
- **Взаимодействие**: Catalog Service хранит URL медиа-файлов на CDN. Может использовать API CDN для инвалидации кэша.

### 7.11 Интеграция с S3-совместимым хранилищем
- **Протокол**: S3 API (HTTPS)
- **Направление**: Catalog Service (или отдельный сервис загрузки медиа) -> S3
- **Цель**: Первичное хранение медиа-файлов перед их попаданием на CDN.


## 8. Мониторинг, Логирование и Трассировка

Этот раздел детализирует подходы к мониторингу, логированию и трассировке для обеспечения наблюдаемости (observability) микросервиса Catalog Service.

### 8.1 Мониторинг

Мониторинг осуществляется с использованием стека Prometheus, Grafana и Alertmanager.

#### 8.1.1 Ключевые метрики (Prometheus)

Сервис должен предоставлять метрики в формате Prometheus через эндпоинт `/metrics`. Основные группы метрик:

1.  **Метрики запросов (gRPC и HTTP):**
    *   `grpc_server_handling_seconds_bucket`: Гистограмма времени обработки gRPC запросов.
    *   `grpc_server_handled_total`: Счетчик обработанных gRPC запросов с метками `grpc_service`, `grpc_method`, `grpc_code`.
    *   `http_request_duration_seconds_bucket`: Гистограмма времени обработки HTTP запросов (если используется REST API).
    *   `http_requests_total`: Счетчик обработанных HTTP запросов с метками `code`, `method`, `handler`.

2.  **Метрики производительности Go:**
    *   `go_goroutines`: Количество активных горутин.
    *   `go_memstats_alloc_bytes`: Объем выделенной памяти.
    *   `go_gc_duration_seconds`: Гистограмма времени выполнения сборки мусора.
    *   `process_cpu_seconds_total`: Общее время CPU, использованное процессом.
    *   `process_resident_memory_bytes`: Объем используемой физической памяти.

3.  **Метрики базы данных (PostgreSQL):**
    *   `db_query_duration_seconds_bucket`: Гистограмма времени выполнения SQL-запросов с меткой `query_name`.
    *   `db_query_errors_total`: Счетчик ошибок выполнения SQL-запросов с меткой `query_name`.
    *   `sql_pool_open_connections`: Количество открытых соединений в пуле.
    *   `sql_pool_in_use_connections`: Количество используемых соединений.
    *   `sql_pool_wait_duration_seconds_bucket`: Гистограмма времени ожидания соединения из пула.

4.  **Метрики кэша (Redis):**
    *   `cache_hits_total`: Счетчик попаданий в кэш с меткой `cache_name`.
    *   `cache_misses_total`: Счетчик промахов кэша с меткой `cache_name`.
    *   `cache_operation_duration_seconds_bucket`: Гистограмма времени выполнения операций с кэшем (GET, SET, DELETE) с меткой `operation`.
    *   `cache_errors_total`: Счетчик ошибок при работе с кэшем.

5.  **Метрики брокера сообщений (Kafka):**
    *   `kafka_messages_produced_total`: Счетчик отправленных сообщений с меткой `topic`.
    *   `kafka_messages_produce_errors_total`: Счетчик ошибок при отправке сообщений с меткой `topic`.
    *   `kafka_producer_request_latency_seconds_bucket`: Гистограмма задержки отправки сообщений.

6.  **Метрики поискового движка (Elasticsearch):**
    *   `elasticsearch_query_duration_seconds_bucket`: Гистограмма времени выполнения запросов к Elasticsearch с меткой `query_type`.
    *   `elasticsearch_query_errors_total`: Счетчик ошибок при выполнении запросов к Elasticsearch.
    *   `elasticsearch_bulk_index_duration_seconds_bucket`: Гистограмма времени выполнения операций массового индексирования.

7.  **Бизнес-метрики:**
    *   `catalog_products_total`: Общее количество продуктов в каталоге по статусам.
    *   `catalog_moderation_queue_size`: Размер очереди на модерацию.
    *   `catalog_promotions_active_total`: Количество активных акций.

#### 8.1.2 Дашборды (Grafana)

Необходимо создать дашборды в Grafana для визуализации ключевых метрик. Пример структуры дашборда:

*   **Обзор сервиса:**
    *   Статус доступности (Up/Down)
    *   Количество реплик
    *   Версия развертывания
    *   Ключевые SLO (Latency, Availability)
*   **Производительность запросов:**
    *   P99, P95, P50 Latency (gRPC/HTTP)
    *   Request Rate (RPS)
    *   Error Rate (%)
    *   Разбивка по методам/эндпоинтам
*   **Ресурсы:**
    *   CPU Usage
    *   Memory Usage
    *   Goroutines
    *   GC Performance
*   **База данных:**
    *   Query Latency (P95)
    *   Query Rate
    *   Error Rate
    *   Connection Pool Usage
*   **Кэш:**
    *   Hit Rate (%)
    *   Operation Latency (P95)
    *   Error Rate
*   **Kafka:**
    *   Produce Rate
    *   Produce Error Rate
    *   Produce Latency
*   **Elasticsearch:**
    *   Query Latency (P95)
    *   Query Rate
    *   Error Rate
*   **Бизнес-метрики:**
    *   Количество продуктов по статусам
    *   Очередь модерации
    *   Активные акции

#### 8.1.3 Алертинг (Alertmanager)

Настроить правила алертинга в Prometheus для критических ситуаций. Примеры правил:

*   **Высокая задержка запросов:**
    ```yaml
    - alert: HighRequestLatencyP95
      expr: histogram_quantile(0.95, sum(rate(grpc_server_handling_seconds_bucket[5m])) by (le, grpc_method)) > 0.5 # 500ms
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High gRPC request latency on {{$labels.grpc_method}}"
        description: "P95 latency for {{$labels.grpc_method}} is above 500ms for the last 5 minutes."
    ```
*   **Высокий уровень ошибок:**
    ```yaml
    - alert: HighRequestErrorRate
      expr: sum(rate(grpc_server_handled_total{grpc_code!="OK"}[5m])) by (grpc_service) / sum(rate(grpc_server_handled_total[5m])) by (grpc_service) > 0.05 # 5%
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "High gRPC error rate on {{$labels.grpc_service}}"
        description: "More than 5% of requests to {{$labels.grpc_service}} are failing for the last 5 minutes."
    ```
*   **Сервис недоступен:**
    ```yaml
    - alert: ServiceDown
      expr: up{job="catalog-service"} == 0
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "Catalog Service is down"
        description: "Prometheus could not scrape the catalog-service job for the last 2 minutes."
    ```
*   **Высокая задержка запросов к БД:**
    ```yaml
    - alert: HighDBQueryLatency
      expr: histogram_quantile(0.95, sum(rate(db_query_duration_seconds_bucket[5m])) by (le, query_name)) > 0.2 # 200ms
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "High DB query latency for {{$labels.query_name}}"
        description: "P95 latency for DB query {{$labels.query_name}} is above 200ms for the last 10 minutes."
    ```
*   **Низкий Cache Hit Rate:**
    ```yaml
    - alert: LowCacheHitRate
      expr: sum(rate(cache_hits_total[5m])) by (cache_name) / (sum(rate(cache_hits_total[5m])) by (cache_name) + sum(rate(cache_misses_total[5m])) by (cache_name)) < 0.8 # 80%
      for: 15m
      labels:
        severity: info
      annotations:
        summary: "Low cache hit rate for {{$labels.cache_name}}"
        description: "Cache hit rate for {{$labels.cache_name}} is below 80% for the last 15 minutes."
    ```

### 8.2 Логирование

Логирование используется для записи событий, происходящих в сервисе, для отладки и анализа.

#### 8.2.1 Формат логов

Использовать **структурированное логирование** в формате **JSON**. Каждая запись лога должна содержать как минимум следующие поля:

*   `timestamp`: Время события (ISO 8601, UTC)
*   `level`: Уровень логирования (`debug`, `info`, `warn`, `error`, `fatal`)
*   `service`: Имя сервиса (`catalog-service`)
*   `version`: Версия сервиса
*   `trace_id`: ID трассировки (если есть)
*   `span_id`: ID спана (если есть)
*   `message`: Основное сообщение лога
*   `caller`: Имя файла и номер строки, где был вызван логгер (для `debug`, `error`, `fatal`)
*   **Контекстные поля**: Дополнительная информация, релевантная событию (например, `user_id`, `product_id`, `request_id`, `duration_ms`, `error_details`, `query`, `status_code`).

**Пример записи лога (уровень INFO):**
```json
{
  "timestamp": "2025-05-25T19:30:00.123Z",
  "level": "info",
  "service": "catalog-service",
  "version": "1.2.0",
  "trace_id": "a1b2c3d4e5f6",
  "span_id": "f6e5d4c3b2a1",
  "message": "gRPC request processed",
  "grpc_method": "/catalog.v1.CatalogService/GetProduct",
  "peer_address": "10.0.1.5:56789",
  "user_agent": "grpc-go/1.50.0",
  "status_code": "OK",
  "duration_ms": 55
}
```

**Пример записи лога (уровень ERROR):**
```json
{
  "timestamp": "2025-05-25T19:31:15.456Z",
  "level": "error",
  "service": "catalog-service",
  "version": "1.2.0",
  "trace_id": "a1b2c3d4e5f6",
  "span_id": "a9b8c7d6e5f4",
  "caller": "internal/repository/product_repo.go:152",
  "message": "Failed to execute database query",
  "error": "context deadline exceeded",
  "query_name": "GetProductByID",
  "product_id": "uuid-1234-abcd",
  "stack_trace": "... (полный stack trace) ..."
}
```

#### 8.2.2 Уровни логирования

*   **DEBUG**: Детальная информация для отладки (например, вход/выход из функции, значения переменных). **Не использовать в production.**
*   **INFO**: Информация о нормальном ходе выполнения (например, обработка запроса, запуск/остановка сервиса, успешное выполнение операции).
*   **WARN**: Предупреждения о потенциальных проблемах, которые не привели к ошибке, но требуют внимания (например, использование deprecated API, медленный ответ от зависимости, приближение к лимитам).
*   **ERROR**: Ошибки, которые помешали выполнению конкретной операции, но сервис продолжает работать (например, ошибка БД, ошибка при вызове другого сервиса, невалидные входные данные).
*   **FATAL**: Критические ошибки, после которых сервис не может продолжать работу и должен завершиться (например, невозможность подключиться к БД при старте).

Уровень логирования должен быть настраиваемым через конфигурацию (по умолчанию `INFO` для production).

#### 8.2.3 Сбор и хранение логов

Логи должны выводиться в `stdout`/`stderr` контейнера. Система оркестрации (Kubernetes) должна собирать эти логи с помощью агента (например, Fluentd, Promtail) и отправлять в централизованную систему хранения и анализа логов (например, Elasticsearch/Kibana, Loki/Grafana).

### 8.3 Трассировка

Распределенная трассировка используется для отслеживания пути запроса через несколько микросервисов.

#### 8.3.1 Инструментация

Использовать **OpenTelemetry** (`go.opentelemetry.io/otel`) для инструментации кода.

*   **Автоматическая инструментация**: Использовать готовые OTel-инструментации для gRPC, HTTP-клиентов/серверов, библиотек для работы с БД (например, `otelgorm`, `otelsql`).
*   **Ручная инструментация**: Создавать спаны вручную для важных бизнес-операций или участков кода, не покрытых автоматической инструментацией.

#### 8.3.2 Создание спанов

Ключевые спаны, которые должны создаваться:

*   Входящий gRPC/HTTP запрос (корневой спан для обработки запроса).
*   Вызов метода репозитория (работа с БД).
*   Операция с кэшем (GET/SET/DELETE).
*   Отправка сообщения в Kafka.
*   Запрос к Elasticsearch.
*   Исходящий gRPC/HTTP вызов к другому микросервису.
*   Выполнение значимых этапов бизнес-логики (например, "ValidateProductData", "ApplyDiscounts", "CheckModerationRules").

Каждый спан должен содержать релевантные атрибуты (теги), например:

*   `db.system`, `db.statement`, `db.operation`
*   `cache.operation`, `cache.key`, `cache.hit`
*   `messaging.system`, `messaging.destination`, `messaging.message_id`
*   `elasticsearch.operation`, `elasticsearch.query`
*   `http.method`, `http.url`, `http.status_code`
*   `rpc.system`, `rpc.service`, `rpc.method`
*   Бизнес-атрибуты: `product.id`, `user.id`, `promotion.id`

#### 8.3.3 Контекст трассировки

Контекст трассировки (trace ID, span ID) должен автоматически **пропагироваться** между сервисами через заголовки gRPC метаданных или HTTP заголовки (стандарт W3C Trace Context).

#### 8.3.4 Сбор и хранение трасс

OTel SDK должен быть настроен для экспорта трасс в коллектор OpenTelemetry Collector, который затем отправляет их в бэкенд для хранения и визуализации (например, Jaeger, Tempo).

## 9. SLO и SLI

Service Level Objectives (SLO) определяют целевой уровень надежности сервиса. Service Level Indicators (SLI) — это метрики, используемые для измерения соответствия SLO.

### 9.1 Ключевые SLI

1.  **Доступность (Availability):**
    *   **SLI**: Доля успешных запросов к критическим gRPC методам (`GetProduct`, `SearchProducts`, `GetProductInternal`) за определенный период времени (например, 5 минут).
    *   **Измерение**: `sum(rate(grpc_server_handled_total{grpc_method=~"GetProduct|SearchProducts|GetProductInternal", grpc_code="OK"}[5m])) / sum(rate(grpc_server_handled_total{grpc_method=~"GetProduct|SearchProducts|GetProductInternal"}[5m]))`

2.  **Задержка (Latency) - Чтение:**
    *   **SLI**: Процентиль (P95) времени обработки запросов к критическим gRPC методам чтения (`GetProduct`, `SearchProducts`).
    *   **Измерение**: `histogram_quantile(0.95, sum(rate(grpc_server_handling_seconds_bucket{grpc_method=~"GetProduct|SearchProducts"}[5m])) by (le))`

3.  **Задержка (Latency) - Запись:**
    *   **SLI**: Процентиль (P95) времени обработки запросов к критическим gRPC методам записи (`CreateProduct`, `UpdateProduct`, `UpdateProductPrices`, `AddMedia`).
    *   **Измерение**: `histogram_quantile(0.95, sum(rate(grpc_server_handling_seconds_bucket{grpc_method=~"CreateProduct|UpdateProduct|..."}[5m])) by (le))`

### 9.2 Целевые SLO

*   **Доступность**: **99.95%** за последние 28 дней.
*   **Задержка (Чтение)**: **P95 < 150ms** за последние 28 дней.
*   **Задержка (Запись)**: **P95 < 500ms** за последние 28 дней.

Эти SLO должны отслеживаться с помощью Grafana и использоваться для настройки алертов при нарушении бюджета ошибок (Error Budget).

## 10. Развертывание и эксплуатация

### 10.1 Сборка и Контейнеризация

#### 10.1.1 Dockerfile

Использовать многостадийную сборку для минимизации размера образа и повышения безопасности.

```dockerfile
# --- Build Stage ---
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Копируем зависимости
COPY go.mod go.sum ./
RUN go mod download

# Копируем исходный код
COPY . .

# Собираем статически скомпилированный бинарник
# CGO_ENABLED=0 отключает Cgo
# -ldflags="-w -s" удаляет отладочную информацию и символы
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /catalog-service ./cmd/catalog-service

# --- Runtime Stage ---
FROM alpine:latest

WORKDIR /app

# Копируем бинарник из стадии сборки
COPY --from=builder /catalog-service .

# Копируем конфигурационные файлы (если они не монтируются)
# COPY config/config.yaml .

# Указываем пользователя без root прав
# RUN addgroup -S appgroup && adduser -S appuser -G appgroup
# USER appuser

# Открываем порт gRPC
EXPOSE 8080
# Открываем порт метрик
EXPOSE 9090

# Запускаем сервис
ENTRYPOINT ["/app/catalog-service"]
# CMD ["-config", "/app/config.yaml"] # Пример передачи конфига
```

#### 10.1.2 Образ контейнера

Образы должны тегироваться версией приложения (например, `your-registry/catalog-service:v1.2.3`) и храниться в приватном реестре контейнеров.

### 10.2 Развертывание в Kubernetes

Использовать Kubernetes для оркестрации контейнеров.

#### 10.2.1 Deployment Manifest

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: catalog-service
  namespace: production
  labels:
    app: catalog-service
spec:
  replicas: 3 # Начальное количество реплик
  selector:
    matchLabels:
      app: catalog-service
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1 # Макс. недоступных подов во время обновления
      maxSurge: 1       # Макс. подов сверх желаемого количества
  template:
    metadata:
      labels:
        app: catalog-service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: catalog-service
        image: your-registry/catalog-service:v1.2.3 # Заменить на актуальную версию
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080 # gRPC
          name: grpc
        - containerPort: 9090 # Metrics
          name: metrics
        env:
        - name: CONFIG_PATH
          value: "/etc/config/config.yaml"
        # Добавить другие переменные окружения (DB_HOST, KAFKA_BROKERS и т.д.)
        # или использовать ConfigMap/Secrets
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
        resources:
          requests:
            cpu: "200m"
            memory: "256Mi"
          limits:
            cpu: "1000m"
            memory: "512Mi"
        livenessProbe:
          grpc:
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 10
        readinessProbe:
          grpc:
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: config-volume
        configMap:
          name: catalog-service-config
```

#### 10.2.2 Service Manifest

```yaml
apiVersion: v1
kind: Service
metadata:
  name: catalog-service
  namespace: production
  labels:
    app: catalog-service
spec:
  selector:
    app: catalog-service
  ports:
  - name: grpc
    port: 8080
    targetPort: 8080
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP
  type: ClusterIP # Внутренний сервис
```

#### 10.2.3 ConfigMap и Secrets

Конфигурация (адреса БД, Kafka, Redis, ключи API и т.д.) должна управляться через Kubernetes ConfigMaps и Secrets, а не зашиваться в образ.

#### 10.2.4 Horizontal Pod Autoscaler (HPA)

Настроить HPA для автоматического масштабирования количества реплик на основе метрик (например, CPU utilization или RPS).

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: catalog-service-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: catalog-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70 # Целевое использование CPU 70%
  # Можно добавить метрики на основе RPS, если используется KEDA или custom metrics
```

### 10.3 CI/CD

Процесс непрерывной интеграции и доставки должен включать:

1.  **Сборка**: Компиляция кода, запуск статических анализаторов (`go vet`, `staticcheck`).
2.  **Тестирование**: Запуск Unit и Integration тестов. Расчет покрытия кода.
3.  **Сборка образа**: Сборка Docker-образа и загрузка в реестр.
4.  **Развертывание (Staging)**: Развертывание новой версии в тестовом/staging окружении.
5.  **Автоматические тесты (Staging)**: Запуск E2E тестов в staging окружении.
6.  **Развертывание (Production)**: Развертывание новой версии в production с использованием стратегии Rolling Update, Canary или Blue/Green.

### 10.4 Операционные процедуры

#### 10.4.1 Масштабирование

*   **Автоматическое**: HPA управляет количеством реплик на основе нагрузки.
*   **Ручное**: При необходимости можно изменить `spec.replicas` в Deployment манифесте и применить (`kubectl apply -f deployment.yaml`).

#### 10.4.2 Обновление / Откат

*   **Обновление**: Изменить `spec.template.spec.containers[0].image` в Deployment манифесте на новую версию и применить. Kubernetes выполнит Rolling Update.
*   **Откат**: Использовать `kubectl rollout undo deployment/catalog-service` для отката к предыдущей версии. `kubectl rollout history deployment/catalog-service` для просмотра истории.

#### 10.4.3 Миграции БД

*   Использовать инструмент для миграций (например, `golang-migrate`, `goose`).

*   Миграции должны быть идемпотентными и обратно совместимыми (по возможности).
*   Запускать миграции как отдельный Job в Kubernetes перед развертыванием новой версии приложения, которая требует изменений схемы.
*   Иметь план отката миграции.

#### 10.4.4 Переиндексация Elasticsearch

*   При изменении маппинга или необходимости полной переиндексации:
    1.  Создать новый индекс с обновленным маппингом.
    2.  Использовать Elasticsearch Reindex API для копирования данных из старого индекса в новый.
    3.  Переключить алиас, используемый приложением, на новый индекс.
    4.  Удалить старый индекс.
*   Этот процесс можно автоматизировать скриптом или Kubernetes Job.

#### 10.4.5 Траблшутинг

*   **Высокая задержка**: Проверить дашборды Grafana (Latency, Resource Usage, DB Latency, Cache Latency). Использовать Jaeger/Tempo для анализа медленных трасс. Проверить логи на наличие ошибок или медленных операций.
*   **Высокий уровень ошибок**: Проверить дашборды Grafana (Error Rate). Проанализировать логи на наличие сообщений об ошибках и stack trace. Проверить статус зависимостей (БД, Kafka, Redis, другие сервисы).
*   **Поды падают / OOMKilled**: Проверить логи пода (`kubectl logs <pod-name>`). Проверить события Kubernetes (`kubectl describe pod <pod-name>`). Проанализировать метрики использования ресурсов (Memory Usage). Возможно, требуется увеличить лимиты памяти или найти утечку памяти.

#### 10.4.6 Резервное копирование и восстановление

*   **База данных (PostgreSQL)**: Настроить регулярное резервное копирование (например, с помощью `pg_dump` или облачных инструментов). Протестировать процедуру восстановления из бэкапа.
*   **Elasticsearch**: Настроить создание снапшотов индекса и их хранение во внешнем хранилище (S3).
*   **Конфигурация (K8s)**: Хранить манифесты Kubernetes в системе контроля версий (GitOps).

## 11. Безопасность

## 11. Безопасность

### 11.1 Модель угроз

Catalog Service обрабатывает и хранит важные бизнес-данные, включая информацию о продуктах, ценах и акциях. Основные угрозы:

1. **Несанкционированный доступ к API**: Попытки вызова API без необходимых прав.
2. **Инъекции (SQL, NoSQL, Elasticsearch)**: Попытки внедрения вредоносного кода через входные данные.
3. **Раскрытие чувствительных данных**: Утечка информации о неопубликованных продуктах, ценах или акциях.
4. **Отказ в обслуживании (DoS)**: Перегрузка сервиса большим количеством запросов.
5. **Подделка межсервисных запросов (SSRF)**: Атаки на внутренние сервисы через подделку запросов.
6. **Нарушение целостности данных**: Несанкционированное изменение данных о продуктах или ценах.

### 11.2 Аутентификация и авторизация

#### 11.2.1 Аутентификация

Catalog Service не выполняет аутентификацию пользователей напрямую, а полагается на API Gateway и Auth Service:

1. **Внешние запросы (от пользователей)**:
   - API Gateway проверяет JWT-токен в заголовке `Authorization`.
   - API Gateway добавляет заголовки `X-User-Id`, `X-User-Roles` и `X-Request-Id` к запросу перед проксированием к Catalog Service.
   - Catalog Service доверяет этим заголовкам, так как они приходят из доверенного источника (API Gateway).

2. **Межсервисные запросы (gRPC)**:
   - Использование взаимной TLS (mTLS) для аутентификации сервисов.
   - Каждый сервис имеет свой сертификат, выданный внутренним CA.
   - Дополнительно, использование API-ключей в метаданных gRPC для идентификации вызывающего сервиса.

#### 11.2.2 Авторизация

Catalog Service реализует модель RBAC (Role-Based Access Control) для контроля доступа к API:

1. **Проверка ролей**:
   - Для каждого запроса проверяется наличие необходимых ролей в заголовке `X-User-Roles`.
   - Используется middleware/interceptor, который проверяет роли до выполнения основной логики обработки запроса.

2. **Проверка владения**:
   - Для некоторых операций (например, обновление продукта) проверяется, является ли пользователь владельцем ресурса (разработчиком/издателем продукта).
   - Это реализуется через проверку `developer_ids` или `publisher_id` в метаданных продукта.

3. **Матрица доступа**:
   - Определяет, какие роли имеют доступ к каким методам API.
   - См. раздел 11.2.3 для полной матрицы доступа.

#### 11.2.3 Матрица доступа

| Метод API                       | Пользователь | Разработчик | Издатель | Модератор | Администратор |
|---------------------------------|--------------|-------------|----------|-----------|---------------|
| **Публичные методы (чтение)**   |              |             |          |           |               |
| GetProduct                      | ✓            | ✓           | ✓        | ✓         | ✓             |
| SearchProducts                  | ✓            | ✓           | ✓        | ✓         | ✓             |
| ListGenres                      | ✓            | ✓           | ✓        | ✓         | ✓             |
| ListTags                        | ✓            | ✓           | ✓        | ✓         | ✓             |
| ListCategories                  | ✓            | ✓           | ✓        | ✓         | ✓             |
| GetAchievementMetadata          | ✓            | ✓           | ✓        | ✓         | ✓             |
| GetPromotion                    | ✓            | ✓           | ✓        | ✓         | ✓             |
| ListPromotions                  | ✓            | ✓           | ✓        | ✓         | ✓             |
| **Методы разработчика/издателя**|              |             |          |           |               |
| CreateProduct                   | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateProduct                   | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| DeleteProduct                   | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateProductPrices             | ✗            | ✗           | ✓*       | ✗         | ✓             |
| AddMedia                        | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateMedia                     | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| DeleteMedia                     | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateProductGenres             | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateProductTags               | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateProductCategories         | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| CreateAchievementMetadata       | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| UpdateAchievementMetadata       | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| DeleteAchievementMetadata       | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| GetDeveloperProducts            | ✗            | ✓           | ✓        | ✗         | ✓             |
| SubmitForModeration             | ✗            | ✓*          | ✓*       | ✗         | ✓             |
| **Методы модератора**           |              |             |          |           |               |
| GetProductInternal              | ✗            | ✗           | ✗        | ✓         | ✓             |
| UpdateProductModerationStatus   | ✗            | ✗           | ✗        | ✓         | ✓             |
| GetProductsForModeration        | ✗            | ✗           | ✗        | ✓         | ✓             |
| RequestAdditionalInfo           | ✗            | ✗           | ✗        | ✓         | ✓             |
| **Методы администратора**       |              |             |          |           |               |
| UpdateProductStatus             | ✗            | ✗           | ✗        | ✗         | ✓             |
| CreatePromotion                 | ✗            | ✗           | ✗        | ✗         | ✓             |
| UpdatePromotion                 | ✗            | ✗           | ✗        | ✗         | ✓             |
| DeletePromotion                 | ✗            | ✗           | ✗        | ✗         | ✓             |
| SetPromotionDiscounts           | ✗            | ✗           | ✗        | ✗         | ✓             |
| AddProductsToPromotion          | ✗            | ✗           | ✓*       | ✗         | ✓             |
| RemoveProductsFromPromotion     | ✗            | ✗           | ✓*       | ✗         | ✓             |
| ApprovePromotion                | ✗            | ✗           | ✗        | ✗         | ✓             |
| ActivatePromotion               | ✗            | ✗           | ✗        | ✗         | ✓             |
| EndPromotion                    | ✗            | ✗           | ✗        | ✗         | ✓             |
| GetProductsForPromotionPreview  | ✗            | ✗           | ✗        | ✗         | ✓             |
| GetPromotionDetails             | ✗            | ✗           | ✗        | ✗         | ✓             |

✓* - Доступ только к собственным ресурсам (продуктам, медиа, достижениям).

### 11.3 Защита данных

#### 11.3.1 Шифрование данных в состоянии покоя

1. **База данных**:
   - Шифрование дисков, на которых хранится БД (например, с помощью AWS EBS encryption, GCP Persistent Disk encryption).
   - Использование встроенных механизмов шифрования PostgreSQL (например, pgcrypto) для особо чувствительных данных.

2. **Elasticsearch**:
   - Шифрование дисков, на которых хранится Elasticsearch.
   - Использование node-to-node encryption для защиты данных внутри кластера.

3. **Кэш (Redis)**:
   - Шифрование дисков, на которых хранится Redis.
   - Использование аутентификации и TLS для подключения к Redis.

4. **Резервные копии**:
   - Шифрование всех резервных копий (бэкапов) перед их сохранением.

#### 11.3.2 Шифрование данных при передаче

1. **Внешние коммуникации**:
   - Использование TLS 1.3 для всех HTTP/gRPC соединений.
   - Строгие настройки TLS (отключение устаревших шифров, использование ECDHE для Perfect Forward Secrecy).

2. **Внутренние коммуникации**:
   - Использование mTLS для взаимной аутентификации и шифрования между сервисами.
   - Использование TLS для подключения к базам данных, Kafka, Redis и другим компонентам.

### 11.4 Защита от распространенных уязвимостей

#### 11.4.1 Инъекции (OWASP A1)

1. **SQL-инъекции**:
   - Использование параметризованных запросов или ORM (GORM) с привязкой параметров.
   - Избегание динамического построения SQL-запросов из пользовательского ввода.
   - Использование принципа наименьших привилегий для БД-пользователя.

2. **NoSQL-инъекции (Elasticsearch)**:
   - Валидация и санитизация всех параметров поиска.
   - Использование DSL вместо строковых запросов.
   - Ограничение сложности и глубины запросов.

#### 11.4.2 Нарушение аутентификации и сессий (OWASP A2)

1. **Защита API-ключей**:
   - Хранение API-ключей в защищенном хранилище (например, Kubernetes Secrets).
   - Регулярная ротация API-ключей.

2. **Защита от подделки межсервисных запросов**:
   - Использование mTLS для аутентификации сервисов.
   - Проверка заголовков и метаданных запросов.

#### 11.4.3 Раскрытие чувствительных данных (OWASP A3)

1. **Логирование**:
   - Не логировать чувствительные данные (пароли, API-ключи, токены).
   - Маскировать чувствительные данные в логах (например, PII).

2. **Ошибки**:
   - Не возвращать детальные сообщения об ошибках внешним пользователям.
   - Использовать общие сообщения об ошибках для публичного API.

#### 11.4.4 XML External Entities (XXE) и Deserialization (OWASP A4, A8)

1. **Парсинг XML**:
   - Отключение DTD и внешних сущностей при парсинге XML (если используется).

2. **Десериализация**:
   - Использование безопасных форматов (JSON, Protocol Buffers) с валидацией схемы.
   - Избегание десериализации недоверенных данных.

#### 11.4.5 Недостатки контроля доступа (OWASP A5)

1. **Проверка авторизации**:
   - Реализация проверки авторизации на уровне API и бизнес-логики.
   - Использование middleware/interceptor для централизованной проверки прав доступа.

2. **Защита от обхода авторизации**:
   - Проверка прав доступа для всех операций, включая чтение и запись.
   - Использование уникальных идентификаторов (UUID) для ресурсов, чтобы предотвратить угадывание ID.

#### 11.4.6 Неправильная настройка безопасности (OWASP A6)

1. **Конфигурация**:
   - Использование безопасных настроек по умолчанию.
   - Регулярный аудит конфигурации на наличие уязвимостей.
   - Использование принципа наименьших привилегий для всех компонентов.

2. **Зависимости**:
   - Регулярное обновление зависимостей для устранения известных уязвимостей.
   - Использование инструментов для сканирования зависимостей (например, OWASP Dependency Check, Snyk).

#### 11.4.7 Cross-Site Scripting (XSS) (OWASP A7)

1. **Защита от XSS**:
   - Валидация и санитизация всех входных данных.
   - Использование Content Security Policy (CSP) на стороне клиента.
   - Экранирование специальных символов при выводе данных.

#### 11.4.8 Небезопасная десериализация (OWASP A8)

1. **Десериализация**:
   - Использование безопасных форматов (JSON, Protocol Buffers) с валидацией схемы.
   - Избегание десериализации недоверенных данных.

#### 11.4.9 Использование компонентов с известными уязвимостями (OWASP A9)

1. **Управление зависимостями**:
   - Регулярное обновление зависимостей.
   - Сканирование зависимостей на наличие уязвимостей.
   - Мониторинг CVE для используемых компонентов.

#### 11.4.10 Недостаточное логирование и мониторинг (OWASP A10)

1. **Логирование событий безопасности**:
   - Логирование всех попыток аутентификации и авторизации.
   - Логирование изменений критических данных (продукты, цены, акции).
   - Логирование аномального поведения (большое количество запросов, необычные паттерны доступа).

2. **Мониторинг**:
   - Настройка алертов на подозрительную активность.
   - Регулярный анализ логов на предмет попыток взлома.

### 11.5 Управление секретами

1. **Хранение секретов**:
   - Использование Kubernetes Secrets или внешнего хранилища секретов (HashiCorp Vault, AWS Secrets Manager) для хранения чувствительных данных (API-ключи, пароли, сертификаты).
   - Не хранить секреты в исходном коде, конфигурационных файлах или переменных окружения напрямую.

2. **Доступ к секретам**:
   - Ограничение доступа к секретам по принципу наименьших привилегий.
   - Аудит доступа к секретам.

3. **Ротация секретов**:
   - Регулярная ротация всех секретов (API-ключи, сертификаты).
   - Автоматизация процесса ротации, где это возможно.

## 12. Тестирование

### 12.1 Стратегия тестирования

Catalog Service должен быть покрыт различными типами тестов для обеспечения качества и надежности.

#### 12.1.1 Unit-тесты

Unit-тесты проверяют отдельные компоненты в изоляции от других частей системы.

**Цели**:
- Проверка корректности бизнес-логики.
- Проверка обработки граничных случаев и ошибок.
- Обеспечение регрессионной безопасности при рефакторинге.

**Инструменты**:
- Стандартный пакет `testing` Go.
- `github.com/stretchr/testify` для более удобных assertions.
- `github.com/golang/mock` для создания моков.

**Покрытие**:
- Целевое покрытие кода: **>80%**.
- Обязательное покрытие критических компонентов: **>90%**.

**Примеры компонентов для тестирования**:
- Сервисы (бизнес-логика).
- Валидаторы.
- Маппинги между DTO и доменными объектами.
- Утилиты и хелперы.

**Пример unit-теста**:

```go
func TestProductService_CalculateFinalPrice(t *testing.T) {
    // Arrange
    mockRepo := mocks.NewMockProductRepository(ctrl)
    service := NewProductService(mockRepo)
    
    product := &domain.Product{
        ID: "test-id",
        Prices: []domain.ProductPrice{
            {
                RegionCode:     "RU",
                CurrencyCode:   "RUB",
                Amount:         1000,
                DiscountAmount: 800,
                DiscountStartDate: time.Now().Add(-24 * time.Hour),
                DiscountEndDate:   time.Now().Add(24 * time.Hour),
            },
        },
    }
    
    mockRepo.EXPECT().GetProductByID(gomock.Any(), "test-id").Return(product, nil)
    
    // Act
    price, err := service.CalculateFinalPrice(context.Background(), "test-id", "RU", "RUB")
    
    // Assert
    assert.NoError(t, err)
    assert.Equal(t, int64(800), price.FinalAmount)
    assert.Equal(t, int64(1000), price.BaseAmount)
    assert.Equal(t, 20, price.DiscountPercentage)
    assert.True(t, price.IsDiscounted)
}
```

#### 12.1.2 Integration-тесты

Integration-тесты проверяют взаимодействие между компонентами системы.

**Цели**:
- Проверка корректности взаимодействия между слоями приложения.
- Проверка взаимодействия с внешними системами (БД, Elasticsearch, Redis, Kafka).
- Выявление проблем интеграции, которые не могут быть обнаружены unit-тестами.

**Инструменты**:
- `testcontainers-go` для запуска контейнеров с зависимостями (PostgreSQL, Elasticsearch, Redis, Kafka).
- `github.com/ory/dockertest` как альтернатива testcontainers.
- `database/sql` и миграции для подготовки тестовой БД.

**Покрытие**:
- Целевое покрытие интеграционных сценариев: **>70%**.

**Примеры сценариев для тестирования**:
- Репозитории (работа с БД).
- Кэширование (работа с Redis).
- Поиск (работа с Elasticsearch).
- Отправка событий (работа с Kafka).
- gRPC-сервисы (end-to-end тестирование API).

**Пример integration-теста**:

```go
func TestProductRepository_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    // Запуск PostgreSQL в контейнере
    ctx := context.Background()
    postgres, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: testcontainers.ContainerRequest{
            Image:        "postgres:14",
            ExposedPorts: []string{"5432/tcp"},
            Env: map[string]string{
                "POSTGRES_USER":     "test",
                "POSTGRES_PASSWORD": "test",
                "POSTGRES_DB":       "testdb",
            },
            WaitingFor: wait.ForLog("database system is ready to accept connections"),
        },
        Started: true,
    })
    if err != nil {
        t.Fatal(err)
    }
    defer postgres.Terminate(ctx)
    
    // Получение порта и подключение к БД
    port, _ := postgres.MappedPort(ctx, "5432")
    host, _ := postgres.Host(ctx)
    dsn := fmt.Sprintf("postgres://test:test@%s:%s/testdb?sslmode=disable", host, port.Port())
    
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        t.Fatal(err)
    }
    defer db.Close()
    
    // Применение миграций
    // ...
    
    // Создание репозитория
    repo := NewProductRepository(db)
    
    // Тест создания продукта
    product := &domain.Product{
        Type:  domain.ProductTypeGame,
        Titles: map[string]string{"en": "Test Game", "ru": "Тестовая Игра"},
        // ...
    }
    
    createdProduct, err := repo.CreateProduct(ctx, product)
    assert.NoError(t, err)
    assert.NotEmpty(t, createdProduct.ID)
    
    // Тест получения продукта
    retrievedProduct, err := repo.GetProductByID(ctx, createdProduct.ID)
    assert.NoError(t, err)
    assert.Equal(t, createdProduct.ID, retrievedProduct.ID)
    assert.Equal(t, "Test Game", retrievedProduct.Titles["en"])
    assert.Equal(t, "Тестовая Игра", retrievedProduct.Titles["ru"])
    // ...
}
```

#### 12.1.3 End-to-End (E2E) тесты

E2E-тесты проверяют работу всего сервиса в условиях, близких к реальным.

**Цели**:
- Проверка работы сервиса как единого целого.
- Проверка взаимодействия с другими сервисами.
- Выявление проблем, которые могут возникнуть в production.

**Инструменты**:
- `testcontainers-go` для запуска контейнеров с зависимостями.
- gRPC-клиенты для вызова API.
- Kubernetes-in-Docker (KinD) или Minikube для тестирования в среде, близкой к production.

**Покрытие**:
- Целевое покрытие ключевых бизнес-сценариев: **>50%**.

**Примеры сценариев для тестирования**:
- Создание и публикация продукта (полный цикл).
- Поиск и фильтрация продуктов.
- Создание и активация акции.
- Модерация контента.

**Пример E2E-теста**:

```go
func TestProductCreationAndPublication_E2E(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping E2E test in short mode")
    }
    
    // Запуск всех зависимостей в контейнерах
    // ...
    
    // Запуск Catalog Service
    // ...
    
    // Создание gRPC-клиента
    conn, err := grpc.Dial(serviceAddr, grpc.WithInsecure())
    if err != nil {
        t.Fatal(err)
    }
    defer conn.Close()
    
    client := catalogv1.NewCatalogServiceClient(conn)
    ctx := context.Background()
    
    // Тест создания продукта
    createResp, err := client.CreateProduct(ctx, &catalogv1.CreateProductRequest{
        Type:        catalogv1.ProductType_PRODUCT_TYPE_GAME,
        DeveloperId: "dev-123",
    })
    assert.NoError(t, err)
    assert.NotEmpty(t, createResp.ProductId)
    
    productId := createResp.ProductId
    
    // Тест обновления продукта
    _, err = client.UpdateProduct(ctx, &catalogv1.UpdateProductRequest{
        ProductId: productId,
        Titles: map[string]string{
            "en": "Test Game",
            "ru": "Тестовая Игра",
        },
        Descriptions: map[string]string{
            "en": "This is a test game",
            "ru": "Это тестовая игра",
        },
        // ...
    })
    assert.NoError(t, err)
    
    // Тест отправки на модерацию
    _, err = client.SubmitForModeration(ctx, &catalogv1.SubmitForModerationRequest{
        ProductId: productId,
    })
    assert.NoError(t, err)
    
    // Тест одобрения модерации
    _, err = client.UpdateProductModerationStatus(ctx, &catalogv1.UpdateProductModerationStatusRequest{
        ProductId:        productId,
        ModerationStatus: catalogv1.ModerationStatus_MODERATION_STATUS_APPROVED,
        ModeratorId:      "mod-123",
    })


    assert.NoError(t, err)
    
    // Тест установки даты релиза
    releaseDate := timestamppb.New(time.Now())
    _, err = client.UpdateProductReleaseDate(ctx, &catalogv1.UpdateProductReleaseDateRequest{
        ProductId:   productId,
        ReleaseDate: releaseDate,
    })
    assert.NoError(t, err)
    
    // Тест получения продукта
    product, err := client.GetProduct(ctx, &catalogv1.GetProductRequest{
        ProductId:    productId,
        RegionCode:   "RU",
        CurrencyCode: "RUB",
        Locale:       "ru-RU",
    })
    assert.NoError(t, err)
    assert.Equal(t, productId, product.Id)
    assert.Equal(t, "Тестовая Игра", product.Titles["ru"])
    assert.Equal(t, "Это тестовая игра", product.Descriptions["ru"])
    // ...
}
```

#### 12.1.4 Нагрузочное тестирование

Нагрузочное тестирование проверяет производительность и масштабируемость сервиса под нагрузкой.

**Цели**:
- Определение максимальной пропускной способности (throughput).
- Измерение времени отклика (latency) при различных уровнях нагрузки.
- Выявление узких мест и проблем масштабируемости.
- Проверка соответствия SLO.

**Инструменты**:
- `ghz` для нагрузочного тестирования gRPC.
- `k6` для нагрузочного тестирования HTTP.
- Prometheus и Grafana для сбора и визуализации метрик.

**Сценарии для тестирования**:
- Поиск и фильтрация продуктов (наиболее частая операция).
- Получение информации о продукте.
- Создание и обновление продуктов.
- Смешанная нагрузка, имитирующая реальное использование.

**Пример скрипта для нагрузочного тестирования gRPC с ghz**:

```bash
ghz --insecure \
    --proto ./catalog.proto \
    --call catalog.v1.CatalogService.GetProduct \
    --data '{"product_id": "test-id", "region_code": "RU", "currency_code": "RUB", "locale": "ru-RU"}' \
    --connections=10 \
    --concurrency=50 \
    --qps=100 \
    --duration=30s \
    --format=summary \
    localhost:8080
```

**Пример скрипта для нагрузочного тестирования HTTP с k6**:

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 50,
  duration: '30s',
  thresholds: {
    http_req_duration: ['p(95)<200'],
    http_req_failed: ['rate<0.01'],
  },
};

export default function() {
  let res = http.get('http://localhost:8080/products/test-id?region=RU&currency=RUB&locale=ru-RU');
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 200ms': (r) => r.timings.duration < 200,
  });
  sleep(1);
}
```

### 12.2 Автоматизация тестирования

Тестирование должно быть автоматизировано и интегрировано в CI/CD-пайплайн.

#### 12.2.1 CI/CD-интеграция

1. **Unit-тесты**:
   - Запускаются при каждом push и pull request.
   - Блокируют мерж при падении.

2. **Integration-тесты**:
   - Запускаются при каждом push в основные ветки и pull request.
   - Блокируют мерж при падении.

3. **E2E-тесты**:
   - Запускаются при мерже в основные ветки.
   - Могут блокировать деплой в production при падении.

4. **Нагрузочное тестирование**:
   - Запускается периодически (например, раз в день) или перед релизом.
   - Результаты сравниваются с предыдущими запусками для выявления регрессий производительности.

#### 12.2.2 Мониторинг качества кода

1. **Покрытие кода**:
   - Измерение покрытия кода тестами при каждом запуске тестов.
   - Блокирование мержа при снижении покрытия ниже установленного порога.

2. **Статический анализ**:
   - Использование линтеров (`golangci-lint`) для проверки качества кода.
   - Использование инструментов для поиска уязвимостей (`gosec`).

3. **Проверка зависимостей**:
   - Сканирование зависимостей на наличие уязвимостей.

## 13. Будущее развитие

### 13.1 Планируемые улучшения

#### 13.1.1 Функциональные улучшения

1. **Расширенные рекомендации**:
   - Интеграция с ML-моделями для персонализированных рекомендаций.
   - A/B-тестирование алгоритмов рекомендаций.

2. **Улучшенный поиск**:
   - Поддержка семантического поиска.
   - Автоматическое исправление опечаток.
   - Поиск по похожему звучанию (фонетический поиск).

3. **Расширенная аналитика**:
   - Интеграция с Analytics Service для сбора и анализа данных о поведении пользователей.
   - Использование этих данных для улучшения поиска и рекомендаций.

4. **Управление контентом**:
   - Поддержка версионирования контента.
   - Планирование публикации контента.
   - Улучшенные инструменты для модерации.

#### 13.1.2 Технические улучшения

1. **Производительность**:
   - Оптимизация запросов к БД.
   - Улучшение стратегий кэширования.
   - Оптимизация индексов Elasticsearch.

2. **Масштабируемость**:
   - Шардирование данных для горизонтального масштабирования.
   - Асинхронная обработка тяжелых операций.

3. **Отказоустойчивость**:
   - Реализация паттерна Circuit Breaker для защиты от каскадных отказов.
   - Улучшение стратегий повторных попыток и таймаутов.

4. **Мониторинг и наблюдаемость**:
   - Расширение метрик и логов для лучшей диагностики проблем.
   - Улучшение дашбордов и алертов.

### 13.2 Потенциальные риски и их митигация

#### 13.2.1 Технические риски

1. **Рост объема данных**:
   - **Риск**: По мере роста каталога производительность запросов может деградировать.
   - **Митигация**: Шардирование данных, оптимизация индексов, архивация старых данных.

2. **Пиковые нагрузки**:
   - **Риск**: Во время распродаж и других событий нагрузка может значительно возрастать.
   - **Митигация**: Автоматическое масштабирование, кэширование, приоритизация запросов.

3. **Зависимость от внешних сервисов**:
   - **Риск**: Отказ зависимых сервисов (БД, Elasticsearch, Redis, Kafka) может привести к недоступности Catalog Service.
   - **Митигация**: Circuit Breaker, fallback-стратегии, репликация данных.

#### 13.2.2 Бизнес-риски

1. **Изменение требований**:
   - **Риск**: Частые изменения бизнес-требований могут привести к техническому долгу.
   - **Митигация**: Гибкая архитектура, модульный дизайн, регулярный рефакторинг.

2. **Масштабирование бизнеса**:
   - **Риск**: Выход на новые рынки может потребовать поддержки новых языков, валют, регионов.
   - **Митигация**: Проектирование с учетом интернационализации и локализации.

3. **Конкуренция**:
   - **Риск**: Конкуренты могут предложить более продвинутые функции каталога.
   - **Митигация**: Регулярный анализ рынка, быстрая реализация новых функций.

## 14. Глоссарий

| Термин | Определение |
|--------|-------------|
| **Продукт (Product)** | Базовая сущность каталога, представляющая игру, DLC, программное обеспечение или комплект. |
| **Игра (Game)** | Тип продукта, представляющий интерактивное программное обеспечение для развлечения. |
| **DLC (Downloadable Content)** | Дополнительный контент к основной игре, распространяемый отдельно. |
| **Комплект (Bundle)** | Набор продуктов, продаваемых вместе по специальной цене. |
| **Разработчик (Developer)** | Компания или физическое лицо, создавшее продукт. |
| **Издатель (Publisher)** | Компания, ответственная за публикацию и распространение продукта. |
| **Жанр (Genre)** | Категория, определяющая тип игрового процесса (например, экшен, стратегия, RPG). |
| **Тег (Tag)** | Ключевое слово или фраза, используемые для классификации и поиска продуктов. |
| **Категория (Category)** | Группировка продуктов по определенному признаку (например, инди, ранний доступ). |
| **Медиа-контент (Media)** | Визуальные и аудиовизуальные материалы, связанные с продуктом (скриншоты, трейлеры, обложки). |
| **Достижение (Achievement)** | Награда, которую игрок может получить за выполнение определенных действий в игре. |
| **Цена (Price)** | Стоимость продукта в определенной валюте для определенного региона. |
| **Скидка (Discount)** | Временное снижение цены продукта. |
| **Акция (Promotion)** | Маркетинговое мероприятие, включающее скидки на группу продуктов. |
| **Модерация (Moderation)** | Процесс проверки контента на соответствие правилам платформы. |
| **Рекомендация (Recommendation)** | Предложение продуктов пользователю на основе его предпочтений или других факторов. |
| **Локализация (Localization)** | Адаптация продукта для определенного языка и региона. |
| **Возрастной рейтинг (Age Rating)** | Ограничение по возрасту для использования продукта (например, 0+, 6+, 12+, 16+, 18+). |
| **Системные требования (System Requirements)** | Минимальные и рекомендуемые характеристики компьютера для запуска продукта. |
| **Франшиза (Franchise)** | Серия связанных продуктов, объединенных общим брендом или вселенной. |
| **Коллекция (Collection)** | Курируемый набор продуктов, объединенных по определенному признаку. |
| **Поисковый запрос (Search Query)** | Текст, введенный пользователем для поиска продуктов. |
| **Фильтр (Filter)** | Критерий для ограничения результатов поиска или просмотра. |
| **Сортировка (Sort)** | Порядок отображения результатов поиска или просмотра. |
| **Пагинация (Pagination)** | Разделение результатов на страницы для удобства просмотра. |
| **Кэш (Cache)** | Временное хранилище данных для ускорения доступа к часто запрашиваемой информации. |
| **Индекс (Index)** | Структура данных в Elasticsearch для быстрого поиска. |
| **Событие (Event)** | Сообщение, отправляемое в Kafka для уведомления других сервисов об изменениях. |
| **API (Application Programming Interface)** | Интерфейс для взаимодействия с сервисом программным способом. |
| **REST API** | API, основанный на принципах REST (Representational State Transfer). |
| **gRPC** | Высокопроизводительный RPC-фреймворк для межсервисного взаимодействия. |
| **Protobuf (Protocol Buffers)** | Формат сериализации данных, используемый в gRPC. |
| **SLO (Service Level Objective)** | Целевой уровень надежности сервиса. |
| **SLI (Service Level Indicator)** | Метрика, используемая для измерения соответствия SLO. |
| **Latency (Задержка)** | Время, необходимое для обработки запроса. |
| **Throughput (Пропускная способность)** | Количество запросов, которое сервис может обработать за единицу времени. |
| **Availability (Доступность)** | Процент времени, в течение которого сервис доступен и работает корректно. |
| **RBAC (Role-Based Access Control)** | Модель контроля доступа, основанная на ролях пользователей. |
| **mTLS (mutual TLS)** | Взаимная аутентификация клиента и сервера с использованием TLS-сертификатов. |
| **Circuit Breaker** | Паттерн проектирования для предотвращения каскадных отказов в распределенных системах. |
| **Fallback** | Запасной вариант действий при недоступности основного пути. |
| **Idempotency** | Свойство операции, при котором многократное выполнение дает тот же результат, что и однократное. |
| **Eventual Consistency** | Модель согласованности, при которой система в конечном итоге достигает согласованного состояния. |
| **Strong Consistency** | Модель согласованности, при которой все чтения возвращают последнее записанное значение. |

# Спецификация микросервиса Payment Service

## Содержание

1. [Введение](#1-введение)
2. [Требования и цели](#2-требования-и-цели)
3. [Архитектура](#3-архитектура)
4. [Бизнес-логика и сценарии использования](#4-бизнес-логика-и-сценарии-использования)
5. [Структура данных и API](#5-структура-данных-и-api)
6. [Интеграции с другими сервисами](#6-интеграции-с-другими-сервисами)
7. [Требования к безопасности, масштабируемости и отказоустойчивости](#7-требования-к-безопасности-масштабируемости-и-отказоустойчивости)
8. [Рекомендации по реализации и развертыванию](#8-рекомендации-по-реализации-и-развертыванию)

## 1. Введение

### 1.1 Назначение документа

Данный документ представляет собой полную спецификацию микросервиса Payment Service для российского аналога платформы Steam. Документ содержит детальное описание требований, архитектуры, бизнес-логики, API, интеграций и нефункциональных требований, необходимых для полной реализации микросервиса. Он предназначен для разработчиков, архитекторов, тестировщиков и менеджеров проекта, обеспечивая единое понимание функциональности и технических аспектов сервиса.

### 1.2 Область применения

Payment Service является критически важным компонентом платформы, отвечающим за обработку платежей, управление транзакциями и финансовыми операциями. Сервис обеспечивает безопасное проведение платежей через различные платежные системы, формирование и хранение фискальных данных, обработку возвратов, управление балансами разработчиков, обработку промокодов и подарочных сертификатов, а также выплаты разработчикам. Данный сервис является ключевым для монетизации платформы и обеспечения финансовых взаимоотношений между пользователями, платформой и разработчиками игр.

### 1.3 Связь с другими микросервисами

Payment Service взаимодействует с несколькими компонентами платформы:

- **Account Service**: Получает данные о пользователях для идентификации и авторизации платежных операций.
- **Catalog Service**: Получает данные о ценах игр и скидках для формирования платежей.
- **Library Service**: Предоставляет информацию о покупках для добавления игр в библиотеку пользователя.
- **Developer Service**: Предоставляет информацию о финансовых операциях и балансах разработчиков.
- **Admin Service**: Предоставляет административный доступ к финансовым операциям и отчетам.
- **Analytics Service**: Предоставляет данные о транзакциях для аналитики и формирования отчетов.

## 2. Требования и цели

### 2.1 Назначение сервиса

Основное назначение Payment Service — обеспечить надежную, безопасную и соответствующую законодательству РФ обработку всех финансовых операций на платформе, включая покупки игр, возвраты средств, использование промокодов и подарочных сертификатов, а также выплаты разработчикам.

### 2.2 Основные цели

1. **Обработка платежей**: Обеспечить обработку платежей через различные российские платежные системы (СБП, МИР, ЮMoney) с высоким уровнем надежности и безопасности.
2. **Управление транзакциями**: Обеспечить надежное хранение и управление всеми финансовыми транзакциями на платформе.
3. **Фискализация**: Обеспечить формирование и хранение фискальных данных (чеков) в соответствии с требованиями 54-ФЗ.
4. **Обработка возвратов**: Реализовать механизмы обработки возвратов средств в соответствии с политикой платформы и законодательством.
5. **Управление балансами**: Обеспечить точный учет и управление финансовыми балансами разработчиков.
6. **Промокоды и подарки**: Реализовать механизмы обработки промокодов и подарочных сертификатов.
7. **Выплаты разработчикам**: Обеспечить своевременные и точные выплаты разработчикам в соответствии с условиями сотрудничества.
8. **Безопасность**: Обеспечить высокий уровень безопасности всех финансовых операций и защиту чувствительных данных.
9. **Соответствие законодательству**: Обеспечить полное соответствие требованиям российского законодательства в области финансовых операций и защиты персональных данных.

### 2.3 Функциональные требования

#### 2.3.1 Обработка платежей

- **Интеграция с платежными системами**: Интеграция с российскими платежными системами (СБП, МИР, ЮMoney) для обработки платежей.
- **Инициирование платежа**: Создание платежной сессии с указанием суммы, валюты, описания и метода оплаты.
- **Обработка платежного колбэка**: Обработка уведомлений от платежных систем о статусе платежа.
- **Проверка статуса платежа**: Возможность проверки текущего статуса платежа.
- **Сохранение платежных методов**: Сохранение информации о платежных методах пользователя для повторного использования (с соблюдением требований безопасности).
- **Поддержка различных валют**: Поддержка рубля как основной валюты с возможностью расширения на другие валюты стран СНГ.
- **Обработка ошибок платежей**: Корректная обработка и логирование ошибок при проведении платежей.

#### 2.3.2 Управление транзакциями

- **Создание транзакций**: Создание записей о всех финансовых операциях на платформе.
- **Отслеживание статуса транзакций**: Отслеживание и обновление статуса транзакций (создана, в процессе, завершена, отменена, ошибка).
- **История транзакций**: Хранение полной истории транзакций для каждого пользователя и разработчика.
- **Детализация транзакций**: Хранение детальной информации о каждой транзакции (сумма, валюта, метод оплаты, описание, связанные сущности).
- **Группировка транзакций**: Возможность группировки транзакций по различным критериям (пользователь, разработчик, игра, период).
- **Экспорт транзакций**: Возможность экспорта истории транзакций в различных форматах (CSV, Excel, PDF).

#### 2.3.3 Фискализация

- **Формирование чеков**: Формирование фискальных чеков в соответствии с требованиями 54-ФЗ.
- **Интеграция с ОФД**: Интеграция с операторами фискальных данных для передачи чеков.
- **Хранение чеков**: Надежное хранение всех сформированных чеков.
- **Доступ к чекам**: Предоставление пользователям доступа к их чекам (просмотр, скачивание, отправка на email).
- **Коррекция чеков**: Возможность коррекции чеков в случае необходимости (с соблюдением требований законодательства).

#### 2.3.4 Обработка возвратов

- **Инициирование возврата**: Возможность инициирования возврата средств (полного или частичного) по запросу пользователя или администратора.
- **Проверка возможности возврата**: Проверка соответствия запроса на возврат политике платформы (срок с момента покупки, использование игры и т.д.).
- **Обработка возврата**: Проведение операции возврата средств через соответствующую платежную систему.
- **Фискализация возврата**: Формирование чека возврата в соответствии с требованиями 54-ФЗ.
- **Отслеживание статуса возврата**: Отслеживание и обновление статуса операции возврата.
- **История возвратов**: Хранение полной истории возвратов для каждого пользователя и разработчика.

#### 2.3.5 Управление балансами разработчиков

- **Учет доходов**: Учет всех доходов разработчиков от продаж их игр.
- **Расчет комиссий**: Расчет комиссий платформы в соответствии с условиями сотрудничества.
- **Отслеживание баланса**: Отслеживание текущего баланса каждого разработчика.
- **История операций**: Хранение полной истории операций по балансу каждого разработчика.
- **Блокировка средств**: Возможность временной блокировки средств (например, на период возможного возврата).
- **Корректировка баланса**: Возможность ручной корректировки баланса администратором (с обязательным логированием).

#### 2.3.6 Промокоды и подарочные сертификаты

- **Создание промокодов**: Возможность создания различных типов промокодов (фиксированная сумма, процент, бесплатная игра).
- **Управление промокодами**: Управление сроком действия, лимитами использования и другими параметрами промокодов.
- **Применение промокодов**: Проверка и применение промокодов при оформлении заказа.
- **Создание подарочных сертификатов**: Возможность создания и продажи подарочных сертификатов.
- **Активация подарочных сертификатов**: Механизм активации подарочных сертификатов пользователями.
- **Отслеживание использования**: Отслеживание использования промокодов и подарочных сертификатов.

#### 2.3.7 Выплаты разработчикам

- **Планирование выплат**: Автоматическое планирование регулярных выплат разработчикам.
- **Инициирование выплат**: Возможность инициирования выплаты разработчику (автоматически по расписанию или вручную).
- **Поддержка различных методов выплат**: Поддержка различных методов выплат (банковский перевод, электронные кошельки).
- **Отслеживание статуса выплат**: Отслеживание и обновление статуса выплат.
- **История выплат**: Хранение полной истории выплат для каждого разработчика.
- **Формирование отчетов**: Формирование финансовых отчетов для разработчиков.
- **Налоговая информация**: Учет налоговой информации и формирование необходимых документов.

### 2.4 Нефункциональные требования

#### 2.4.1 Производительность

- **Время отклика**: Время отклика API не более 500 мс для 95% запросов.
- **Пропускная способность**: Обработка не менее 100 транзакций в секунду.
- **Масштабируемость**: Возможность горизонтального масштабирования для обработки растущего объема транзакций.
- **Время обработки платежа**: Инициирование платежа и перенаправление на платежный шлюз не более 2 секунд.

#### 2.4.2 Надежность и отказоустойчивость

- **Доступность**: Доступность сервиса не менее 99.9% времени.
- **Устойчивость к сбоям**: Сохранение работоспособности при сбоях отдельных компонентов.
- **Восстановление после сбоев**: Автоматическое восстановление после сбоев с минимальной потерей данных.
- **Резервное копирование**: Регулярное резервное копирование всех данных с возможностью быстрого восстановления.
- **Мониторинг**: Комплексный мониторинг всех компонентов системы с автоматическими оповещениями о сбоях.

#### 2.4.3 Безопасность

- **Шифрование данных**: Шифрование всех чувствительных данных при хранении и передаче.
- **Соответствие PCI DSS**: Соответствие требованиям стандарта PCI DSS для обработки платежных карт.
- **Аутентификация и авторизация**: Строгая аутентификация и авторизация для доступа к API и данным.
- **Аудит действий**: Детальное логирование всех действий с финансовыми данными.
- **Защита от мошенничества**: Механизмы выявления и предотвращения мошеннических операций.
- **Защита от атак**: Защита от CSRF, XSS, SQL-инъекций и других типов атак.

#### 2.4.4 Соответствие законодательству

- **54-ФЗ**: Полное соответствие требованиям 54-ФЗ "О применении контрольно-кассовой техники".
- **152-ФЗ**: Соответствие требованиям 152-ФЗ "О персональных данных".
- **115-ФЗ**: Соответствие требованиям 115-ФЗ "О противодействии легализации доходов, полученных преступным путем".
- **Локализация данных**: Хранение персональных данных граждан РФ на территории РФ.

#### 2.4.5 Масштабируемость и расширяемость

- **Горизонтальное масштабирование**: Возможность горизонтального масштабирования всех компонентов системы.
- **Добавление новых платежных методов**: Возможность легкого добавления новых платежных методов.
- **Поддержка новых валют**: Возможность добавления поддержки новых валют.
- **Расширение функциональности**: Модульная архитектура, позволяющая легко расширять функциональность.

## 3. Архитектура

### 3.1 Обзор архитектуры

Payment Service построен на основе микросервисной архитектуры с четким разделением ответственности между компонентами. Сервис обеспечивает высокую надежность, безопасность и масштабируемость, что критически важно для финансовых операций.

### 3.2 Компоненты сервиса

- **API Gateway**: Единая точка входа для всех запросов к сервису, обеспечивающая маршрутизацию, аутентификацию и авторизацию.
- **Transaction Service**: Компонент, отвечающий за создание, обработку и отслеживание всех транзакций.
- **Payment Processing Service**: Компонент, отвечающий за взаимодействие с платежными системами и обработку платежей.
- **Refund Service**: Компонент, отвечающий за обработку возвратов средств.
- **Fiscal Service**: Компонент, отвечающий за формирование и хранение фискальных данных (чеков).
- **Balance Service**: Компонент, отвечающий за управление балансами разработчиков.
- **Promo Service**: Компонент, отвечающий за обработку промокодов и подарочных сертификатов.
- **Payout Service**: Компонент, отвечающий за выплаты разработчикам.
- **Notification Service**: Компонент, отвечающий за отправку уведомлений о финансовых операциях.
- **Reporting Service**: Компонент, отвечающий за формирование финансовых отчетов.
- **Data Storage**: Компонент, отвечающий за хранение всех данных сервиса.
- **Security Service**: Компонент, отвечающий за обеспечение безопасности всех операций.
- **Monitoring Service**: Компонент, отвечающий за мониторинг работы сервиса и выявление аномалий.

### 3.3 Схема взаимодействия компонентов

```
+------------------+    +------------------+    +------------------+
| Другие сервисы   |    | Клиентские       |    | Административные |
| платформы        |    | приложения       |    | интерфейсы       |
+--------+---------+    +--------+---------+    +--------+---------+
         |                       |                       |
         v                       v                       v
+--------------------------------------------------+
|                   API Gateway                    |
+--------------------------------------------------+
         |                       |                       |
         v                       v                       v
+------------------+    +------------------+    +------------------+
| Transaction      |    | Payment          |    | Fiscal           |
| Service          |    | Processing       |    | Service          |
+--------+---------+    | Service          |    +--------+---------+
         |              +--------+---------+            |
         |                       |                      |
         v                       v                      v
+------------------+    +------------------+    +------------------+
| Balance          |    | Refund           |    | Promo            |
| Service          |    | Service          |    | Service          |
+--------+---------+    +--------+---------+    +--------+---------+
         |                       |                       |
         v                       v                       v
+------------------+    +------------------+    +------------------+
| Payout           |    | Notification     |    | Reporting        |
| Service          |    | Service          |    | Service          |
+--------+---------+    +--------+---------+    +--------+---------+
         |                       |                       |
         v                       v                       v
+--------------------------------------------------+
|                   Data Storage                   |
+--------------------------------------------------+
         |                       |                       |
         v                       v                       v
+------------------+    +------------------+    +------------------+
| Security         |    | Monitoring       |    | Внешние          |
| Service          |    | Service          |    | платежные системы|
+------------------+    +------------------+    +------------------+
```

### 3.4 Технологический стек (рекомендуемый)

- **Языки программирования**: Java/Kotlin (для основных сервисов), Go (для высоконагруженных компонентов)
- **Фреймворки**: Spring Boot, Micronaut
- **Базы данных**: PostgreSQL (основное хранилище), Redis (кэширование и временные данные)
- **Очереди сообщений**: Kafka (для асинхронной обработки и интеграции)
- **API**: RESTful API, gRPC (для внутреннего взаимодействия)
- **Контейнеризация**: Docker
- **Оркестрация**: Kubernetes
- **Мониторинг**: Prometheus, Grafana
- **Логирование**: ELK Stack (Elasticsearch, Logstash, Kibana)
- **Безопасность**: Vault (для управления секретами), OAuth 2.0/OpenID Connect

### 3.5 Потоки данных

#### 3.5.1 Поток обработки платежа

1. Пользователь инициирует покупку игры через клиентское приложение.
2. Запрос поступает в API Gateway, который проверяет аутентификацию и авторизацию.
3. API Gateway перенаправляет запрос в Transaction Service.
4. Transaction Service создает новую транзакцию со статусом "создана" и передает запрос в Payment Processing Service.
5. Payment Processing Service определяет доступные методы оплаты и формирует платежную сессию.
6. Пользователь перенаправляется на страницу оплаты выбранной платежной системы.
7. После завершения оплаты платежная система отправляет колбэк в Payment Processing Service.
8. Payment Processing Service обновляет статус транзакции и передает информацию в Fiscal Service.
9. Fiscal Service формирует фискальный чек и отправляет его в ОФД.
10. Transaction Service обновляет статус транзакции на "завершена" и отправляет уведомление в Notification Service.
11. Notification Service отправляет уведомление пользователю о успешной покупке.
12. Balance Service обновляет баланс разработчика.
13. Информация о покупке передается в Library Service для добавления игры в библиотеку пользователя.

#### 3.5.2 Поток обработки возврата

1. Пользователь или администратор инициирует возврат средств.
2. Запрос поступает в API Gateway, который проверяет аутентификацию и авторизацию.
3. API Gateway перенаправляет запрос в Refund Service.
4. Refund Service проверяет возможность возврата (срок с момента покупки, использование игры и т.д.).
5. Если возврат возможен, Refund Service создает новую транзакцию возврата и передает запрос в Payment Processing Service.
6. Payment Processing Service инициирует возврат средств через соответствующую платежную систему.
7. После подтверждения возврата Payment Processing Service обновляет статус транзакции и передает информацию в Fiscal Service.
8. Fiscal Service формирует чек возврата и отправляет его в ОФД.
9. Transaction Service обновляет статус транзакции на "завершена" и отправляет уведомление в Notification Service.
10. Notification Service отправляет уведомление пользователю о успешном возврате.
11. Balance Service корректирует баланс разработчика.
12. Информация о возврате передается в Library Service для удаления игры из библиотеки пользователя.

#### 3.5.3 Поток выплаты разработчику

1. Система автоматически (по расписанию) или администратор вручную инициирует выплату разработчику.
2. Запрос поступает в Payout Service.
3. Payout Service проверяет баланс разработчика и минимальную сумму для выплаты.
4. Если выплата возможна, Payout Service создает новую транзакцию выплаты и передает запрос в Payment Processing Service.
5. Payment Processing Service инициирует перевод средств через выбранный метод выплаты.
6. После подтверждения выплаты Payment Processing Service обновляет статус транзакции.
7. Transaction Service обновляет статус транзакции на "завершена" и отправляет уведомление в Notification Service.
8. Notification Service отправляет уведомление разработчику о успешной выплате.
9. Balance Service обновляет баланс разработчика.
10. Reporting Service обновляет финансовые отчеты.

## 4. Бизнес-логика и сценарии использования

### 4.1 Обработка платежей

#### 4.1.1 Инициирование покупки игры

1. **Предусловия**: Пользователь авторизован, выбрал игру для покупки.
2. **Шаги**:
   - Пользователь нажимает кнопку "Купить" на странице игры.
   - Система проверяет, что игра не находится в библиотеке пользователя.
   - Система получает актуальную цену игры из Catalog Service.
   - Система проверяет наличие активных промокодов или подарочных сертификатов.
   - Система формирует заказ с указанием игры, цены и применимых скидок.
   - Пользователь выбирает метод оплаты.
   - Система создает транзакцию со статусом "создана".
   - Система перенаправляет пользователя на страницу оплаты выбранной платежной системы.
3. **Постусловия**: Создана транзакция, пользователь перенаправлен на страницу оплаты.
4. **Альтернативные сценарии**:
   - Если игра уже в библиотеке пользователя, система показывает соответствующее сообщение.
   - Если возникает ошибка при создании транзакции, система показывает сообщение об ошибке и предлагает повторить попытку.

#### 4.1.2 Обработка платежного колбэка

1. **Предусловия**: Пользователь завершил процесс оплаты на странице платежной системы.
2. **Шаги**:
   - Платежная система отправляет колбэк с результатом операции.
   - Система проверяет подпись колбэка для подтверждения его подлинности.
   - Система находит соответствующую транзакцию по идентификатору.
   - Если платеж успешен, система обновляет статус транзакции на "оплачена".
   - Система формирует фискальный чек и отправляет его в ОФД.
   - Система обновляет баланс разработчика.
   - Система отправляет запрос в Library Service для добавления игры в библиотеку пользователя.
   - Система отправляет уведомление пользователю о успешной покупке.
3. **Постусловия**: Транзакция завершена, игра добавлена в библиотеку пользователя, сформирован фискальный чек, обновлен баланс разработчика.
4. **Альтернативные сценарии**:
   - Если платеж не успешен, система обновляет статус транзакции на "отменена" и отправляет уведомление пользователю.
   - Если возникает ошибка при формировании чека, система логирует ошибку и создает задачу для ручной обработки.

#### 4.1.3 Сохранение платежного метода

1. **Предусловия**: Пользователь успешно совершил платеж и выбрал опцию сохранения платежного метода.
2. **Шаги**:
   - Система получает токен платежного метода от платежной системы.
   - Система проверяет, что у пользователя нет сохраненного метода с таким же токеном.
   - Система сохраняет токен платежного метода в зашифрованном виде.
   - Система отправляет уведомление пользователю о сохранении платежного метода.
3. **Постусловия**: Платежный метод сохранен для будущих платежей.
4. **Альтернативные сценарии**:
   - Если у пользователя уже есть сохраненный метод с таким же токеном, система обновляет существующую запись.
   - Если возникает ошибка при сохранении, система логирует ошибку и отправляет уведомление пользователю.

### 4.2 Управление возвратами

#### 4.2.1 Инициирование возврата пользователем

1. **Предусловия**: Пользователь авторизован, игра находится в библиотеке пользователя, с момента покупки прошло не более 14 дней, игровое время не превышает 2 часов.
2. **Шаги**:
   - Пользователь выбирает игру в своей библиотеке и нажимает кнопку "Запросить возврат".
   - Система проверяет соответствие условиям возврата (срок с момента покупки, игровое время).
   - Если условия соблюдены, система создает запрос на возврат.
   - Система обновляет статус игры в библиотеке пользователя на "в процессе возврата".
   - Система создает транзакцию возврата со статусом "создана".
   - Система инициирует возврат средств через соответствующую платежную систему.
   - После подтверждения возврата система обновляет статус транзакции на "завершена".
   - Система формирует чек возврата и отправляет его в ОФД.
   - Система удаляет игру из библиотеки пользователя.
   - Система корректирует баланс разработчика.
   - Система отправляет уведомление пользователю о успешном возврате.
3. **Постусловия**: Средства возвращены пользователю, игра удалена из библиотеки, сформирован чек возврата, скорректирован баланс разработчика.
4. **Альтернативные сценарии**:
   - Если условия возврата не соблюдены, система показывает соответствующее сообщение.
   - Если возникает ошибка при инициировании возврата, система логирует ошибку и создает задачу для ручной обработки.

#### 4.2.2 Обработка возврата администратором

1. **Предусловия**: Администратор авторизован, имеет права на обработку возвратов.
2. **Шаги**:
   - Администратор находит транзакцию покупки в системе.
   - Администратор проверяет информацию о покупке и причину возврата.
   - Администратор принимает решение о возврате.
   - Если решение положительное, администратор инициирует возврат.
   - Система создает транзакцию возврата со статусом "создана".
   - Система инициирует возврат средств через соответствующую платежную систему.
   - После подтверждения возврата система обновляет статус транзакции на "завершена".
   - Система формирует чек возврата и отправляет его в ОФД.
   - Система удаляет игру из библиотеки пользователя.
   - Система корректирует баланс разработчика.
   - Система отправляет уведомление пользователю о успешном возврате.
3. **Постусловия**: Средства возвращены пользователю, игра удалена из библиотеки, сформирован чек возврата, скорректирован баланс разработчика.
4. **Альтернативные сценарии**:
   - Если администратор отклоняет возврат, система отправляет уведомление пользователю с указанием причины.
   - Если возникает ошибка при инициировании возврата, система логирует ошибку и создает задачу для ручной обработки.

### 4.3 Управление промокодами и подарочными сертификатами

#### 4.3.1 Создание промокода

1. **Предусловия**: Администратор авторизован, имеет права на создание промокодов.
2. **Шаги**:
   - Администратор заполняет форму создания промокода, указывая тип (фиксированная сумма, процент, бесплатная игра), значение, срок действия, лимит использования.
   - Система проверяет корректность введенных данных.
   - Система генерирует уникальный код промокода.
   - Система сохраняет промокод в базе данных.
   - Система отправляет уведомление администратору о успешном создании промокода.
3. **Постусловия**: Промокод создан и готов к использованию.
4. **Альтернативные сценарии**:
   - Если введенные данные некорректны, система показывает соответствующее сообщение.
   - Если возникает ошибка при создании промокода, система логирует ошибку и показывает сообщение об ошибке.

#### 4.3.2 Применение промокода при покупке

1. **Предусловия**: Пользователь авторизован, выбрал игру для покупки, имеет промокод.
2. **Шаги**:
   - Пользователь вводит промокод на странице оформления заказа.
   - Система проверяет существование промокода.
   - Система проверяет срок действия промокода.
   - Система проверяет лимит использования промокода.
   - Система проверяет применимость промокода к выбранной игре.
   - Если все проверки пройдены, система применяет скидку в соответствии с типом промокода.
   - Система обновляет сумму заказа.
   - Система отмечает использование промокода.
3. **Постусловия**: Промокод применен, сумма заказа обновлена.
4. **Альтернативные сценарии**:
   - Если промокод не существует, система показывает соответствующее сообщение.
   - Если срок действия промокода истек, система показывает соответствующее сообщение.
   - Если лимит использования промокода исчерпан, система показывает соответствующее сообщение.
   - Если промокод не применим к выбранной игре, система показывает соответствующее сообщение.

#### 4.3.3 Создание и активация подарочного сертификата

1. **Предусловия**: Пользователь авторизован, выбрал опцию покупки подарочного сертификата.
2. **Шаги**:
   - Пользователь выбирает номинал подарочного сертификата.
   - Пользователь указывает email получателя и опционально персональное сообщение.
   - Система создает заказ на покупку подарочного сертификата.
   - Пользователь оплачивает заказ.
   - После успешной оплаты система генерирует уникальный код подарочного сертификата.
   - Система отправляет email получателю с кодом сертификата и персональным сообщением.
   - Система сохраняет информацию о подарочном сертификате в базе данных.
3. **Постусловия**: Подарочный сертификат создан и отправлен получателю.
4. **Альтернативные сценарии**:
   - Если оплата не успешна, система отменяет создание подарочного сертификата.
   - Если возникает ошибка при отправке email, система логирует ошибку и создает задачу для ручной обработки.

### 4.4 Управление балансами разработчиков

#### 4.4.1 Расчет комиссии платформы

1. **Предусловия**: Успешно завершена транзакция покупки игры.
2. **Шаги**:
   - Система получает информацию о транзакции.
   - Система определяет разработчика игры.
   - Система получает информацию о комиссии платформы для данного разработчика.
   - Система рассчитывает сумму комиссии платформы.
   - Система рассчитывает сумму, подлежащую зачислению на баланс разработчика.
   - Система обновляет баланс разработчика.
   - Система сохраняет информацию о расчете комиссии.
3. **Постусловия**: Рассчитана комиссия платформы, обновлен баланс разработчика.
4. **Альтернативные сценарии**:
   - Если возникает ошибка при расчете комиссии, система логирует ошибку и создает задачу для ручной обработки.

#### 4.4.2 Выплата средств разработчику

1. **Предусловия**: Наступила дата плановой выплаты или разработчик запросил внеплановую выплату, баланс разработчика превышает минимальную сумму для выплаты.
2. **Шаги**:
   - Система проверяет баланс разработчика.
   - Система проверяет наличие всей необходимой информации для выплаты (банковские реквизиты, налоговая информация).
   - Система создает транзакцию выплаты со статусом "создана".
   - Система инициирует перевод средств через выбранный метод выплаты.
   - После подтверждения выплаты система обновляет статус транзакции на "завершена".
   - Система обновляет баланс разработчика.
   - Система отправляет уведомление разработчику о успешной выплате.
   - Система обновляет финансовые отчеты.
3. **Постусловия**: Средства выплачены разработчику, обновлен баланс разработчика, обновлены финансовые отчеты.
4. **Альтернативные сценарии**:
   - Если баланс разработчика меньше минимальной суммы для выплаты, система откладывает выплату до следующей даты.
   - Если отсутствует необходимая информация для выплаты, система отправляет уведомление разработчику с запросом информации.
   - Если возникает ошибка при инициировании выплаты, система логирует ошибку и создает задачу для ручной обработки.

### 4.5 Формирование и хранение фискальных данных

#### 4.5.1 Формирование чека при покупке

1. **Предусловия**: Успешно завершена транзакция покупки игры.
2. **Шаги**:
   - Система получает информацию о транзакции.
   - Система формирует данные для чека в соответствии с требованиями 54-ФЗ.
   - Система отправляет данные чека в ОФД.
   - Система получает фискальные данные от ОФД.
   - Система сохраняет фискальные данные.
   - Система формирует электронный чек.
   - Система отправляет электронный чек пользователю по email.
3. **Постусловия**: Сформирован и отправлен фискальный чек, сохранены фискальные данные.
4. **Альтернативные сценарии**:
   - Если возникает ошибка при отправке данных в ОФД, система повторяет попытку несколько раз.
   - Если после нескольких попыток ошибка сохраняется, система логирует ошибку и создает задачу для ручной обработки.

#### 4.5.2 Формирование чека при возврате

1. **Предусловия**: Успешно завершена транзакция возврата.
2. **Шаги**:
   - Система получает информацию о транзакции возврата.
   - Система находит соответствующую транзакцию покупки и связанные фискальные данные.
   - Система формирует данные для чека возврата в соответствии с требованиями 54-ФЗ.
   - Система отправляет данные чека возврата в ОФД.
   - Система получает фискальные данные от ОФД.
   - Система сохраняет фискальные данные.
   - Система формирует электронный чек возврата.
   - Система отправляет электронный чек возврата пользователю по email.
3. **Постусловия**: Сформирован и отправлен фискальный чек возврата, сохранены фискальные данные.
4. **Альтернативные сценарии**:
   - Если возникает ошибка при отправке данных в ОФД, система повторяет попытку несколько раз.
   - Если после нескольких попыток ошибка сохраняется, система логирует ошибку и создает задачу для ручной обработки.

## 5. Структура данных и API

### 5.1 Модели данных

#### 5.1.1 Транзакции (Transactions)

```sql
CREATE TABLE transactions (
    transaction_id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    type VARCHAR(50) NOT NULL, -- purchase, refund, payout
    status VARCHAR(50) NOT NULL, -- created, processing, completed, failed, cancelled
    amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
    payment_method_id UUID,
    description TEXT,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (payment_method_id) REFERENCES payment_methods(payment_method_id)
);

CREATE TABLE transaction_items (
    transaction_item_id UUID PRIMARY KEY,
    transaction_id UUID NOT NULL,
    item_type VARCHAR(50) NOT NULL, -- game, gift_card, subscription
    item_id UUID NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    price DECIMAL(10, 2) NOT NULL,
    discount DECIMAL(10, 2) NOT NULL DEFAULT 0,
    tax DECIMAL(10, 2) NOT NULL DEFAULT 0,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id)
);

CREATE TABLE transaction_events (
    event_id UUID PRIMARY KEY,
    transaction_id UUID NOT NULL,
    event_type VARCHAR(50) NOT NULL, -- status_change, payment_attempt, notification_sent
    event_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id)
);
```

#### 5.1.2 Платежные методы (Payment Methods)

```sql
CREATE TABLE payment_methods (
    payment_method_id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    type VARCHAR(50) NOT NULL, -- card, sbp, yoomoney
    provider VARCHAR(50) NOT NULL,
    token VARCHAR(255) NOT NULL,
    masked_number VARCHAR(19), -- для карт
    expiry_date VARCHAR(7), -- для карт
    cardholder_name VARCHAR(255), -- для карт
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

#### 5.1.3 Фискальные данные (Fiscal Data)

```sql
CREATE TABLE fiscal_receipts (
    receipt_id UUID PRIMARY KEY,
    transaction_id UUID NOT NULL,
    type VARCHAR(50) NOT NULL, -- sale, refund
    fiscal_document_number VARCHAR(50) NOT NULL,
    fiscal_document_attribute VARCHAR(50) NOT NULL,
    fiscal_receipt_number VARCHAR(50) NOT NULL,
    fiscal_date TIMESTAMP WITH TIME ZONE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    ofd_name VARCHAR(255) NOT NULL,
    receipt_data JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id)
);
```

#### 5.1.4 Балансы разработчиков (Developer Balances)

```sql
CREATE TABLE developer_balances (
    developer_id UUID PRIMARY KEY,
    available_balance DECIMAL(10, 2) NOT NULL DEFAULT 0,
    pending_balance DECIMAL(10, 2) NOT NULL DEFAULT 0,
    total_earned DECIMAL(10, 2) NOT NULL DEFAULT 0,
    total_paid DECIMAL(10, 2) NOT NULL DEFAULT 0,
    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
    last_payout_date TIMESTAMP WITH TIME ZONE,
    next_payout_date TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (developer_id) REFERENCES developers(developer_id)
);

CREATE TABLE developer_balance_history (
    history_id UUID PRIMARY KEY,
    developer_id UUID NOT NULL,
    transaction_id UUID,
    type VARCHAR(50) NOT NULL, -- sale, refund, payout, adjustment
    amount DECIMAL(10, 2) NOT NULL,
    balance_after DECIMAL(10, 2) NOT NULL,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (developer_id) REFERENCES developers(developer_id),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id)
);
```

#### 5.1.5 Промокоды и подарочные сертификаты (Promo Codes and Gift Cards)

```sql
CREATE TABLE promo_codes (
    promo_code_id UUID PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE,
    type VARCHAR(50) NOT NULL, -- fixed_amount, percentage, free_game
    value DECIMAL(10, 2) NOT NULL, -- сумма или процент
    currency VARCHAR(3) DEFAULT 'RUB', -- для fixed_amount
    game_id UUID, -- для free_game
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    max_uses INTEGER,
    current_uses INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_by UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (game_id) REFERENCES games(game_id),
    FOREIGN KEY (created_by) REFERENCES users(user_id)
);

CREATE TABLE gift_cards (
    gift_card_id UUID PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE,
    amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
    remaining_amount DECIMAL(10, 2) NOT NULL,
    purchaser_id UUID NOT NULL,
    recipient_email VARCHAR(255),
    is_activated BOOLEAN NOT NULL DEFAULT FALSE,
    activated_by UUID,
    activated_at TIMESTAMP WITH TIME ZONE,
    expiry_date TIMESTAMP WITH TIME ZONE NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (purchaser_id) REFERENCES users(user_id),
    FOREIGN KEY (activated_by) REFERENCES users(user_id)
);

CREATE TABLE gift_card_transactions (
    transaction_id UUID PRIMARY KEY,
    gift_card_id UUID NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    transaction_type VARCHAR(50) NOT NULL, -- purchase, activation, usage, refund
    related_transaction_id UUID,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (gift_card_id) REFERENCES gift_cards(gift_card_id),
    FOREIGN KEY (related_transaction_id) REFERENCES transactions(transaction_id)
);
```

#### 5.1.6 Выплаты разработчикам (Developer Payouts)

```sql
CREATE TABLE developer_payout_methods (
    payout_method_id UUID PRIMARY KEY,
    developer_id UUID NOT NULL,
    type VARCHAR(50) NOT NULL, -- bank_transfer, yoomoney
    bank_name VARCHAR(255), -- для bank_transfer
    account_number VARCHAR(255), -- зашифровано
    account_holder VARCHAR(255),
    swift_code VARCHAR(50), -- для bank_transfer
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    FOREIGN KEY (developer_id) REFERENCES developers(developer_id)
);

CREATE TABLE developer_payouts (
    payout_id UUID PRIMARY KEY,
    developer_id UUID NOT NULL,
    transaction_id UUID NOT NULL,
    payout_method_id UUID NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
    status VARCHAR(50) NOT NULL, -- created, processing, completed, failed
    reference_number VARCHAR(255),
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (developer_id) REFERENCES developers(developer_id),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id),
    FOREIGN KEY (payout_method_id) REFERENCES developer_payout_methods(payout_method_id)
);
```

### 5.2 API Endpoints (REST)

Все API-эндпоинты требуют аутентификации и авторизации. Доступ к API ограничивается на основе ролей и прав пользователей.

**Префикс**: `/api/v1/payments`

#### 5.2.1 API транзакций

- `POST /transactions` - Создание новой транзакции.
  - Body параметры:
    - `user_id` - ID пользователя.
    - `type` - Тип транзакции (purchase, refund, payout).
    - `amount` - Сумма транзакции.
    - `currency` - Валюта транзакции (по умолчанию RUB).
    - `payment_method_id` - ID метода оплаты (опционально).
    - `description` - Описание транзакции.
    - `metadata` - Дополнительные метаданные.
    - `items` - Массив элементов транзакции.
- `GET /transactions` - Получение списка транзакций с возможностью фильтрации.
  - Query параметры:
    - `user_id` - ID пользователя.
    - `type` - Тип транзакции.
    - `status` - Статус транзакции.
    - `start_date` - Начальная дата.
    - `end_date` - Конечная дата.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /transactions/{transaction_id}` - Получение информации о конкретной транзакции.
- `PATCH /transactions/{transaction_id}` - Обновление статуса транзакции.
  - Body параметры:
    - `status` - Новый статус транзакции.
    - `metadata` - Дополнительные метаданные.
- `GET /transactions/{transaction_id}/events` - Получение истории событий транзакции.
- `GET /transactions/{transaction_id}/receipt` - Получение фискального чека транзакции.

#### 5.2.2 API платежных методов

- `POST /payment-methods` - Создание нового платежного метода.
  - Body параметры:
    - `user_id` - ID пользователя.
    - `type` - Тип платежного метода (card, sbp, yoomoney).
    - `provider` - Провайдер платежного метода.
    - `token` - Токен платежного метода.
    - `masked_number` - Маскированный номер карты (для карт).
    - `expiry_date` - Срок действия карты (для карт).
    - `cardholder_name` - Имя держателя карты (для карт).
    - `is_default` - Флаг "по умолчанию".
    - `metadata` - Дополнительные метаданные.
- `GET /payment-methods` - Получение списка платежных методов пользователя.
  - Query параметры:
    - `user_id` - ID пользователя.
    - `type` - Тип платежного метода.
    - `is_default` - Флаг "по умолчанию".
- `GET /payment-methods/{payment_method_id}` - Получение информации о конкретном платежном методе.
- `PATCH /payment-methods/{payment_method_id}` - Обновление платежного метода.
  - Body параметры:
    - `is_default` - Флаг "по умолчанию".
    - `metadata` - Дополнительные метаданные.
- `DELETE /payment-methods/{payment_method_id}` - Удаление платежного метода.

#### 5.2.3 API возвратов

- `POST /refunds` - Создание нового возврата.
  - Body параметры:
    - `transaction_id` - ID транзакции покупки.
    - `amount` - Сумма возврата (для частичного возврата).
    - `reason` - Причина возврата.
    - `metadata` - Дополнительные метаданные.
- `GET /refunds` - Получение списка возвратов с возможностью фильтрации.
  - Query параметры:
    - `user_id` - ID пользователя.
    - `transaction_id` - ID транзакции покупки.
    - `status` - Статус возврата.
    - `start_date` - Начальная дата.
    - `end_date` - Конечная дата.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /refunds/{refund_id}` - Получение информации о конкретном возврате.
- `PATCH /refunds/{refund_id}` - Обновление статуса возврата.
  - Body параметры:
    - `status` - Новый статус возврата.
    - `metadata` - Дополнительные метаданные.

#### 5.2.4 API промокодов и подарочных сертификатов

- `POST /promo-codes` - Создание нового промокода.
  - Body параметры:
    - `code` - Код промокода (опционально, генерируется автоматически).
    - `type` - Тип промокода (fixed_amount, percentage, free_game).
    - `value` - Значение промокода (сумма или процент).
    - `currency` - Валюта (для fixed_amount).
    - `game_id` - ID игры (для free_game).
    - `start_date` - Дата начала действия.
    - `end_date` - Дата окончания действия.
    - `max_uses` - Максимальное количество использований.
    - `is_active` - Флаг активности.
- `GET /promo-codes` - Получение списка промокодов с возможностью фильтрации.
  - Query параметры:
    - `code` - Код промокода.
    - `type` - Тип промокода.
    - `is_active` - Флаг активности.
    - `start_date` - Начальная дата.
    - `end_date` - Конечная дата.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /promo-codes/{promo_code_id}` - Получение информации о конкретном промокоде.
- `PATCH /promo-codes/{promo_code_id}` - Обновление промокода.
  - Body параметры:
    - `end_date` - Дата окончания действия.
    - `max_uses` - Максимальное количество использований.
    - `is_active` - Флаг активности.
- `DELETE /promo-codes/{promo_code_id}` - Удаление промокода.
- `POST /promo-codes/validate` - Валидация промокода.
  - Body параметры:
    - `code` - Код промокода.
    - `user_id` - ID пользователя.
    - `game_id` - ID игры (опционально).
    - `amount` - Сумма заказа (опционально).

- `POST /gift-cards` - Создание нового подарочного сертификата.
  - Body параметры:
    - `amount` - Сумма сертификата.
    - `currency` - Валюта сертификата.
    - `purchaser_id` - ID покупателя.
    - `recipient_email` - Email получателя.
    - `expiry_date` - Дата истечения срока действия.
- `GET /gift-cards` - Получение списка подарочных сертификатов с возможностью фильтрации.
  - Query параметры:
    - `code` - Код сертификата.
    - `purchaser_id` - ID покупателя.
    - `is_activated` - Флаг активации.
    - `is_active` - Флаг активности.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /gift-cards/{gift_card_id}` - Получение информации о конкретном подарочном сертификате.
- `POST /gift-cards/activate` - Активация подарочного сертификата.
  - Body параметры:
    - `code` - Код сертификата.
    - `user_id` - ID пользователя.
- `POST /gift-cards/apply` - Применение подарочного сертификата к заказу.
  - Body параметры:
    - `code` - Код сертификата.
    - `user_id` - ID пользователя.
    - `amount` - Сумма для списания с сертификата.

#### 5.2.5 API балансов разработчиков

- `GET /developer-balances` - Получение списка балансов разработчиков с возможностью фильтрации.
  - Query параметры:
    - `developer_id` - ID разработчика.
    - `min_balance` - Минимальный баланс.
    - `max_balance` - Максимальный баланс.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /developer-balances/{developer_id}` - Получение информации о балансе конкретного разработчика.
- `GET /developer-balances/{developer_id}/history` - Получение истории операций по балансу разработчика.
  - Query параметры:
    - `type` - Тип операции.
    - `start_date` - Начальная дата.
    - `end_date` - Конечная дата.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `POST /developer-balances/{developer_id}/adjust` - Ручная корректировка баланса разработчика (только для администраторов).
  - Body параметры:
    - `amount` - Сумма корректировки.
    - `description` - Описание корректировки.
    - `metadata` - Дополнительные метаданные.

#### 5.2.6 API выплат разработчикам

- `POST /developer-payout-methods` - Создание нового метода выплаты для разработчика.
  - Body параметры:
    - `developer_id` - ID разработчика.
    - `type` - Тип метода выплаты (bank_transfer, yoomoney).
    - `bank_name` - Название банка (для bank_transfer).
    - `account_number` - Номер счета.
    - `account_holder` - Владелец счета.
    - `swift_code` - SWIFT-код (для bank_transfer).
    - `is_default` - Флаг "по умолчанию".
    - `metadata` - Дополнительные метаданные.
- `GET /developer-payout-methods` - Получение списка методов выплаты разработчика.
  - Query параметры:
    - `developer_id` - ID разработчика.
    - `type` - Тип метода выплаты.
    - `is_default` - Флаг "по умолчанию".
- `GET /developer-payout-methods/{payout_method_id}` - Получение информации о конкретном методе выплаты.
- `PATCH /developer-payout-methods/{payout_method_id}` - Обновление метода выплаты.
  - Body параметры:
    - `is_default` - Флаг "по умолчанию".
    - `metadata` - Дополнительные метаданные.
- `DELETE /developer-payout-methods/{payout_method_id}` - Удаление метода выплаты.

- `POST /developer-payouts` - Создание новой выплаты разработчику.
  - Body параметры:
    - `developer_id` - ID разработчика.
    - `payout_method_id` - ID метода выплаты.
    - `amount` - Сумма выплаты.
    - `currency` - Валюта выплаты.
    - `metadata` - Дополнительные метаданные.
- `GET /developer-payouts` - Получение списка выплат разработчикам с возможностью фильтрации.
  - Query параметры:
    - `developer_id` - ID разработчика.
    - `status` - Статус выплаты.
    - `start_date` - Начальная дата.
    - `end_date` - Конечная дата.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /developer-payouts/{payout_id}` - Получение информации о конкретной выплате.
- `PATCH /developer-payouts/{payout_id}` - Обновление статуса выплаты.
  - Body параметры:
    - `status` - Новый статус выплаты.
    - `reference_number` - Референсный номер выплаты.
    - `metadata` - Дополнительные метаданные.

#### 5.2.7 API фискальных данных

- `GET /fiscal-receipts` - Получение списка фискальных чеков с возможностью фильтрации.
  - Query параметры:
    - `transaction_id` - ID транзакции.
    - `type` - Тип чека (sale, refund).
    - `start_date` - Начальная дата.
    - `end_date` - Конечная дата.
    - `page` - Номер страницы.
    - `limit` - Количество записей на странице.
- `GET /fiscal-receipts/{receipt_id}` - Получение информации о конкретном фискальном чеке.
- `GET /fiscal-receipts/{receipt_id}/download` - Скачивание фискального чека в формате PDF.
- `POST /fiscal-receipts/{receipt_id}/send` - Отправка фискального чека на email.
  - Body параметры:
    - `email` - Email для отправки чека.

### 5.3 Webhook API

Payment Service предоставляет Webhook API для получения уведомлений от платежных систем о статусе платежей.

**Префикс**: `/api/v1/payments/webhooks`

- `POST /webhooks/{provider}` - Эндпоинт для получения уведомлений от платежных систем.
  - Path параметры:
    - `provider` - Провайдер платежной системы (sbp, mir, yoomoney).
  - Body параметры:
    - Зависят от провайдера платежной системы.

### 5.4 Интеграционные API

Payment Service предоставляет интеграционные API для взаимодействия с другими сервисами платформы.

**Префикс**: `/api/v1/payments/integration`

- `POST /integration/purchase-complete` - Уведомление о завершении покупки.
  - Body параметры:
    - `transaction_id` - ID транзакции.
    - `user_id` - ID пользователя.
    - `game_id` - ID игры.
    - `status` - Статус покупки.
    - `metadata` - Дополнительные метаданные.
- `POST /integration/refund-complete` - Уведомление о завершении возврата.
  - Body параметры:
    - `transaction_id` - ID транзакции возврата.
    - `original_transaction_id` - ID исходной транзакции покупки.
    - `user_id` - ID пользователя.
    - `game_id` - ID игры.
    - `status` - Статус возврата.
    - `metadata` - Дополнительные метаданные.

## 6. Интеграции с другими сервисами

### 6.1 Взаимодействие с Account Service

- **Получение данных о пользователях**: Payment Service получает от Account Service данные о пользователях для идентификации и авторизации платежных операций.
- **Проверка прав доступа**: Payment Service запрашивает у Account Service информацию о правах доступа пользователей к различным операциям.
- **Обновление платежной информации**: Payment Service отправляет в Account Service информацию о сохраненных платежных методах пользователя.

### 6.2 Взаимодействие с Catalog Service

- **Получение данных о ценах**: Payment Service получает от Catalog Service актуальную информацию о ценах игр и скидках для формирования платежей.
- **Проверка доступности игр**: Payment Service запрашивает у Catalog Service информацию о доступности игр для покупки.
- **Обновление информации о продажах**: Payment Service отправляет в Catalog Service информацию о продажах игр для обновления статистики.

### 6.3 Взаимодействие с Library Service

- **Добавление игр в библиотеку**: Payment Service отправляет в Library Service информацию о успешных покупках для добавления игр в библиотеку пользователя.
- **Удаление игр из библиотеки**: Payment Service отправляет в Library Service информацию о возвратах для удаления игр из библиотеки пользователя.
- **Проверка наличия игры в библиотеке**: Payment Service запрашивает у Library Service информацию о наличии игры в библиотеке пользователя перед покупкой.

### 6.4 Взаимодействие с Developer Service

- **Предоставление финансовой информации**: Payment Service предоставляет Developer Service информацию о продажах, возвратах и балансах разработчиков.
- **Получение данных о разработчиках**: Payment Service получает от Developer Service информацию о разработчиках для расчета комиссий и выплат.
- **Обновление статуса выплат**: Payment Service отправляет в Developer Service информацию о статусе выплат разработчикам.

### 6.5 Взаимодействие с Admin Service

- **Предоставление административного доступа**: Payment Service предоставляет Admin Service доступ к управлению финансовыми операциями и настройками.
- **Получение административных команд**: Payment Service получает от Admin Service команды на выполнение административных операций (корректировка балансов, отмена транзакций и т.д.).
- **Предоставление финансовых отчетов**: Payment Service предоставляет Admin Service доступ к финансовым отчетам и статистике.

### 6.6 Взаимодействие с Analytics Service

- **Предоставление данных о транзакциях**: Payment Service предоставляет Analytics Service данные о транзакциях для аналитики и формирования отчетов.
- **Предоставление финансовых метрик**: Payment Service предоставляет Analytics Service финансовые метрики для мониторинга и анализа.
- **Получение аналитических данных**: Payment Service получает от Analytics Service аналитические данные для оптимизации процессов и выявления мошенничества.

### 6.7 Интеграция с внешними платежными системами

- **СБП (Система быстрых платежей)**: Интеграция с СБП для обработки платежей через QR-коды и по номеру телефона.
- **МИР**: Интеграция с платежной системой МИР для обработки платежей по картам МИР.
- **ЮMoney**: Интеграция с ЮMoney для обработки платежей через электронные кошельки и банковские карты.
- **Операторы фискальных данных (ОФД)**: Интеграция с ОФД для формирования и передачи фискальных чеков в соответствии с 54-ФЗ.

## 7. Требования к безопасности, масштабируемости и отказоустойчивости

### 7.1 Безопасность

- **Защита платежных данных**: Соответствие требованиям PCI DSS для обработки платежных карт. Шифрование всех чувствительных данных при хранении и передаче. Использование токенизации для хранения платежных методов.
- **Аутентификация и авторизация**: Строгая аутентификация и авторизация для доступа к API и данным. Использование JWT-токенов с коротким сроком действия. Поддержка двухфакторной аутентификации для административных операций.
- **Защита от мошенничества**: Механизмы выявления и предотвращения мошеннических операций. Анализ паттернов транзакций. Блокировка подозрительных операций.
- **Аудит действий**: Детальное логирование всех действий с финансовыми данными. Сохранение истории изменений. Невозможность удаления записей аудита.
- **Защита от атак**: Защита от CSRF, XSS, SQL-инъекций и других типов атак. Ограничение скорости запросов (rate limiting). Валидация всех входных данных.
- **Соответствие законодательству**: Соответствие требованиям 54-ФЗ, 152-ФЗ, 115-ФЗ. Хранение персональных данных граждан РФ на территории РФ.

### 7.2 Масштабируемость

- **Горизонтальное масштабирование**: Возможность горизонтального масштабирования всех компонентов системы для обработки растущего объема транзакций.
- **Асинхронная обработка**: Использование асинхронной обработки для операций, не требующих немедленного ответа (формирование чеков, отправка уведомлений).
- **Кэширование**: Эффективное кэширование часто запрашиваемых данных для снижения нагрузки на базы данных.
- **Шардирование данных**: Шардирование данных по ключевым полям (user_id, transaction_id) для распределения нагрузки.
- **Балансировка нагрузки**: Использование балансировщиков нагрузки для распределения запросов между экземплярами сервисов.
- **Очереди сообщений**: Использование Kafka для асинхронной обработки и интеграции с другими сервисами.

### 7.3 Отказоустойчивость

- **Репликация данных**: Синхронная репликация критически важных данных для обеспечения их сохранности при сбоях.
- **Распределенная архитектура**: Отсутствие единой точки отказа благодаря распределенной архитектуре.
- **Автоматическое восстановление**: Механизмы автоматического восстановления после сбоев с минимальной потерей данных.
- **Резервное копирование**: Регулярное резервное копирование всех данных с возможностью быстрого восстановления.
- **Мониторинг и оповещения**: Комплексный мониторинг всех компонентов системы с автоматическими оповещениями о сбоях.
- **Деградация функциональности**: Механизмы деградации функциональности при недоступности отдельных компонентов.
- **Изоляция сбоев**: Использование паттернов изоляции сбоев (Circuit Breaker, Bulkhead) для предотвращения каскадных отказов.

## 8. Рекомендации по реализации и развертыванию

### 8.1 Реализация

- **Модульность**: Разделение кода на логические модули (транзакции, платежи, возвраты, фискализация) для упрощения разработки и поддержки.
- **Тестирование**: Комплексное тестирование всех компонентов, включая юнит-тесты, интеграционные тесты и нагрузочные тесты. Особое внимание уделить тестированию финансовых расчетов и интеграций с платежными системами.
- **Документация**: Подробная документация API, моделей данных и внутренней архитектуры для упрощения разработки и интеграции.
- **Логирование**: Детальное логирование всех операций с использованием структурированного формата (JSON) для упрощения анализа и отладки.
- **Мониторинг**: Интеграция с системами мониторинга для отслеживания производительности и выявления проблем.
- **Управление зависимостями**: Четкое управление зависимостями и версиями компонентов для обеспечения стабильности и совместимости.
- **Непрерывная интеграция**: Настройка процессов непрерывной интеграции и доставки (CI/CD) для автоматизации тестирования и развертывания.

### 8.2 Развертывание

- **Контейнеризация**: Упаковка всех компонентов в Docker-контейнеры для обеспечения единообразия сред разработки, тестирования и продакшена.
- **Оркестрация**: Использование Kubernetes для управления развертыванием, масштабированием и сетевым взаимодействием контейнеров.
- **Инфраструктура как код**: Использование инструментов IaC (Terraform, Ansible) для автоматизации создания и настройки инфраструктуры.
- **Управление конфигурацией**: Централизованное управление конфигурацией с использованием ConfigMaps и Secrets в Kubernetes или специализированных решений (Consul, Vault).
- **Мониторинг и логирование**: Настройка систем мониторинга (Prometheus, Grafana) и логирования (ELK stack) для отслеживания работы системы.
- **Резервное копирование**: Настройка регулярного резервного копирования всех данных и конфигураций.
- **Управление секретами**: Использование специализированных решений для управления секретами (HashiCorp Vault, Kubernetes Secrets).

### 8.3 Рекомендации по безопасности

- **Аудит безопасности**: Регулярное проведение аудита безопасности, включая статический анализ кода, сканирование уязвимостей и пентесты.
- **Обновление компонентов**: Регулярное обновление всех компонентов системы для устранения известных уязвимостей.
- **Защита от внешних угроз**: Настройка WAF, IDS/IPS и других средств защиты от внешних угроз.
- **Сегментация сети**: Разделение сети на сегменты для изоляции критически важных компонентов.
- **Шифрование данных**: Использование современных алгоритмов шифрования для защиты данных при хранении и передаче.
- **Управление доступом**: Строгое управление доступом к системе с использованием принципа наименьших привилегий.
- **Обучение персонала**: Регулярное обучение персонала по вопросам информационной безопасности.

### 8.4 Рекомендации по производительности

- **Оптимизация запросов**: Оптимизация запросов к базам данных для обеспечения высокой производительности.
- **Индексирование**: Правильное индексирование таблиц баз данных для ускорения запросов.
- **Кэширование**: Многоуровневое кэширование для снижения нагрузки на базы данных и улучшения отзывчивости API.
- **Асинхронная обработка**: Использование асинхронных операций для длительных задач с возможностью отслеживания прогресса.
- **Оптимизация сетевого взаимодействия**: Минимизация сетевого взаимодействия между компонентами, использование эффективных протоколов и форматов данных.
- **Балансировка нагрузки**: Равномерное распределение нагрузки между экземплярами сервисов и базами данных.
- **Мониторинг производительности**: Постоянный мониторинг производительности системы для выявления и устранения узких мест.

### 8.5 Рекомендации по интеграции

- **Стандартизация API**: Использование стандартизированных API для интеграции с другими сервисами платформы и внешними системами.
- **Версионирование API**: Четкое версионирование API для обеспечения обратной совместимости при изменениях.
- **Документация API**: Подробная документация API с примерами запросов и ответов.
- **Мониторинг интеграций**: Мониторинг работы интеграций для своевременного выявления проблем.
- **Тестирование интеграций**: Комплексное тестирование интеграций с другими сервисами и внешними системами.
- **Обработка ошибок**: Корректная обработка ошибок при взаимодействии с другими сервисами и внешними системами.
- **Асинхронное взаимодействие**: Использование асинхронного взаимодействия через Kafka для обеспечения надежности и масштабируемости интеграций.

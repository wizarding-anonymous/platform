# Проект "Российский Аналог Платформы Steam"

## Введение

Это основной файл README для проекта "Российский Аналог Платформы Steam".
Данный проект нацелен на создание комплексной игровой платформы, предоставляющей пользователям доступ к каталогу игр, социальным функциям, системе покупок и многому другому.

## Описание Проекта

Этот проект нацелен на создание "Российского аналога Steam" – комплексной игровой платформы. Платформа будет предоставлять пользователям доступ к обширному каталогу игр, возможность их покупки и загрузки, а также социальные функции для взаимодействия игроков. Ключевыми компонентами системы являются микросервисы, отвечающие за управление аккаунтами, аутентификацию, каталог игр, библиотеку пользователя, платежи, загрузки, социальное взаимодействие, а также сервисы для разработчиков, администрирования, аналитики и уведомлений. Клиентское приложение платформы поддерживает множество операционных систем, включая Windows, Linux, macOS, Android, iOS и Веб. Подробнее см. в [CROSS_PLATFORM_SUPPORT.md](./CROSS_PLATFORM_SUPPORT.md).
**Особое внимание уделяется соответствию требованиям российского законодательства:**
*   **ФЗ-152 "О персональных данных":** Персональные данные российских граждан хранятся и обрабатываются на серверах, физически расположенных на территории Российской Федерации. Платформа использует инфраструктуру российского хостинг-провайдера Beget для размещения своих сервисов и данных.
*   **54-ФЗ "О применении контрольно-кассовой техники":** Обеспечивается фискализация всех релевантных транзакций через интеграцию с Оператором Фискальных Данных (ОФД).
*   Платформа также будет использовать **российские платежные системы** для обработки финансовых операций.
Система проектируется с учетом высоких нагрузок и обеспечения безопасности данных.

Важно отметить, что следующие функции не планируются для реализации в текущей версии платформы: Мастерская/Пользовательский контент (Workshop/User-Generated Content), Стриминг игр (Game Streaming) и Торговая площадка/Обмен внутриигровыми предметами (Marketplace/Trading).

Этот документ и вся документация в данном репозитории призваны обеспечить единое понимание архитектуры, процессов и стандартов разработки для всех участников команды.

## Навигация по Документации

*   **Общепроектная документация:** Находится в корневой директории (например, `project_glossary.md`, `project_api_standards.md`).
*   **Документация по микросервисам:** Находится в директории `backend/<имя-сервиса>/docs/README.md`.
*   **Документация по Frontend приложению:** Находится в директории `frontend/docs/README.md` (основная документация) и `frontend/README.md` (базовый обзор и запуск).

## Начало Работы

### Предварительные требования

Для работы над проектом и запуска микросервисов вам потребуются следующие инструменты:

*   **Go:** версия 1.21+ (основной язык бэкенда)
*   **Flutter SDK:** версия 3.10+ (для разработки клиентских приложений)
    *   **Dart:** версия 3.0+ (поставляется с Flutter SDK)
*   **Docker:** версия 20.10+ (для контейнеризации и локального запуска сервисов)
*   **Docker Compose:** версия v2.0+ (для управления мультиконтейнерными приложениями локально)
*   **Git:** последняя стабильная версия (для контроля версий)
*   **make:** (опционально, для использования Makefile с командами сборки/запуска)
*   **kubectl:** версия 1.25+ (опционально, для взаимодействия с Kubernetes кластером)
*   **Helm:** версия 3.x+ (опционально, для управления Kubernetes-пакетами)
*   **Python:** версия 3.10+ (опционально, для скриптов автоматизации и утилит)
*   **IDE/Редактор кода:** Рекомендуется GoLand, IntelliJ IDEA, VS Code с соответствующими плагинами для Go и Dart/Flutter.
<!-- Важно: Следите за актуальностью версий технологий, указанных в этом документе, и синхронизируйте их с project_technology_stack.md при необходимости. -->

Убедитесь, что все перечисленные инструменты установлены и корректно настроены в вашей системе. Для специфических зависимостей каждого микросервиса обратитесь к его `README.md` в соответствующей директории.

### Настройка Окружения

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL репозитория>
    cd <имя-проекта>
    ```
2.  **Установите Docker и Docker Compose:** Если они еще не установлены, следуйте официальным инструкциям для вашей операционной системы.
3.  **Настройте переменные окружения:**
    *   Скопируйте файл `.env.example` (если он существует в корне проекта или для конкретных сервисов) в `.env`.
    *   Заполните необходимые значения в `.env` файле, такие как учетные данные для баз данных, ключи API для внешних сервисов и т.д. Обратитесь к документации по конкретным сервисам или `docker-compose.yml` для списка необходимых переменных.
4.  **(Опционально) Установите зависимости для локальной разработки без Docker:**
    *   Для Go-сервисов: `go mod download` в директории каждого сервиса.
    *   Для Flutter-клиента: `flutter pub get` в директории клиента.
5.  **Инициализация Git-хуков (если используются):**
    ```bash
    git config core.hooksPath .githooks # Пример, если хуки в .githooks
    ```

### Сборка Проекта

Для сборки проекта и его компонентов вы можете использовать следующие подходы:

**1. Сборка с использованием Docker (рекомендуется для консистентности окружений):**
*   **Сборка всех сервисов (если определено в корневом `docker-compose.yml`):**
    ```bash
    docker-compose build
    ```
*   **Сборка конкретного сервиса:**
    ```bash
    docker-compose build <имя-сервиса-из-compose-файла>
    ```
    Или, если Dockerfile находится в директории сервиса:
    ```bash
    cd backend/<имя-сервиса>/
    docker build -t <имя-образа>:<тег> .
    ```
    (Пример Dockerfile см. в "Стандарты инфраструктурных файлов для продакшен-развертывания.txt")

**2. Локальная сборка Go-сервисов (без Docker):**
*   Перейдите в директорию сервиса:
    ```bash
    cd backend/<имя-сервиса>/
    ```
*   Выполните команду сборки (пример для сервиса, где главный файл в `cmd/service-name/main.go`):
    ```bash
    go build -o ./bin/service-name ./cmd/service-name/
    ```
*   Для сборки с оптимизацией (как в Dockerfile):
    ```bash
    CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o ./bin/service-name ./cmd/service-name/
    ```

**3. Сборка Frontend (Flutter):**
*   Перейдите в директорию клиента:
    ```bash
    cd frontend/ # Или актуальный путь к клиенту
    ```
*   Сборка для Android:
    ```bash
    flutter build apk --release
    # или
    flutter build appbundle --release
    ```
*   Сборка для iOS (требуется macOS и Xcode):
    ```bash
    flutter build ios --release
    ```
*   Сборка для Web:
    ```bash
    flutter build web
    ```
*   Сборка для Desktop (Windows, Linux, macOS):
    ```bash
    flutter build <windows|linux|macos> --release
    ```

**4. Использование Makefile (если предусмотрено):**
*   Проверьте наличие `Makefile` в корне проекта или в директориях сервисов.
*   Часто используемые команды:
    ```bash
    make build                # Собрать все или основной компонент
    make build-service service_name=account-service # Пример
    make clean                # Очистить артефакты сборки
    ```

### Запуск Проекта

**1. Запуск с использованием Docker Compose (рекомендуется для локальной разработки всего стека):**
*   Убедитесь, что вы настроили переменные окружения в файле `.env` (см. раздел "Настройка Окружения").
*   Запустите все сервисы в фоновом режиме:
    ```bash
    docker-compose up -d
    ```
*   Просмотр логов всех сервисов:
    ```bash
    docker-compose logs -f
    ```
*   Просмотр логов конкретного сервиса:
    ```bash
    docker-compose logs -f <имя-сервиса-из-compose-файла>
    ```
*   Остановка всех сервисов:
    ```bash
    docker-compose down
    ```
*   Для доступа к платформе, обратитесь к документации API Gateway или фронтенд-приложения. Обычно это `http://localhost:<порт_API_Gateway>` или `http://localhost:<порт_фронтенда>`.

**2. Локальный запуск отдельного Go-сервиса (без Docker, после сборки):**
*   Перейдите в директорию сервиса.
*   Убедитесь, что все зависимости (например, база данных, Kafka) запущены и доступны.
*   Запустите собранный бинарный файл:
    ```bash
    ./bin/service-name # Или путь к вашему бинарнику
    ```
*   Может потребоваться указание пути к конфигурационному файлу или передача переменных окружения.

**3. Локальный запуск Frontend (Flutter):**
*   Перейдите в директорию клиента:
    ```bash
    cd frontend/ # Или актуальный путь к клиенту
    ```
*   Убедитесь, что эмулятор/симулятор или подключенное устройство готово.
*   Запустите приложение:
    ```bash
    flutter run
    ```
    Для запуска на конкретном устройстве используйте `flutter run -d <device_id>`.

### Запуск Тестов

#### 1. Локальный Запуск Тестов (Local Test Execution)

##### 1.1. Запуск тестов для Go-сервисов:
*   Перейдите в директорию интересующего сервиса:
    ```bash
    cd backend/<имя-сервиса>/
    ```
*   Запуск Unit-тестов:
    ```bash
    go test ./...
    ```
*   Запуск Unit-тестов с выводом покрытия:
    ```bash
    go test -coverprofile=coverage.out ./...
    go tool cover -html=coverage.out # Открыть отчет в браузере
    ```
*   Запуск интеграционных тестов (могут требовать запущенных зависимостей, например, через Docker Compose, или использовать testcontainers):
    *   Обратитесь к `README.md` конкретного сервиса для инструкций по запуску интеграционных тестов. Обычно это может быть команда вида:
        ```bash
        go test -tags=integration ./...
        ```

##### 1.2. Запуск тестов для Frontend (Flutter):
*   Перейдите в директорию клиента:
    ```bash
    cd frontend/ # Или актуальный путь к клиенту
    ```
*   Запуск всех unit и widget тестов:
    ```bash
    flutter test
    ```
*   Пример запуска только unit тестов (если они структурированы в `test/unit_tests/`):
    ```bash
    flutter test test/unit_tests/
    ```
*   Пример запуска только widget тестов (если они структурированы в `test/widget_tests/`):
    ```bash
    flutter test test/widget_tests/
    ```
*   Запуск интеграционных тестов (требуют эмулятор/устройство):
    ```bash
    flutter test integration_test/
    ```
*   Для просмотра отчета о покрытии тестами:
    ```bash
    flutter test --coverage && genhtml coverage/lcov.info -o coverage/html # требует установки lcov
    ```

##### 1.3. Использование Makefile (если предусмотрено):
*   Проверьте наличие `Makefile` в корне проекта или в директориях сервисов.
*   Часто используемые команды:
    ```bash
    make test                # Запустить все тесты (или тесты основного компонента)
    make test-unit           # Запустить только unit-тесты
    make test-integration    # Запустить только интеграционные тесты
    make test-service service_name=account-service # Пример
    ```

#### 2. Тестирование на Сервере / CI (Server/CI Testing)

В дополнение к локальному запуску, все тесты (юнит, интеграционные) автоматически выполняются в рамках CI/CD пайплайнов при каждом изменении кода. Это обеспечивает проверку работоспособности сервисов в окружении, приближенном к продакшену.
Детали конфигурации CI/CD для каждого сервиса можно найти в разделе "Развертывание (Deployment)" его детальной документации (`backend/<имя-сервиса>/docs/README.md`).
Обычно, успешное прохождение всех тестов в CI является обязательным условием для слияния изменений в основную ветку разработки и последующего развертывания.

#### 3. Содействие ИИ в Тестировании (AI Assistance in Testing)

Искусственный интеллект (такой как этот ассистент) может оказывать содействие в процессе тестирования следующим образом:
*   **Написание и обновление тест-кейсов:** Помощь в создании новых юнит-тестов, интеграционных тестов и сценариев e2e-тестирования на основе спецификаций или изменений в коде.
*   **Генерация тестовых данных:** Помощь в создании наборов тестовых данных для различных сценариев.
*   **Анализ покрытия тестами:** Помощь в анализе отчетов о покрытии и выявление нетестированных участков кода.
*   **Рефакторинг тестов:** Предложения по улучшению существующих тестов, делая их более читаемыми и поддерживаемыми.

Важно понимать, что ИИ **не выполняет** тесты самостоятельно в окружении разработчика или на сервере. Запуск тестов осуществляется разработчиками локально или автоматически CI/CD системами, как описано выше.

## Участие в Проекте

Мы приветствуем ваш вклад в развитие проекта! Пожалуйста, придерживайтесь следующих правил при работе над задачами.

### Процесс Внесения Изменений

1.  **Создание Задачи:** Убедитесь, что для вашей работы существует задача (issue) в системе отслеживания. Если нет, создайте новую, подробно описав проблему или предлагаемую функциональность.
2.  **Ветвление:** Создайте новую ветку от актуальной версии ветки `develop`.
3.  **Именование Веток:**
    *   Для новых функций: `feature/XXX-kratkoe-opisanie` (где `XXX` - номер задачи)
    *   Для исправлений ошибок: `bugfix/XXX-kratkoe-opisanie`
    *   Для задач, не связанных напрямую с кодом (документация, настройка CI/CD): `chore/XXX-kratkoe-opisanie`
4.  **Разработка:** Пишите код, следуя установленным стандартам кодирования (см. `CODING_STANDARDS.md`). Не забывайте писать юни-тесты и, при необходимости, интеграционные тесты.
5.  **Коммиты:** Старайтесь делать атомарные коммиты с осмысленными сообщениями, следуя [Conventional Commits](https://www.conventionalcommits.org/).
6.  **Pull Request (PR):** После завершения работы создайте Pull Request в ветку `develop`.
    *   Убедитесь, что CI проверки (сборка, тесты, линтеры) проходят успешно.
    *   В описании PR дайте ссылку на связанную задачу и кратко опишите сделанные изменения.
    *   При необходимости, добавьте скриншоты или инструкции для тестирования.
7.  **Код-Ревью:**
    *   Для каждого PR требуется как минимум **один** апрув от другого члена команды.
    *   Ревьюеры должны обращать внимание на корректность логики, соответствие стандартам, наличие тестов и читаемость кода.
    *   Конструктивно обсуждайте замечания и вносите необходимые исправления.
8.  **Слияние:** После получения апрува и разрешения всех комментариев, PR может быть слит в `develop` (обычно это делает автор PR или тимлид).
9.  **Удаление Ветки:** После слияния PR, удалите свою feature/bugfix ветку.

### Шаблон Pull Request

Шаблон для Pull Request находится в файле `.github/PULL_REQUEST_TEMPLATE.md`. Пожалуйста, используйте его при создании новых Pull Request'ов.

```markdown
## Связанная Задача

Closes #XXX

## Описание Изменений

<!-- Кратко опишите, что было сделано. -->

## Как Протестировать

<!-- Опишите шаги для проверки внесенных изменений. -->

## Чек-лист

- [ ] Код соответствует стандартам кодирования.
- [ ] Написаны или обновлены юни-тесты.
- [ ] Написаны или обновлены интеграционные тесты (если применимо).
- [ ] Документация обновлена (если применимо).
- [ ] CI проверки проходят успешно.
- [ ] Получен как минимум один апрув.
```

---
*Этот документ является живым и будет обновляться по мере развития проекта.*
---
*Последнее обновление документа: 2024-07-16*

# Стандарты Кодирования Проекта "Российский Аналог Платформы Steam"

## 1. Общие Принципы

### 1.1. Язык
*   **Комментарии и документация к коду:** Русский язык. Это упростит понимание внутри команды.
*   **Имена в коде (переменные, функции, классы и т.д.):** Английский язык. Это соответствует общепринятым практикам в программировании и упрощает использование англоязычных библиотек и инструментов.
*   **Сообщения коммитов:** Английский язык (рекомендуется), либо русский, если вся команда придерживается одного языка. Главное – консистентность. (См. раздел "Сообщения коммитов").

### 1.2. Форматирование
*   **Автоматическое форматирование:** Обязательно использовать автоматические форматеры для каждого языка (см. разделы по конкретным языкам).
*   **Отступы:** 4 пробела для большинства языков, если не указано иное в стандартах конкретного языка. Не использовать табы для отступов.
*   **Длина строки:** Рекомендуется не более 120 символов. Для некоторых языков (например, Python) стандарт может быть строже (например, 79 или 99 символов).
*   **Пустые строки:** Использовать для логического разделения блоков кода.

### 1.3. Именование
*   Имена должны быть осмысленными и отражать назначение элемента.
*   Избегать сокращений, если они не являются общепринятыми.
*   Следовать конвенциям именования для конкретного языка (см. ниже).

### 1.4. Принципы Проектирования
*   **DRY (Don't Repeat Yourself):** Избегайте дублирования кода. Используйте функции, классы, модули для переиспользования логики.
*   **KISS (Keep It Simple, Stupid):** Предпочитайте простые и понятные решения сложным.
*   **SOLID (для ООП):** Принципы Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion должны применяться при проектировании классов и модулей.
*   **YAGNI (You Ain't Gonna Need It):** Не добавляйте функциональность, которая не требуется в данный момент.

### 1.5. Стандартизация Пакетов и Библиотек
*   Для обеспечения консистентности и упрощения поддержки, проект придерживается стандартизированного набора библиотек и пакетов для общих задач. Рекомендации по выбору и список стандартных пакетов приведены в документе `PACKAGE_STANDARDIZATION.md`. Перед добавлением новой зависимости в проект, необходимо ознакомиться с этим документом и, при необходимости, следовать процессу предложения новой стандартной библиотеки.

### 1.6. Конфигурационные Файлы
*   Стандарты для конфигурационных файлов (формат, структура, управление секретами) описаны в `project_api_standards.md` (раздел 7) и детализированы в `DOCUMENTATION_GUIDELINES.md` (раздел 6). Код должен придерживаться этих стандартов при чтении конфигураций.

## 2. Стандарты Backend (Go)

См. документ `project_technology_stack.md`, разделы "Стандарты разработки на Go" и "Стандарты работы с PostgreSQL". Ключевые моменты:

*   **Форматирование:** `gofmt` и `goimports`.
*   **Линтинг:** `golangci-lint` с конфигурацией из репозитория `platform-linters-config` (предположим, что такой есть или будет).
*   **Именование:**
    *   Пакеты: `snake_case` (например, `user_service`).
    *   Переменные, функции, типы: `camelCase` или `PascalCase` в соответствии с правилами экспорта Go.
*   **Комментарии:** Стандарты `godoc`. Комментировать публичные API и нетривиальную логику.
*   **Обработка ошибок:**
    *   Явная проверка ошибок (`if err != nil`).
    *   Оборачивание ошибок для добавления контекста: `fmt.Errorf("module: operation failed: %w", err)`.
    *   Определение кастомных типов ошибок для доменной логики.
    *   Логирование ошибок на верхнем уровне обработчика запроса или в специализированных обработчиках ошибок.
*   **Тестирование:**
    *   Unit-тесты для всех критически важных пакетов и функций. Целевое покрытие > 80%.
    *   Именование тестовых функций: `TestFunctionName_StateUnderTest_ExpectedBehavior`.
    *   Использование стандартного пакета `testing` и библиотек `testify/assert`, `testify/mock`.

## 3. Стандарты Frontend (Flutter/Dart)

См. документ `project_technology_stack.md`, раздел "Стандарты разработки на Flutter". Ключевые моменты:

*   **Форматирование:** `dart format`.
*   **Линтинг:** `flutter_lints` или `dart_code_metrics`. Конфигурация в `analysis_options.yaml`.
*   **Именование:**
    *   Файлы: `snake_case.dart` (например, `user_profile_page.dart`).
    *   Классы, enum, typedefs, расширения: `PascalCase`.
    *   Переменные, функции, методы, параметры: `camelCase`.
    *   Константы: `camelCase` или `kPascalCase` (например, `kDefaultPadding`).
*   **Комментарии:** Стандарты `dartdoc`.
*   **Архитектура:** Чистая архитектура (Presentation, Domain, Data), BLoC для управления состоянием.
*   **Тестирование:** Unit-тесты для логики (BLoCs, UseCases, Repositories), Widget-тесты для UI.

## 4. Сообщения Коммитов (Git)

Использовать стандарт **Conventional Commits** (https://www.conventionalcommits.org/).
Это обеспечивает читаемость истории и позволяет автоматизировать генерацию CHANGELOGs и управление версиями.

**Формат:**
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

*   **Основные типы (`<type>`):**
    *   `feat`: Новая функциональность.
    *   `fix`: Исправление ошибки.
    *   `build`: Изменения, влияющие на систему сборки или внешние зависимости (например, Go, Docker, npm).
    *   `chore`: Прочие изменения, не модифицирующие исходный код или тесты (например, обновление зависимостей, настройка CI).
    *   `ci`: Изменения в файлах и скриптах конфигурации CI.
    *   `docs`: Изменения только в документации.
    *   `perf`: Изменения кода, улучшающие производительность.
    *   `refactor`: Рефакторинг кода, который не исправляет ошибок и не добавляет функциональности.
    *   `style`: Изменения, не влияющие на смысл кода (пробелы, форматирование, точки с запятой).
    *   `test`: Добавление или исправление тестов.

*   **Примеры:**
    ```
    feat: добавить возможность аутентификации через VK ID
    ```
    ```
    fix(payment): исправить ошибку округления при расчете комиссии
    ```
    ```
    docs: обновить документацию по API аутентификации
    ```
    ```
    refactor: улучшить читаемость кода в модуле обработки платежей
    ```

## 5. API Design

См. документ `project_api_standards.md`. Ключевые моменты:
*   **REST API:** Версионирование в URL, kebab-case для URL, стандартные HTTP-методы, коды ответов, пагинация, JSON API-подобный формат.
*   **gRPC API:** Версионирование в имени пакета, PascalCase для сервисов и методов, snake_case для полей сообщений.
*   **WebSocket API:** JSON-сообщения с полями `type`, `id`, `payload`.

## 6. Обработка ошибок

*   **Явность:** Ошибки должны обрабатываться явно, а не подавляться.
*   **Контекст:** При перехвате ошибки и её "пробрасывании" выше, добавлять контекст о том, на каком этапе произошла ошибка.
*   **Типизация:** Использовать типизированные ошибки для бизнес-логики, чтобы вышестоящий код мог принимать решения на основе типа ошибки.
*   **Логирование:** Логировать ошибки с достаточным количеством информации (trace_id, user_id, параметры запроса (без чувствительных данных)). Не логировать одну и ту же ошибку на нескольких уровнях стека вызовов.
*   **Пользовательские сообщения:** Не показывать пользователю технические детали ошибок. Предоставлять общие, понятные сообщения и уникальный идентификатор ошибки (trace_id), который можно сообщить в поддержку.

## 7. Документация

*   Весь публичный API (функции, классы, методы) должен быть документирован.
*   Комментарии должны объяснять *почему* код делает то, что он делает, а не *что* он делает (это должно быть понятно из самого кода).
*   Сложные или неочевидные участки кода должны быть прокомментированы.
*   Документация должна поддерживаться в актуальном состоянии.

## 8. Безопасность
*   Следовать принципу наименьших привилегий.
*   Валидировать все входные данные.
*   Использовать параметризованные запросы к базам данных для предотвращения SQL-инъекций.
*   Экранировать данные при выводе в UI для предотвращения XSS.
*   Не хранить чувствительные данные (пароли, ключи API) в коде или конфигурационных файлах. Использовать переменные окружения и системы управления секретами.
*   Регулярно обновлять зависимости для исправления известных уязвимостей.
*   См. также `project_security_standards.md`.

Этот документ является живым и должен обновляться по мере развития проекта и изменения практик в команде.
